{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/express_2.png","path":"images/express_2.png","modified":0,"renderable":0},{"_id":"source/images/express_1.png","path":"images/express_1.png","modified":0,"renderable":0},{"_id":"themes/cactus-light/source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/images/apple-touch-icon.png","path":"images/apple-touch-icon.png","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/images/logo.png","path":"images/logo.png","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/images/favicon-192x192.png","path":"images/favicon-192x192.png","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"source/images/flow.jpg","path":"images/flow.jpg","modified":0,"renderable":0},{"_id":"themes/cactus-light/source/lib/justified-gallery/justifiedGallery.min.css","path":"lib/justified-gallery/justifiedGallery.min.css","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/meslo-LG/styles.css","path":"lib/meslo-LG/styles.css","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/justified-gallery/jquery.justifiedGallery.min.js","path":"lib/justified-gallery/jquery.justifiedGallery.min.js","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/jquery/jquery.min.js","path":"lib/jquery/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGM-BoldItalic.ttf","path":"lib/meslo-LG/fonts/MesloLGM-BoldItalic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGL-Italic.ttf","path":"lib/meslo-LG/fonts/MesloLGL-Italic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGS-BoldItalic.ttf","path":"lib/meslo-LG/fonts/MesloLGS-BoldItalic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGS-Italic.ttf","path":"lib/meslo-LG/fonts/MesloLGS-Italic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGS-Bold.ttf","path":"lib/meslo-LG/fonts/MesloLGS-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGL-Regular.ttf","path":"lib/meslo-LG/fonts/MesloLGL-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGL-BoldItalic.ttf","path":"lib/meslo-LG/fonts/MesloLGL-BoldItalic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGM-Bold.ttf","path":"lib/meslo-LG/fonts/MesloLGM-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGL-Bold.ttf","path":"lib/meslo-LG/fonts/MesloLGL-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGM-Regular.ttf","path":"lib/meslo-LG/fonts/MesloLGM-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGM-Italic.ttf","path":"lib/meslo-LG/fonts/MesloLGM-Italic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGS-Regular.ttf","path":"lib/meslo-LG/fonts/MesloLGS-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/images/theme overview.psd","path":"images/theme overview.psd","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"9ad0023f15c563610361fedd986c87f7186e3395","modified":1569305381816},{"_id":"source/_drafts/code.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1567076499631},{"_id":"themes/cactus-light/LICENSE","hash":"2f1530f30fbec68407daa54391553c3d5ff71f6a","modified":1563501222606},{"_id":"themes/cactus-light/_config.yml","hash":"2274465a87507b51419dfba5dc2016b5e9fe816f","modified":1563501222607},{"_id":"themes/cactus-light/README.md","hash":"da60bf6d6f800de621ea3a2600f4a850ddaff7d2","modified":1563501222607},{"_id":"source/_posts/design-patterns-in-expressjs.md","hash":"07fb91eeb7ebe596ce7100f06a2891338a6ecb60","modified":1603193685097},{"_id":"source/_posts/how-to-write-alfred-workflow.md","hash":"48c7682f4258a622bc372390de2855e1baf05468","modified":1563501222606},{"_id":"source/_drafts/github-desktop.md","hash":"beafe47cdfe42161de3cab60ad49992d28303e2f","modified":1570614483209},{"_id":"source/_drafts/how-koa.md","hash":"23412d70a4eb226ada4765413a9e93f1f5313267","modified":1605851008519},{"_id":"source/_posts/typescript-advanced-type.md","hash":"df82b95cf2a818e9821df924d03be9ea5a86204f","modified":1563501222606},{"_id":"source/_posts/understanding-expressjs.md","hash":"ffebe9630c7487e0f2ae8a68225737a5d85a5660","modified":1604912694737},{"_id":"source/_drafts/mac-guide-series-one.md","hash":"27d2a9a077438a73398a0478459cd67a26eb33e9","modified":1563501222605},{"_id":"source/_drafts/how-to-write-a-vscode-plugin.md","hash":"d26a4738d294a26f676e1051af472ce0c206ef78","modified":1563501222605},{"_id":"source/_drafts/mp-webpack.md","hash":"106a9986db2a2855962965a6411eaec36350d9bd","modified":1596594405242},{"_id":"source/_drafts/how-express.md","hash":"272fad2055381ddd87860f1f9c45468e2887169a","modified":1603359873661},{"_id":"source/_drafts/rollup-ts-react-babel.md","hash":"637c9d7e57359a9e91504f43f9e28446b925fb26","modified":1563501222605},{"_id":"source/_drafts/test-react-component-with-jest-and-enzyme.md","hash":"805e73a7e35a241e29e86908a9bc4f0b18123572","modified":1563501222606},{"_id":"source/_drafts/typescript-in-action.md","hash":"6add8b99e25349eb2723a8d29d3644304242382d","modified":1570614486369},{"_id":"source/_drafts/oop.md","hash":"6a9f745f5910cb781226798af4bcad17200744a0","modified":1605000388263},{"_id":"source/_drafts/webpack-series-one.md","hash":"f43fcd1f1f8bcd0161dcc6cd4936d946490e4069","modified":1563501222606},{"_id":"source/_posts/electron-in-action.md","hash":"e7a391d52a6524145cd2db5524ce60659860fbc6","modified":1570614683441},{"_id":"source/_drafts/what-learned-from-kickstarter.md","hash":"f3086d81712fe87a8fcb19120238e7600bda8457","modified":1596185379350},{"_id":"source/_posts/how-wepback-dev-server-run.md","hash":"4e1d0a1baf3416fce3aaa31d899ddc756ff18711","modified":1600428278191},{"_id":"source/images/express_2.png","hash":"866c7b1c49d9203ad5a6c34144a2e8784007572a","modified":1604909199496},{"_id":"themes/cactus-light/layout/index.ejs","hash":"53196279a25035da55902f4b8f0ebdf7871d39d1","modified":1563501222609},{"_id":"themes/cactus-light/layout/page.ejs","hash":"b6b7b1e6dc856a0e62f35da0151f67ba41143e04","modified":1563501222609},{"_id":"themes/cactus-light/layout/archive.ejs","hash":"ab9798bf534485a4fed4d3089011421858afdd26","modified":1563501222609},{"_id":"themes/cactus-light/scripts/meta.js","hash":"fa6055a39851c9953d033e70c1614547b94dce60","modified":1563501222610},{"_id":"themes/cactus-light/scripts/thumbnail.js","hash":"df8829fd8c3119650037eba5ec11bdce06acff9d","modified":1563501222610},{"_id":"themes/cactus-light/layout/layout.ejs","hash":"8484532ad7c4da22f46fc1394bb2fd9ded34be1f","modified":1563501222609},{"_id":"themes/cactus-light/layout/post.ejs","hash":"2731e597b5d1714a6f5a775c432e99785f02a3e3","modified":1563501222610},{"_id":"source/images/express_1.png","hash":"4856d887892b28d4708e935ceb1c1087aa551dd7","modified":1604903985459},{"_id":"themes/cactus-light/layout/_partial/footer.ejs","hash":"7f6b3f126a58e6734b658ab57bc6b41822bc9342","modified":1563501222607},{"_id":"themes/cactus-light/layout/_partial/comments.ejs","hash":"853a4500da515ef3facc51a055886eaf8efd080d","modified":1563501222607},{"_id":"themes/cactus-light/layout/_partial/header.ejs","hash":"889fe54bbfd1fb3357e8c0614d57a437a72f782a","modified":1563501222608},{"_id":"themes/cactus-light/layout/_partial/head.ejs","hash":"31110d5640046eb59d8f6c217cbe9ff2e92debcb","modified":1563501222607},{"_id":"themes/cactus-light/layout/_partial/pagination.ejs","hash":"ca660c59aec56daa4a7b41715b97434d4a24c37e","modified":1563501222608},{"_id":"themes/cactus-light/layout/_partial/scripts.ejs","hash":"6cffa3adb2f5b93a47f29549ac589c8bce8c223e","modified":1563501222609},{"_id":"themes/cactus-light/layout/_partial/styles.ejs","hash":"e62b799d8ac369d1f1b36bd2649ecc34aec3384c","modified":1563501222609},{"_id":"themes/cactus-light/source/images/favicon.ico","hash":"189f9842bcb79a6f8f9e8445bc8bbd773443826b","modified":1563501222624},{"_id":"themes/cactus-light/source/images/apple-touch-icon.png","hash":"119559ffcb71bed428e88e28401a29aebfed674a","modified":1563501222623},{"_id":"themes/cactus-light/source/images/logo.png","hash":"a25db3e5edb7be2182f4bcae98afb0dd7d6e5353","modified":1563501222624},{"_id":"themes/cactus-light/source/images/favicon-192x192.png","hash":"96e6fcbbb13a5914a6131391e210eb7dfd13d692","modified":1563501222623},{"_id":"themes/cactus-light/source/css/_extend.styl","hash":"faca25132d55e8989d1c1d638e55d1e97de3c561","modified":1563501222611},{"_id":"themes/cactus-light/source/css/_mixins.styl","hash":"c921ceb620deedddd38c9cec28190995e8764bab","modified":1563501222620},{"_id":"themes/cactus-light/source/css/_util.styl","hash":"f8e286a21c7ec3e771d5ddeb2909ac92390af9bd","modified":1563501222622},{"_id":"themes/cactus-light/source/css/style.styl","hash":"ada8a252ea063c5b7ec9e7848e993001ccc0631c","modified":1563501222622},{"_id":"themes/cactus-light/source/css/_variables.styl","hash":"35d671e97f68b258aeb7f19d101a0850c6c20f62","modified":1563501222622},{"_id":"themes/cactus-light/source/js/main.js","hash":"2703a7cb4fc7056d13215b9fde675da426b9cdc4","modified":1563501222646},{"_id":"source/images/flow.jpg","hash":"8f3711b2b4d549e5b6a4ecb2c4b96511a3504bd6","modified":1600425509255},{"_id":"themes/cactus-light/layout/_partial/post/gallery.ejs","hash":"9aecd8908e8a684f33dc20c02497c0f1774137c7","modified":1563501222608},{"_id":"themes/cactus-light/layout/_partial/post/date.ejs","hash":"12a4a7ba6334e3e5c03d9a9601d7779a27c2e082","modified":1563501222608},{"_id":"themes/cactus-light/layout/_partial/post/actions_desktop.ejs","hash":"2319dea76f205c27dd59c994921f66350df8027a","modified":1563501222608},{"_id":"themes/cactus-light/layout/_partial/post/actions_mobile.ejs","hash":"e7638a83e5aaa4bf5b24440ca76fec8eb563bed7","modified":1563501222608},{"_id":"themes/cactus-light/layout/_partial/post/title.ejs","hash":"a060f1c6e3718494a6b1d0e1981ea0bf4e549828","modified":1563501222609},{"_id":"themes/cactus-light/layout/_partial/post/tag.ejs","hash":"bfab03ef986d35ccad583f2d2b575db4a8d2789e","modified":1563501222609},{"_id":"themes/cactus-light/layout/_partial/post/share.ejs","hash":"25a3406f97e976ec13239f0d3f32f9e512511f50","modified":1563501222609},{"_id":"themes/cactus-light/source/css/_highlight/atelier-dune-dark.styl","hash":"df50a85a4b14c7ca6e825d665594b91229d0e460","modified":1563501222612},{"_id":"themes/cactus-light/source/css/_highlight/atelier-estuary-dark.styl","hash":"d84382bc8298f96730757391d3e761b7e640f406","modified":1563501222612},{"_id":"themes/cactus-light/source/css/_highlight/agate.styl","hash":"601eb70448a16b918df132f6fc41e891ae053653","modified":1563501222611},{"_id":"themes/cactus-light/source/css/_highlight/androidstudio.styl","hash":"65d09f1b0e81c6a182f549fd3de51e59823c97ae","modified":1563501222611},{"_id":"themes/cactus-light/source/css/_highlight/arta.styl","hash":"1a5accc115f41d1b669ed708ac6a29abac876599","modified":1563501222611},{"_id":"themes/cactus-light/source/css/_highlight/atelier-lakeside-dark.styl","hash":"bb0a8c4ad0dd8e3e7de7122ddf268fc42aa94acb","modified":1563501222613},{"_id":"themes/cactus-light/source/css/_highlight/atelier-forest-dark.styl","hash":"57c154c6045a038dc7df0a25927853e10bf48c4a","modified":1563501222612},{"_id":"themes/cactus-light/source/css/_highlight/atelier-plateau-dark.styl","hash":"09c64f1a7052aec9070c36c0431df25216afaea1","modified":1563501222613},{"_id":"themes/cactus-light/source/css/_highlight/atelier-cave-dark.styl","hash":"bc647b2c1d971d7cc947aa1ed66e9fd115261921","modified":1563501222612},{"_id":"themes/cactus-light/source/css/_highlight/atelier-heath-dark.styl","hash":"b0cf13b2233e7bc38342032d2d7296591a4c2bcf","modified":1563501222613},{"_id":"themes/cactus-light/source/css/_highlight/atelier-seaside-dark.styl","hash":"ce233a101daea7124cbfcd34add43ccfe2e1e1c7","modified":1563501222614},{"_id":"themes/cactus-light/source/css/_highlight/atelier-savanna-dark.styl","hash":"a16c919a1ccf2f845488078fb341381bec46b1f3","modified":1563501222613},{"_id":"themes/cactus-light/source/css/_highlight/codepen-embed.styl","hash":"f4dcc84d8e39f9831a5efe80e51923fc3054feb0","modified":1563501222614},{"_id":"themes/cactus-light/source/css/_highlight/darkula.styl","hash":"ad0d5728d21645039c9f199e7a56814170ed3bab","modified":1563501222615},{"_id":"themes/cactus-light/source/css/_highlight/atelier-sulphurpool-dark.styl","hash":"414b0cfc142f70afe359c16450b651e28bf7325a","modified":1563501222614},{"_id":"themes/cactus-light/source/css/_highlight/dark.styl","hash":"71ce56d311cc2f3a605f6e2c495ccd7236878404","modified":1563501222615},{"_id":"themes/cactus-light/source/css/_highlight/far.styl","hash":"d9928010ffe71e80b97a5afcba1a4975efdd7372","modified":1563501222615},{"_id":"themes/cactus-light/source/css/_highlight/hopscotch.styl","hash":"b374c6550b89b4751aedc8fbc3cf98d95bd70ead","modified":1563501222615},{"_id":"themes/cactus-light/source/css/_highlight/hybrid.styl","hash":"ea8d7ddc258b073308746385f5cb85aabb8bfb83","modified":1563501222615},{"_id":"themes/cactus-light/source/css/_highlight/ir-black.styl","hash":"693078bbd72a2091ed30f506cc55949600b717af","modified":1563501222616},{"_id":"themes/cactus-light/source/css/_highlight/kimbie.styl","hash":"45dbb168f22d739d0109745d2decd66b5f94e786","modified":1563501222616},{"_id":"themes/cactus-light/source/css/_highlight/obsidian.styl","hash":"55572bbcfee1de6c31ac54681bb00336f5ae826d","modified":1563501222617},{"_id":"themes/cactus-light/source/css/_highlight/monokai-sublime.styl","hash":"25aa2fc1dbe38593e7c7ebe525438a39574d9935","modified":1563501222616},{"_id":"themes/cactus-light/source/css/_highlight/monokai.styl","hash":"bd4b20bdbb3a62972f5c9e52f1f794090b8ff7f9","modified":1563501222616},{"_id":"themes/cactus-light/source/css/_highlight/pojoaque.styl","hash":"77dae9dc41945359d17fe84dbd317f1b40b2ee33","modified":1563501222617},{"_id":"themes/cactus-light/source/css/_highlight/rainbow.styl","hash":"ce73b858fc0aba0e57ef9fb136c083082746bc1d","modified":1563501222618},{"_id":"themes/cactus-light/source/css/_highlight/railscasts.styl","hash":"acd620f8bb7ff0e3fe5f9a22b4433ceef93a05e6","modified":1563501222617},{"_id":"themes/cactus-light/source/css/_highlight/paraiso.styl","hash":"f1537bd868579fa018ecdbfd2eb922dcf3ba2cac","modified":1563501222617},{"_id":"themes/cactus-light/source/css/_highlight/tomorrow-night-bright.styl","hash":"0ac6af6ecb446b5b60d6226748e4a6532db34f57","modified":1563501222619},{"_id":"themes/cactus-light/source/css/_highlight/solarized-dark.styl","hash":"702b9299a48c90124e3ac1d45f1591042f2beccc","modified":1563501222618},{"_id":"themes/cactus-light/source/css/_highlight/tomorrow-night-blue.styl","hash":"8b3087d4422be6eb800935a22eb11e035341c4ba","modified":1563501222618},{"_id":"themes/cactus-light/source/css/_highlight/sunburst.styl","hash":"a0b5b5129547a23865d400cfa562ea0ac1ee3958","modified":1563501222618},{"_id":"themes/cactus-light/source/css/_highlight/tomorrow-night.styl","hash":"19b3080d4b066b40d50d7e7f297472482b5801fd","modified":1563501222619},{"_id":"themes/cactus-light/source/css/_highlight/tomorrow-night-eighties.styl","hash":"fa57b3bb7857a160fc856dbe319b31e30cc5d771","modified":1563501222619},{"_id":"themes/cactus-light/source/css/_highlight/zenburn.styl","hash":"fc5ec840435dad80964d04519d3f882ddc03746a","modified":1563501222619},{"_id":"themes/cactus-light/source/css/_partial/archive.styl","hash":"18fa7f84a9783c5fb56c9f450ea93bd88408e682","modified":1563501222620},{"_id":"themes/cactus-light/source/css/_partial/footer.styl","hash":"b7570de60eaf9aa6b0192bf9c71b9172ff11bfbc","modified":1563501222621},{"_id":"themes/cactus-light/source/css/_partial/article.styl","hash":"b90c7eebe9b39110aac089d65155e937dc1836e9","modified":1563501222620},{"_id":"themes/cactus-light/source/css/_partial/comments.styl","hash":"11fb41241a13971d23fc3f7e6d60315c7f248396","modified":1563501222620},{"_id":"themes/cactus-light/source/css/_partial/header.styl","hash":"63707d9103a283147ca222fd6f8ff9bffbffe427","modified":1563501222621},{"_id":"themes/cactus-light/source/css/_partial/index.styl","hash":"cf43702450ea1e5617541501886982a394cff8ec","modified":1563501222621},{"_id":"themes/cactus-light/source/css/_partial/pagination.styl","hash":"f483e0b4e8aefaa81f5e1e5e8ab7c54f70557f75","modified":1563501222621},{"_id":"themes/cactus-light/source/lib/justified-gallery/justifiedGallery.min.css","hash":"13fbcba5e97aa88b748d94d3efc4718475279907","modified":1563501222657},{"_id":"themes/cactus-light/source/lib/meslo-LG/styles.css","hash":"eb88d0b9f1bbef99070e9627e2c96d892036bf7e","modified":1563501222687},{"_id":"themes/cactus-light/source/lib/justified-gallery/jquery.justifiedGallery.min.js","hash":"b2683e7a872bc109b1756a65188a37cef7d0bd5c","modified":1563501222657},{"_id":"themes/cactus-light/source/css/_partial/post/actions_desktop.styl","hash":"e05dbc1022cfe14828dad8499c7a8a6b93f71598","modified":1563501222621},{"_id":"themes/cactus-light/source/css/_partial/post/actions_mobile.styl","hash":"dce6466e2ab708854c9e15173bfc19e5715d4303","modified":1563501222622},{"_id":"themes/cactus-light/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1563501222647},{"_id":"themes/cactus-light/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1563501222647},{"_id":"themes/cactus-light/source/lib/jquery/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1563501222656},{"_id":"themes/cactus-light/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1563501222655},{"_id":"themes/cactus-light/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1563501222655},{"_id":"themes/cactus-light/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1563501222649},{"_id":"themes/cactus-light/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1563501222654},{"_id":"themes/cactus-light/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1563501222650},{"_id":"themes/cactus-light/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1563501222653},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGM-BoldItalic.ttf","hash":"65ddb11e75ee93909e845ab912a36717c48f1c94","modified":1563501222678},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGL-Italic.ttf","hash":"96c97a0a098ca40802f948ae56fa37aa6683d034","modified":1563501222670},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGS-BoldItalic.ttf","hash":"d895a1bd25e36c58b7f463ebe14de09f186d5ab4","modified":1563501222684},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGS-Italic.ttf","hash":"7f7cdbdcc26279c04046632e22d872f111bc9399","modified":1563501222686},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGS-Bold.ttf","hash":"df202ce09cbdc70bc16b81983a13ef0f94e46f10","modified":1563501222683},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGL-Regular.ttf","hash":"2b912dd13f052f645ee19951604610bb350d50af","modified":1563501222674},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGL-BoldItalic.ttf","hash":"a9a431fc7a6c3a67c98021d4035c12a07a4f1070","modified":1563501222666},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGM-Bold.ttf","hash":"a8a8df3393bccc365335fc5eb0a62a6b7ccd32b9","modified":1563501222675},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGL-Bold.ttf","hash":"bfa1ed9a263ed78462f06d322de13bd5bd0906b2","modified":1563501222662},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGM-Regular.ttf","hash":"5e220152adefe905b2197f873d7cee99eca50e91","modified":1563501222682},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGM-Italic.ttf","hash":"68700db02debd4b922304134da83b829cbfddfc9","modified":1563501222681},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGS-Regular.ttf","hash":"56fa0e33a390b704afc56af93a31576ccdbbdd9e","modified":1563501222687},{"_id":"themes/cactus-light/source/images/theme overview.psd","hash":"8dc11d9d289c247423911e962c4eb3a556dc67d1","modified":1563501222646},{"_id":"source/_posts/how-koa.md","hash":"813cd9d4b2790a5cb294524f46f019c77a6b1f1e","modified":1605870996369},{"_id":"public/archives/index.html","hash":"2f16eb938337e9802cdb2f6e784e06ff8a2801cb","modified":1605871012185},{"_id":"public/archives/2018/index.html","hash":"6591cfe238ff17d755ad7ce3beeca46a823b9fdd","modified":1605871012185},{"_id":"public/archives/2018/12/index.html","hash":"4182106cc82279922f94038727a3574019132a20","modified":1605871012259},{"_id":"public/archives/2019/index.html","hash":"f46af930ac4bcda37416329ae088b12111294fe7","modified":1605871012259},{"_id":"public/archives/2019/06/index.html","hash":"cac446e8d53ea9c888e57bddae63c61c39079e8d","modified":1605871012260},{"_id":"public/archives/2019/09/index.html","hash":"966a8ddb20291dc7f4a7e49289237d7e9a4e99c4","modified":1605871012260},{"_id":"public/archives/2020/index.html","hash":"8a786884d5bfdbdc5ead0424fd25474606775578","modified":1605871012260},{"_id":"public/archives/2020/09/index.html","hash":"25564c7f2c9fea2fcf6e117acd34620d9d73f851","modified":1605871012260},{"_id":"public/archives/2020/10/index.html","hash":"2d3e9c18d917a2a9240096c7e9c2cbdecad08a7c","modified":1605871012260},{"_id":"public/index.html","hash":"c036fb9328137fdaa0429bf49f71c97bc83be02c","modified":1605871012260},{"_id":"public/2020/10/20/design-patterns-in-expressjs/index.html","hash":"00d5c6ea1be2f43cd1e668d59d57dff0a5871a2a","modified":1605871012260},{"_id":"public/2020/09/18/how-wepback-dev-server-run/index.html","hash":"a36f2cc82194154c09eab31c4a2be891c2debe02","modified":1605871012260},{"_id":"public/2019/09/24/electron-in-action/index.html","hash":"25613e7590b2b4510c34785507eac3047bace018","modified":1605871012261},{"_id":"public/2019/06/19/typescript-advanced-type/index.html","hash":"901f257dc372864e83c8b0d03298136c03eb47c7","modified":1605871012261},{"_id":"public/2018/12/04/how-to-write-alfred-workflow/index.html","hash":"07b95d4e57fd62ff62ffda97b822b1c7dfd566e6","modified":1605871012261},{"_id":"public/archives/2020/11/index.html","hash":"94817317a0106f8407e81bee3496af5b90320bf3","modified":1605871012262},{"_id":"public/2020/11/09/understanding-expressjs/index.html","hash":"27fad88d674dee457d2dded576cb2a6ca8f7a0fe","modified":1605871012262},{"_id":"public/2020/10/16/how-koa/index.html","hash":"ca8020e5cee714eab29d7b9f7a38f8b62ab65bd9","modified":1605871012262},{"_id":"public/images/express_2.png","hash":"866c7b1c49d9203ad5a6c34144a2e8784007572a","modified":1605871012263},{"_id":"public/images/express_1.png","hash":"4856d887892b28d4708e935ceb1c1087aa551dd7","modified":1605871012267}],"Category":[],"Data":[],"Page":[],"Post":[{"_content":"","source":"_drafts/code.md","raw":"","slug":"code","published":0,"date":"2019-08-29T08:54:12.175Z","updated":"2019-08-29T11:01:39.631Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhpu92w70000ak875sqm29f5","content":"<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"excerpt":"","more":""},{"title":"【译】Express 中的设计模式","date":"2020-10-20T10:03:25.000Z","_content":"\n[原文链接](https://dzone.com/articles/design-patterns-in-expressjs)\n\nExpress 是一种保持最低程度规模的灵活 Node.js Web 应用程序框架，为 Web 和移动应用程序提供一组强大的功能。\n\n下面是一些当我们使用 Express 时可能会看到的一些设计模式。\n\n## 工厂模式\n\n这是 JavaScript 语言中一个简单和常用的设计模式。工厂模式是一种创新的设计模式可以让我们从外部世界中抽象出对象实现细节。Express 通过导出工厂实现这种模式。\n\n```js\n/**\n * Expose `createApplication()`.\n */\n\nexports = module.exports = createApplication;\n\nfunction createApplication() {\n  var app = function(req, res, next) {\n    app.handle(req, res, next);\n  };\n  ...\n  return app;\n}\n```\n\n另外，使用工厂模式创造一个 express 应用就如下面代码所示这么简单\n\n```js\nimport express from 'express';\n..\nconst app = express();\n```\n\n## 中间件\n\n中间件是一个被 Express.js 带火的术语。\n\n事实上，我们可以把这种设计模式看成 [拦截过滤](http://www.oracle.com/technetwork/java/interceptingfilter-142169.html) 和 [职责链模式](http://www.oracle.com/technetwork/java/interceptingfilter-142169.html) 的一种变体。\n\n![alt](https://vietcanho.files.wordpress.com/2016/06/middleware.png?w=1462)\n\n关于该模式的更多信息-点击 [这里](https://dzone.com/articles/understanding-middleware-pattern-in-expressjs)\n\n## 装饰器模式\n\n装饰器模式动态地扩展（装饰）了一个对象的行为。它和经典的继承不同，因为新的行为是在运行时被添加的，并且只被添加到被装饰的对象上（并非类上）。\n\n![alt](https://dzone.com/storage/temp/2440958-decorator.png)\n\n这种模式的一个简单示例是 [req](http://expressjs.com/en/4x/api.html#req) 和 [resp](http://expressjs.com/en/4x/api.html#res) ，在 Node 中，请求和响应对象的 API 是有限的。Express 通过使用一些新的特性装饰它们从而扩展了这些对象。\n\n以下就是接收 request (req) 和 response (resp) 对象并且装饰它们的函数。\n\n```js\n///lib/middleware/init.js\nexports.init = function(app){\n  return function expressInit(req, res, next){\n    if (app.enabled('x-powered-by')) res.setHeader('X-Powered-By', 'Express');\n    req.res = res;\n    res.req = req;\n    req.next = next;\n\n    req.__proto__ = app.request;\n    res.__proto__ = app.response;\n\n    res.locals = res.locals || Object.create(null);\n\n    next();\n  };\n};\n```\n\n## 策略模式\n\n> 定义一组算法，对每一个算法进行封装，让他们变得可被替换。策略模式让算法非常独立于使用它的客户。\n\n![alt](https://dzone.com/storage/temp/2442910-strategy.png)\n\n它让一个策略（算法）在运行时在不被客户意识到的情况下被任何其他策略所替换。\n\n在 Express 中，策略模式能在 Express 支持不同的模板引擎（例如 Pug, Mustache, EJS, swig等等）的实现中看到。在 [这里](https://github.com/expressjs/express/wiki?_ga=1.216495568.777274470.1463719254#template-engines) 可以看到 Express 支持的渲染引擎的完整列表。\n\n\n```js\nimport express from 'express';\nimport exphbs from 'express-handlebars';\n...\nconst app = express();\napp.engine('.html', exphbs({...}));\napp.engine('jade', require('jade').__express);\n\n//Select the strategy '.html'\napp.set('view engine', '.html');\n```\n\n另一个例子是 Express 如何支持 [内容协商](https://www.w3.org/Protocols/rfc2616/rfc2616-sec12.html)\n\n## 代理模式\n\n这种设计模式提供了一个叫做 **Proxy** 的对象用于控制另一个叫 **Subject** 的对象的访问。**Proxy** 对象和 Subject 对象具有相同的接口。**Proxy** 位于客户和 Subject 对象之间，它拦截了所有或者部分的请求，然后将这些请求转发给 **Subject**\n\n![alt](https://dzone.com/storage/temp/2442923-proxy.png)\n\nExpress 有两种类型的中间件：\n\n应用级中间件\n\n路由级中间件\n\n除了 应用级中间件 是绑定在一个应用（application）对象上且 路由级中间件 是绑定在 路由（router）实例上的区别外，它们都是一样的。所以 Express 是怎么实现这个功能的呢？通过 **组合（composition）**！express 的应用（application）对象拥有对 路由（Router) 实例对象的内部引用。\n\n\n```js\nthis._router = new Router({\n      caseSensitive: this.enabled('case sensitive routing'),\n      strict: this.enabled('strict routing')\n});\n\nthis._router.use(query(this.get('query parser fn')));\nthis._router.use(middleware.init(this));\n```\n\n使用每个受支持的API，在将请求转发到内部路由器（Router）实例之前，应用（application）对象将进行一些逻辑检查和验证。\n\n注意: 还有许多其他的设计模式我没有在这里列出来，比如单例模式，懒初始化模式，事件发射器模式。\n\n","source":"_posts/design-patterns-in-expressjs.md","raw":"---\ntitle: 【译】Express 中的设计模式\ndate: 2020-10-20 18:03:25\ntags:\n---\n\n[原文链接](https://dzone.com/articles/design-patterns-in-expressjs)\n\nExpress 是一种保持最低程度规模的灵活 Node.js Web 应用程序框架，为 Web 和移动应用程序提供一组强大的功能。\n\n下面是一些当我们使用 Express 时可能会看到的一些设计模式。\n\n## 工厂模式\n\n这是 JavaScript 语言中一个简单和常用的设计模式。工厂模式是一种创新的设计模式可以让我们从外部世界中抽象出对象实现细节。Express 通过导出工厂实现这种模式。\n\n```js\n/**\n * Expose `createApplication()`.\n */\n\nexports = module.exports = createApplication;\n\nfunction createApplication() {\n  var app = function(req, res, next) {\n    app.handle(req, res, next);\n  };\n  ...\n  return app;\n}\n```\n\n另外，使用工厂模式创造一个 express 应用就如下面代码所示这么简单\n\n```js\nimport express from 'express';\n..\nconst app = express();\n```\n\n## 中间件\n\n中间件是一个被 Express.js 带火的术语。\n\n事实上，我们可以把这种设计模式看成 [拦截过滤](http://www.oracle.com/technetwork/java/interceptingfilter-142169.html) 和 [职责链模式](http://www.oracle.com/technetwork/java/interceptingfilter-142169.html) 的一种变体。\n\n![alt](https://vietcanho.files.wordpress.com/2016/06/middleware.png?w=1462)\n\n关于该模式的更多信息-点击 [这里](https://dzone.com/articles/understanding-middleware-pattern-in-expressjs)\n\n## 装饰器模式\n\n装饰器模式动态地扩展（装饰）了一个对象的行为。它和经典的继承不同，因为新的行为是在运行时被添加的，并且只被添加到被装饰的对象上（并非类上）。\n\n![alt](https://dzone.com/storage/temp/2440958-decorator.png)\n\n这种模式的一个简单示例是 [req](http://expressjs.com/en/4x/api.html#req) 和 [resp](http://expressjs.com/en/4x/api.html#res) ，在 Node 中，请求和响应对象的 API 是有限的。Express 通过使用一些新的特性装饰它们从而扩展了这些对象。\n\n以下就是接收 request (req) 和 response (resp) 对象并且装饰它们的函数。\n\n```js\n///lib/middleware/init.js\nexports.init = function(app){\n  return function expressInit(req, res, next){\n    if (app.enabled('x-powered-by')) res.setHeader('X-Powered-By', 'Express');\n    req.res = res;\n    res.req = req;\n    req.next = next;\n\n    req.__proto__ = app.request;\n    res.__proto__ = app.response;\n\n    res.locals = res.locals || Object.create(null);\n\n    next();\n  };\n};\n```\n\n## 策略模式\n\n> 定义一组算法，对每一个算法进行封装，让他们变得可被替换。策略模式让算法非常独立于使用它的客户。\n\n![alt](https://dzone.com/storage/temp/2442910-strategy.png)\n\n它让一个策略（算法）在运行时在不被客户意识到的情况下被任何其他策略所替换。\n\n在 Express 中，策略模式能在 Express 支持不同的模板引擎（例如 Pug, Mustache, EJS, swig等等）的实现中看到。在 [这里](https://github.com/expressjs/express/wiki?_ga=1.216495568.777274470.1463719254#template-engines) 可以看到 Express 支持的渲染引擎的完整列表。\n\n\n```js\nimport express from 'express';\nimport exphbs from 'express-handlebars';\n...\nconst app = express();\napp.engine('.html', exphbs({...}));\napp.engine('jade', require('jade').__express);\n\n//Select the strategy '.html'\napp.set('view engine', '.html');\n```\n\n另一个例子是 Express 如何支持 [内容协商](https://www.w3.org/Protocols/rfc2616/rfc2616-sec12.html)\n\n## 代理模式\n\n这种设计模式提供了一个叫做 **Proxy** 的对象用于控制另一个叫 **Subject** 的对象的访问。**Proxy** 对象和 Subject 对象具有相同的接口。**Proxy** 位于客户和 Subject 对象之间，它拦截了所有或者部分的请求，然后将这些请求转发给 **Subject**\n\n![alt](https://dzone.com/storage/temp/2442923-proxy.png)\n\nExpress 有两种类型的中间件：\n\n应用级中间件\n\n路由级中间件\n\n除了 应用级中间件 是绑定在一个应用（application）对象上且 路由级中间件 是绑定在 路由（router）实例上的区别外，它们都是一样的。所以 Express 是怎么实现这个功能的呢？通过 **组合（composition）**！express 的应用（application）对象拥有对 路由（Router) 实例对象的内部引用。\n\n\n```js\nthis._router = new Router({\n      caseSensitive: this.enabled('case sensitive routing'),\n      strict: this.enabled('strict routing')\n});\n\nthis._router.use(query(this.get('query parser fn')));\nthis._router.use(middleware.init(this));\n```\n\n使用每个受支持的API，在将请求转发到内部路由器（Router）实例之前，应用（application）对象将进行一些逻辑检查和验证。\n\n注意: 还有许多其他的设计模式我没有在这里列出来，比如单例模式，懒初始化模式，事件发射器模式。\n\n","slug":"design-patterns-in-expressjs","published":1,"updated":"2020-10-20T11:34:45.097Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhpu92wr0001ak87qe1emj5r","content":"<p><a href=\"https://dzone.com/articles/design-patterns-in-expressjs\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<p>Express 是一种保持最低程度规模的灵活 Node.js Web 应用程序框架，为 Web 和移动应用程序提供一组强大的功能。</p>\n<p>下面是一些当我们使用 Express 时可能会看到的一些设计模式。</p>\n<h2 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h2><p>这是 JavaScript 语言中一个简单和常用的设计模式。工厂模式是一种创新的设计模式可以让我们从外部世界中抽象出对象实现细节。Express 通过导出工厂实现这种模式。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Expose `createApplication()`.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\">exports = <span class=\"built_in\">module</span>.exports = createApplication;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createApplication</span>(<span class=\"params\"></span>) </span>{</span><br><span class=\"line\">  <span class=\"keyword\">var</span> app = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>{</span><br><span class=\"line\">    app.handle(req, res, next);</span><br><span class=\"line\">  };</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">return</span> app;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>另外，使用工厂模式创造一个 express 应用就如下面代码所示这么简单</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> express <span class=\"keyword\">from</span> <span class=\"string\">'express'</span>;</span><br><span class=\"line\">..</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = express();</span><br></pre></td></tr></tbody></table></figure>\n<h2 id=\"中间件\"><a href=\"#中间件\" class=\"headerlink\" title=\"中间件\"></a>中间件</h2><p>中间件是一个被 Express.js 带火的术语。</p>\n<p>事实上，我们可以把这种设计模式看成 <a href=\"http://www.oracle.com/technetwork/java/interceptingfilter-142169.html\" target=\"_blank\" rel=\"noopener\">拦截过滤</a> 和 <a href=\"http://www.oracle.com/technetwork/java/interceptingfilter-142169.html\" target=\"_blank\" rel=\"noopener\">职责链模式</a> 的一种变体。</p>\n<p><img src=\"https://vietcanho.files.wordpress.com/2016/06/middleware.png?w=1462\" alt=\"alt\"></p>\n<p>关于该模式的更多信息-点击 <a href=\"https://dzone.com/articles/understanding-middleware-pattern-in-expressjs\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<h2 id=\"装饰器模式\"><a href=\"#装饰器模式\" class=\"headerlink\" title=\"装饰器模式\"></a>装饰器模式</h2><p>装饰器模式动态地扩展（装饰）了一个对象的行为。它和经典的继承不同，因为新的行为是在运行时被添加的，并且只被添加到被装饰的对象上（并非类上）。</p>\n<p><img src=\"https://dzone.com/storage/temp/2440958-decorator.png\" alt=\"alt\"></p>\n<p>这种模式的一个简单示例是 <a href=\"http://expressjs.com/en/4x/api.html#req\" target=\"_blank\" rel=\"noopener\">req</a> 和 <a href=\"http://expressjs.com/en/4x/api.html#res\" target=\"_blank\" rel=\"noopener\">resp</a> ，在 Node 中，请求和响应对象的 API 是有限的。Express 通过使用一些新的特性装饰它们从而扩展了这些对象。</p>\n<p>以下就是接收 request (req) 和 response (resp) 对象并且装饰它们的函数。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">///lib/middleware/init.js</span></span><br><span class=\"line\">exports.init = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">app</span>)</span>{</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">expressInit</span>(<span class=\"params\">req, res, next</span>)</span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (app.enabled(<span class=\"string\">'x-powered-by'</span>)) res.setHeader(<span class=\"string\">'X-Powered-By'</span>, <span class=\"string\">'Express'</span>);</span><br><span class=\"line\">    req.res = res;</span><br><span class=\"line\">    res.req = req;</span><br><span class=\"line\">    req.next = next;</span><br><span class=\"line\"></span><br><span class=\"line\">    req.__proto__ = app.request;</span><br><span class=\"line\">    res.__proto__ = app.response;</span><br><span class=\"line\"></span><br><span class=\"line\">    res.locals = res.locals || <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    next();</span><br><span class=\"line\">  };</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n<h2 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h2><blockquote>\n<p>定义一组算法，对每一个算法进行封装，让他们变得可被替换。策略模式让算法非常独立于使用它的客户。</p>\n</blockquote>\n<p><img src=\"https://dzone.com/storage/temp/2442910-strategy.png\" alt=\"alt\"></p>\n<p>它让一个策略（算法）在运行时在不被客户意识到的情况下被任何其他策略所替换。</p>\n<p>在 Express 中，策略模式能在 Express 支持不同的模板引擎（例如 Pug, Mustache, EJS, swig等等）的实现中看到。在 <a href=\"https://github.com/expressjs/express/wiki?_ga=1.216495568.777274470.1463719254#template-engines\" target=\"_blank\" rel=\"noopener\">这里</a> 可以看到 Express 支持的渲染引擎的完整列表。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> express <span class=\"keyword\">from</span> <span class=\"string\">'express'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> exphbs <span class=\"keyword\">from</span> <span class=\"string\">'express-handlebars'</span>;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = express();</span><br><span class=\"line\">app.engine(<span class=\"string\">'.html'</span>, exphbs({...}));</span><br><span class=\"line\">app.engine(<span class=\"string\">'jade'</span>, <span class=\"built_in\">require</span>(<span class=\"string\">'jade'</span>).__express);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Select the strategy '.html'</span></span><br><span class=\"line\">app.set(<span class=\"string\">'view engine'</span>, <span class=\"string\">'.html'</span>);</span><br></pre></td></tr></tbody></table></figure>\n<p>另一个例子是 Express 如何支持 <a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec12.html\" target=\"_blank\" rel=\"noopener\">内容协商</a></p>\n<h2 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h2><p>这种设计模式提供了一个叫做 <strong>Proxy</strong> 的对象用于控制另一个叫 <strong>Subject</strong> 的对象的访问。<strong>Proxy</strong> 对象和 Subject 对象具有相同的接口。<strong>Proxy</strong> 位于客户和 Subject 对象之间，它拦截了所有或者部分的请求，然后将这些请求转发给 <strong>Subject</strong></p>\n<p><img src=\"https://dzone.com/storage/temp/2442923-proxy.png\" alt=\"alt\"></p>\n<p>Express 有两种类型的中间件：</p>\n<p>应用级中间件</p>\n<p>路由级中间件</p>\n<p>除了 应用级中间件 是绑定在一个应用（application）对象上且 路由级中间件 是绑定在 路由（router）实例上的区别外，它们都是一样的。所以 Express 是怎么实现这个功能的呢？通过 <strong>组合（composition）</strong>！express 的应用（application）对象拥有对 路由（Router) 实例对象的内部引用。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>._router = <span class=\"keyword\">new</span> Router({</span><br><span class=\"line\">      caseSensitive: <span class=\"keyword\">this</span>.enabled(<span class=\"string\">'case sensitive routing'</span>),</span><br><span class=\"line\">      strict: <span class=\"keyword\">this</span>.enabled(<span class=\"string\">'strict routing'</span>)</span><br><span class=\"line\">});</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>._router.use(query(<span class=\"keyword\">this</span>.get(<span class=\"string\">'query parser fn'</span>)));</span><br><span class=\"line\"><span class=\"keyword\">this</span>._router.use(middleware.init(<span class=\"keyword\">this</span>));</span><br></pre></td></tr></tbody></table></figure>\n<p>使用每个受支持的API，在将请求转发到内部路由器（Router）实例之前，应用（application）对象将进行一些逻辑检查和验证。</p>\n<p>注意: 还有许多其他的设计模式我没有在这里列出来，比如单例模式，懒初始化模式，事件发射器模式。</p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://dzone.com/articles/design-patterns-in-expressjs\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<p>Express 是一种保持最低程度规模的灵活 Node.js Web 应用程序框架，为 Web 和移动应用程序提供一组强大的功能。</p>\n<p>下面是一些当我们使用 Express 时可能会看到的一些设计模式。</p>\n<h2 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h2><p>这是 JavaScript 语言中一个简单和常用的设计模式。工厂模式是一种创新的设计模式可以让我们从外部世界中抽象出对象实现细节。Express 通过导出工厂实现这种模式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Expose `createApplication()`.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\">exports = <span class=\"built_in\">module</span>.exports = createApplication;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createApplication</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> app = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">    app.handle(req, res, next);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">return</span> app;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另外，使用工厂模式创造一个 express 应用就如下面代码所示这么简单</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> express <span class=\"keyword\">from</span> <span class=\"string\">'express'</span>;</span><br><span class=\"line\">..</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = express();</span><br></pre></td></tr></table></figure>\n<h2 id=\"中间件\"><a href=\"#中间件\" class=\"headerlink\" title=\"中间件\"></a>中间件</h2><p>中间件是一个被 Express.js 带火的术语。</p>\n<p>事实上，我们可以把这种设计模式看成 <a href=\"http://www.oracle.com/technetwork/java/interceptingfilter-142169.html\" target=\"_blank\" rel=\"noopener\">拦截过滤</a> 和 <a href=\"http://www.oracle.com/technetwork/java/interceptingfilter-142169.html\" target=\"_blank\" rel=\"noopener\">职责链模式</a> 的一种变体。</p>\n<p><img src=\"https://vietcanho.files.wordpress.com/2016/06/middleware.png?w=1462\" alt=\"alt\"></p>\n<p>关于该模式的更多信息-点击 <a href=\"https://dzone.com/articles/understanding-middleware-pattern-in-expressjs\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<h2 id=\"装饰器模式\"><a href=\"#装饰器模式\" class=\"headerlink\" title=\"装饰器模式\"></a>装饰器模式</h2><p>装饰器模式动态地扩展（装饰）了一个对象的行为。它和经典的继承不同，因为新的行为是在运行时被添加的，并且只被添加到被装饰的对象上（并非类上）。</p>\n<p><img src=\"https://dzone.com/storage/temp/2440958-decorator.png\" alt=\"alt\"></p>\n<p>这种模式的一个简单示例是 <a href=\"http://expressjs.com/en/4x/api.html#req\" target=\"_blank\" rel=\"noopener\">req</a> 和 <a href=\"http://expressjs.com/en/4x/api.html#res\" target=\"_blank\" rel=\"noopener\">resp</a> ，在 Node 中，请求和响应对象的 API 是有限的。Express 通过使用一些新的特性装饰它们从而扩展了这些对象。</p>\n<p>以下就是接收 request (req) 和 response (resp) 对象并且装饰它们的函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">///lib/middleware/init.js</span></span><br><span class=\"line\">exports.init = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">app</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">expressInit</span>(<span class=\"params\">req, res, next</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (app.enabled(<span class=\"string\">'x-powered-by'</span>)) res.setHeader(<span class=\"string\">'X-Powered-By'</span>, <span class=\"string\">'Express'</span>);</span><br><span class=\"line\">    req.res = res;</span><br><span class=\"line\">    res.req = req;</span><br><span class=\"line\">    req.next = next;</span><br><span class=\"line\"></span><br><span class=\"line\">    req.__proto__ = app.request;</span><br><span class=\"line\">    res.__proto__ = app.response;</span><br><span class=\"line\"></span><br><span class=\"line\">    res.locals = res.locals || <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    next();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h2><blockquote>\n<p>定义一组算法，对每一个算法进行封装，让他们变得可被替换。策略模式让算法非常独立于使用它的客户。</p>\n</blockquote>\n<p><img src=\"https://dzone.com/storage/temp/2442910-strategy.png\" alt=\"alt\"></p>\n<p>它让一个策略（算法）在运行时在不被客户意识到的情况下被任何其他策略所替换。</p>\n<p>在 Express 中，策略模式能在 Express 支持不同的模板引擎（例如 Pug, Mustache, EJS, swig等等）的实现中看到。在 <a href=\"https://github.com/expressjs/express/wiki?_ga=1.216495568.777274470.1463719254#template-engines\" target=\"_blank\" rel=\"noopener\">这里</a> 可以看到 Express 支持的渲染引擎的完整列表。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> express <span class=\"keyword\">from</span> <span class=\"string\">'express'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> exphbs <span class=\"keyword\">from</span> <span class=\"string\">'express-handlebars'</span>;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = express();</span><br><span class=\"line\">app.engine(<span class=\"string\">'.html'</span>, exphbs(&#123;...&#125;));</span><br><span class=\"line\">app.engine(<span class=\"string\">'jade'</span>, <span class=\"built_in\">require</span>(<span class=\"string\">'jade'</span>).__express);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Select the strategy '.html'</span></span><br><span class=\"line\">app.set(<span class=\"string\">'view engine'</span>, <span class=\"string\">'.html'</span>);</span><br></pre></td></tr></table></figure>\n<p>另一个例子是 Express 如何支持 <a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec12.html\" target=\"_blank\" rel=\"noopener\">内容协商</a></p>\n<h2 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h2><p>这种设计模式提供了一个叫做 <strong>Proxy</strong> 的对象用于控制另一个叫 <strong>Subject</strong> 的对象的访问。<strong>Proxy</strong> 对象和 Subject 对象具有相同的接口。<strong>Proxy</strong> 位于客户和 Subject 对象之间，它拦截了所有或者部分的请求，然后将这些请求转发给 <strong>Subject</strong></p>\n<p><img src=\"https://dzone.com/storage/temp/2442923-proxy.png\" alt=\"alt\"></p>\n<p>Express 有两种类型的中间件：</p>\n<p>应用级中间件</p>\n<p>路由级中间件</p>\n<p>除了 应用级中间件 是绑定在一个应用（application）对象上且 路由级中间件 是绑定在 路由（router）实例上的区别外，它们都是一样的。所以 Express 是怎么实现这个功能的呢？通过 <strong>组合（composition）</strong>！express 的应用（application）对象拥有对 路由（Router) 实例对象的内部引用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>._router = <span class=\"keyword\">new</span> Router(&#123;</span><br><span class=\"line\">      caseSensitive: <span class=\"keyword\">this</span>.enabled(<span class=\"string\">'case sensitive routing'</span>),</span><br><span class=\"line\">      strict: <span class=\"keyword\">this</span>.enabled(<span class=\"string\">'strict routing'</span>)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>._router.use(query(<span class=\"keyword\">this</span>.get(<span class=\"string\">'query parser fn'</span>)));</span><br><span class=\"line\"><span class=\"keyword\">this</span>._router.use(middleware.init(<span class=\"keyword\">this</span>));</span><br></pre></td></tr></table></figure>\n<p>使用每个受支持的API，在将请求转发到内部路由器（Router）实例之前，应用（application）对象将进行一些逻辑检查和验证。</p>\n<p>注意: 还有许多其他的设计模式我没有在这里列出来，比如单例模式，懒初始化模式，事件发射器模式。</p>\n"},{"title":"如何编写 Alfred Workflow","date":"2018-12-04T13:54:16.000Z","_content":"\n## :sparkles: 前言\n\n每当有人问到有什么 macOS 上的提升效率的神器，[Alfred](https://www.alfredapp.com/) 都是我脑海里第一个蹦出来的答案。Alfred with Powerpack 更是强上加强。\n几乎 mac 里的一切都可以通过简单的 `⌘ + space`（我的 Alfred 快捷键）获取到。\n\nAlfred 的 workflows 是一个使我非常兴奋的功能。它能充分满足程序员自给自足的乐趣。\n\n今天我们不介绍 Alfred 的那些优秀的功能。只来学习下如何开发自己的 workflow。\n\n这是成品 [alfred-gitmoji-workflow](https://github.com/Quilljou/alfred-gitmoji-workflow)。效果如下：\n\b<center>\n\n![alt](https://github.com/Quilljou/alfred-gitmoji-workflow/blob/master/screenshots/demo.gif?raw=true)\n\n</center>\n\n> [Gitmoji](https://github.com/carloscuesta/gitmoji) 是一个标准化和解释在GitHub提交消息上使用emojis的计划。可以理解为用来规范 git commit message 中 emoji 的使用的。\n\n通过在 Alfred 中键入 gitmoji 就会列出所有的 gitmoji，可以通过 [gitmoji](https://gitmoji.carloscuesta.me/) 官网中提供的 emoji 名称和释义来搜索。按下回车就复制到了粘贴板，并且粘贴到你当前 focus 的窗口的输入框。\n\n## :wrench: 搭建工作环境\n\n在 Alfred 打开时，键入 `⌘ + ,` 就会进入到偏好页。在 Alfred偏好页 -> Workflows 左侧 workflow 列表的最下方点击加号新建一个空白的 workflow。\n\n<center>\n\n![abc](http://pjcw35d11.bkt.clouddn.com/workflow-list.png)\n\n</center>\n\n在创建 workflow 的弹窗，填写好基本信息，需要注意的是 Bundle Id 是你这个 workflow 的签名。需要填写的独特一些。\n\n<center>\n\n![alt](http://pjcw35d11.bkt.clouddn.com/create-workflow)\n\n</center>\n\n在空白的 workflow 界面，右键。根据我们这次需要开发的 wolkflow 的特性选择 Inputs 为 Script Filter。\n\n<center>\n\n![alt](http://pjcw35d11.bkt.clouddn.com/workflow-script-filter)\n\n</center>\n\n\b然后填写关键词的一些描述信息，包括输入关键词的标题，副标题，和 Loading 时的占位词等等一些设置。\n\n当然最重要的就是设置得到\b用户输入之后，对这个输入进行处理然后输出的脚本。\n\n<center>\n\n![alt](http://pjcw35d11.bkt.clouddn.com/workflow-hotkey)\n\n</center>\n\n\nAlfred 提供了几种脚本语言的运行时。\n\n<center>\n\n![languages](http://pjcw35d11.bkt.clouddn.com/workflow-langs)\n\n</center>\n\n一开始觉得这种插件的开发应该是 JS 的天下。没想到在 Github 上用来开发 workflow 的最多的语言居然是 PHP。我也随大流的选择了 PHP 来进行这次开发。\n\n\n\b脚本输入框内就是最关键的两行代码，我们的脚本入口：\n\n```php\n$query = urlencode( \"{query}\" );\nrequire_once(\"gitmoji.php\");\n```\n\n在 Alfred 中。输入`gitmoji`， 这个关键字后面输入的文字就作为 `{query}` 作为我们脚本的输入。也就是上面我们把这个输入 `urlencode` 之后赋给了变量 `$query`。我们然后引用了 `gitmoji.php`。我们做的搜索逻辑就是在这个 php 文件中完成的。\n\n在列表中右键这个 workflow, 选择在 Finder 中打开，我们就可以看到两个文件。`info.plist`, `icon.png`。`info.plist` 就包含了我们刚刚填写的所有基本信息和设置选项的 xml 文件。你可以双击打开查看。\n所以再创建一个 `gitmoji.php` 就完成了一个 workflow 的开发了。\n\n<center>\n\n![alt](http://pjcw35d11.bkt.clouddn.com/workflow)\n\n</center>\n\n\n刚刚打开的路径是`/Users/xxxx/Library/Application\\ Support/Alfred\\3/Alfred.alfredpreferences/workflows/user.workflow.xxxxx/`。\n\n我们一般不会选择直接在上面这个路径我们的开发目录，因为这根本不是我们的开发地盘。\n\n所以在自己常用的开发目录下新建一个目录，将上面得到的两个文件拷贝过来。我们新建一个空白的 workflow 的目的就是先得到这两个文件。\n\n我们不在 Alfred 存放 workflow 的目录开发，那我们怎么将我们源码放置到 workflow 指定的目录呢？\n\n其实 Alfred 的 workflow 的文件扩展是类似 `gitmoji.workflow` 的一个压缩文件。双击这个压缩文件 Alfred 就会安装这个插件到上面的路径。\n\n所以我们就需要一个脚本帮我们完成这个压缩（打包）的工作。\n\n这里借鉴(copy)的是 [alfred-github-workflow](https://github.com/gharlan/alfred-github-workflow/blob/master/bin/build) 的打包\b脚本。\n\n```php\n#!/usr/bin/env php\n<?php\n// Forked from https://github.com/gharlan/alfred-github-workflow/blob/master/bin/build\n\n$dir = dirname(__DIR__);\n$VERSION = \"1.0.0\";\nrequire $dir.'/workflows.php';\n\n$plist = $dir.'/info.plist';\n\nexec(sprintf('/usr/libexec/PlistBuddy -c \"Set :version %s\" %s', $VERSION, escapeshellarg($plist)));\n\n// $changelog = file_get_contents($dir.'/CHANGELOG.md');\n// $changelog = str_replace(\"\\n\", '\\n', $changelog);\n// exec(sprintf('/usr/libexec/PlistBuddy -c \"Set :readme \\\"%s\\\"\" %s', escapeshellcmd($changelog), escapeshellarg($plist)));\n\n$zipFile = $dir.'/github.zip';\nif (file_exists($zipFile)) {\n    unlink($zipFile);\n}\n\n$zip = new PharData($zipFile);\n\n$files = array(\n    'icon.png',\n    'info.plist',\n    'gitmoji.php',\n    'README.md',\n    'workflows.php',\n);\n\nforeach ($files as $file) {\n    $zip->addFile($dir.'/'.$file, $file);\n}\nforeach (glob($dir.'/icons/*.png') as $path) {\n    $zip->addFile($path, 'icons/'.basename($path));\n}\n\n$zip->compressFiles(Phar::GZ);\n\n$workflow = $dir.'/gitmoji.alfredworkflow';\nif (file_exists($workflow)) {\n    unlink($workflow);\n}\nrename($zipFile, $workflow);\n```\n\n它所做的事情就是将源码（workflow 需要的几个文件）通过 php 的 PharData 类将\b生成一个压缩包。双击就能被 Alfred 安装。安装也就是解压缩之后复制到 workflow 的工作目录。\n\n## \b:rocket: 写脚本\n\n```php\n<?php\nrequire_once('workflows.php');\n$w = new Workflows();\n$query = urldecode(strtolower(trim($query)));\n\n<!-- 一周更新一次 -->\nif (filemtime(\"data.json\") <= (time() - 86400 * 7)) {\n    $dataUrl = 'https://raw.githubusercontent.com/carloscuesta/gitmoji/master/src/data/gitmojis.json';\n    $gitmojis = $w->request($dataUrl);\n    if (isset(json_decode($gitmojis)->gitmojis)) {\n        file_put_contents(\"data.json\", $gitmojis);\n    }\n}\n\n<!-- 将 gitmoji 的数据设置成 Alfred 可读的数据结构  -->\nfunction setResult($gitmojis) {\n    global $w;\n    foreach ($gitmojis as $key => $value) {\n        $id = $value->name;\n        $arg = $value->code;\n        $emoji = $value->emoji;\n        $title = $emoji.\" \".$value->description;\n        $subTitle = \"Copy \".$arg.\" to clipboard\";\n        $w->result($id, $arg, $title, $subTitle, ' ');\n    }\n}\n\n<!-- 通过搜索词过滤出结果 -->\nfunction filter($var) {\n    global $query;\n    $description = strtolower($var->description);\n    $name = strtolower($var->name);\n    return strpos($description,$query) !== false || strpos($name,$query) !== false;\n}\n$gitmojis = json_decode(file_get_contents('data.json'))->gitmojis;\n$data = $gitmojis;\n\n<!-- 没有关键词就显示所有 gitmoji -->\nif (strlen($query) != 0) {\n    $data = array_filter($gitmojis, \"filter\");\n}\n\n<!-- 得到的搜索，设置到缓冲区 -->\nsetResult($data);\n\n<!-- 将结果输出成 Alfred 可读的 xml -->\necho $w->toxml();\n```\n\n脚本只有短短的42行。能这么短的原因是社区有已经封装好的很好用的 [workflow util](https://github.com/jdfwarrior/Workflows)。\n\n我们用到的这个 util 的方法只有`result`，`toxml`。\n\n`result`方法就是把数据推到一个缓冲区，并且设置了 Alfred 最终显示的每一行的数据结构。这个结构包括`$uid, $arg, $title, $sub, $icon`。依次对应唯一ID、结果（复制到粘贴板的字符串）、标题、副标题、icon。注意这里的 icon 只能是本地资源，不能是服务器资源。\n\n`toxml`方法就是把缓冲区的数据转成 Alfred 可读的 `xml` 格式。\n\n\n我做的事情就是获取 gitmoji 托管在 github 上的 json 数据，缓存到本地。根据关键词通过字符串匹配名字和释义。将过滤之后得到的数据转成 Alfred 需要的数据格式，然后转成 xml。\n\n然后再终端运行 `./bin/build`。就得到了一个 Alfred workflow: `gitmoji.workflow`。:tada::tada:\n\n双击`gitmoji.workflow`安装，就可以在 Alfred 中和 gitmoji 尽情玩耍了。\n\n\n## :robot: TODO\n\n其实可以做到事情还有\n\n- 根据不同的语言来搜索 gitmoji。可惜 gitmoji 的维护者说还[没有找到好的方法](https://github.com/carloscuesta/gitmoji/issues/217)维护多语言翻译。\n- 为了保持和 gitmoji 源码数据的同步，没有使用 emoji 图片作为 icon。因为这样每次 gitmoji 数据一更新，这个 workflow 也需要更新。\n- 增加 update 命令：立即同步 github 数据。\n","source":"_posts/how-to-write-alfred-workflow.md","raw":"---\ntitle: 如何编写 Alfred Workflow\ndate: 2018-12-04 21:54:16\ntags:\n---\n\n## :sparkles: 前言\n\n每当有人问到有什么 macOS 上的提升效率的神器，[Alfred](https://www.alfredapp.com/) 都是我脑海里第一个蹦出来的答案。Alfred with Powerpack 更是强上加强。\n几乎 mac 里的一切都可以通过简单的 `⌘ + space`（我的 Alfred 快捷键）获取到。\n\nAlfred 的 workflows 是一个使我非常兴奋的功能。它能充分满足程序员自给自足的乐趣。\n\n今天我们不介绍 Alfred 的那些优秀的功能。只来学习下如何开发自己的 workflow。\n\n这是成品 [alfred-gitmoji-workflow](https://github.com/Quilljou/alfred-gitmoji-workflow)。效果如下：\n\b<center>\n\n![alt](https://github.com/Quilljou/alfred-gitmoji-workflow/blob/master/screenshots/demo.gif?raw=true)\n\n</center>\n\n> [Gitmoji](https://github.com/carloscuesta/gitmoji) 是一个标准化和解释在GitHub提交消息上使用emojis的计划。可以理解为用来规范 git commit message 中 emoji 的使用的。\n\n通过在 Alfred 中键入 gitmoji 就会列出所有的 gitmoji，可以通过 [gitmoji](https://gitmoji.carloscuesta.me/) 官网中提供的 emoji 名称和释义来搜索。按下回车就复制到了粘贴板，并且粘贴到你当前 focus 的窗口的输入框。\n\n## :wrench: 搭建工作环境\n\n在 Alfred 打开时，键入 `⌘ + ,` 就会进入到偏好页。在 Alfred偏好页 -> Workflows 左侧 workflow 列表的最下方点击加号新建一个空白的 workflow。\n\n<center>\n\n![abc](http://pjcw35d11.bkt.clouddn.com/workflow-list.png)\n\n</center>\n\n在创建 workflow 的弹窗，填写好基本信息，需要注意的是 Bundle Id 是你这个 workflow 的签名。需要填写的独特一些。\n\n<center>\n\n![alt](http://pjcw35d11.bkt.clouddn.com/create-workflow)\n\n</center>\n\n在空白的 workflow 界面，右键。根据我们这次需要开发的 wolkflow 的特性选择 Inputs 为 Script Filter。\n\n<center>\n\n![alt](http://pjcw35d11.bkt.clouddn.com/workflow-script-filter)\n\n</center>\n\n\b然后填写关键词的一些描述信息，包括输入关键词的标题，副标题，和 Loading 时的占位词等等一些设置。\n\n当然最重要的就是设置得到\b用户输入之后，对这个输入进行处理然后输出的脚本。\n\n<center>\n\n![alt](http://pjcw35d11.bkt.clouddn.com/workflow-hotkey)\n\n</center>\n\n\nAlfred 提供了几种脚本语言的运行时。\n\n<center>\n\n![languages](http://pjcw35d11.bkt.clouddn.com/workflow-langs)\n\n</center>\n\n一开始觉得这种插件的开发应该是 JS 的天下。没想到在 Github 上用来开发 workflow 的最多的语言居然是 PHP。我也随大流的选择了 PHP 来进行这次开发。\n\n\n\b脚本输入框内就是最关键的两行代码，我们的脚本入口：\n\n```php\n$query = urlencode( \"{query}\" );\nrequire_once(\"gitmoji.php\");\n```\n\n在 Alfred 中。输入`gitmoji`， 这个关键字后面输入的文字就作为 `{query}` 作为我们脚本的输入。也就是上面我们把这个输入 `urlencode` 之后赋给了变量 `$query`。我们然后引用了 `gitmoji.php`。我们做的搜索逻辑就是在这个 php 文件中完成的。\n\n在列表中右键这个 workflow, 选择在 Finder 中打开，我们就可以看到两个文件。`info.plist`, `icon.png`。`info.plist` 就包含了我们刚刚填写的所有基本信息和设置选项的 xml 文件。你可以双击打开查看。\n所以再创建一个 `gitmoji.php` 就完成了一个 workflow 的开发了。\n\n<center>\n\n![alt](http://pjcw35d11.bkt.clouddn.com/workflow)\n\n</center>\n\n\n刚刚打开的路径是`/Users/xxxx/Library/Application\\ Support/Alfred\\3/Alfred.alfredpreferences/workflows/user.workflow.xxxxx/`。\n\n我们一般不会选择直接在上面这个路径我们的开发目录，因为这根本不是我们的开发地盘。\n\n所以在自己常用的开发目录下新建一个目录，将上面得到的两个文件拷贝过来。我们新建一个空白的 workflow 的目的就是先得到这两个文件。\n\n我们不在 Alfred 存放 workflow 的目录开发，那我们怎么将我们源码放置到 workflow 指定的目录呢？\n\n其实 Alfred 的 workflow 的文件扩展是类似 `gitmoji.workflow` 的一个压缩文件。双击这个压缩文件 Alfred 就会安装这个插件到上面的路径。\n\n所以我们就需要一个脚本帮我们完成这个压缩（打包）的工作。\n\n这里借鉴(copy)的是 [alfred-github-workflow](https://github.com/gharlan/alfred-github-workflow/blob/master/bin/build) 的打包\b脚本。\n\n```php\n#!/usr/bin/env php\n<?php\n// Forked from https://github.com/gharlan/alfred-github-workflow/blob/master/bin/build\n\n$dir = dirname(__DIR__);\n$VERSION = \"1.0.0\";\nrequire $dir.'/workflows.php';\n\n$plist = $dir.'/info.plist';\n\nexec(sprintf('/usr/libexec/PlistBuddy -c \"Set :version %s\" %s', $VERSION, escapeshellarg($plist)));\n\n// $changelog = file_get_contents($dir.'/CHANGELOG.md');\n// $changelog = str_replace(\"\\n\", '\\n', $changelog);\n// exec(sprintf('/usr/libexec/PlistBuddy -c \"Set :readme \\\"%s\\\"\" %s', escapeshellcmd($changelog), escapeshellarg($plist)));\n\n$zipFile = $dir.'/github.zip';\nif (file_exists($zipFile)) {\n    unlink($zipFile);\n}\n\n$zip = new PharData($zipFile);\n\n$files = array(\n    'icon.png',\n    'info.plist',\n    'gitmoji.php',\n    'README.md',\n    'workflows.php',\n);\n\nforeach ($files as $file) {\n    $zip->addFile($dir.'/'.$file, $file);\n}\nforeach (glob($dir.'/icons/*.png') as $path) {\n    $zip->addFile($path, 'icons/'.basename($path));\n}\n\n$zip->compressFiles(Phar::GZ);\n\n$workflow = $dir.'/gitmoji.alfredworkflow';\nif (file_exists($workflow)) {\n    unlink($workflow);\n}\nrename($zipFile, $workflow);\n```\n\n它所做的事情就是将源码（workflow 需要的几个文件）通过 php 的 PharData 类将\b生成一个压缩包。双击就能被 Alfred 安装。安装也就是解压缩之后复制到 workflow 的工作目录。\n\n## \b:rocket: 写脚本\n\n```php\n<?php\nrequire_once('workflows.php');\n$w = new Workflows();\n$query = urldecode(strtolower(trim($query)));\n\n<!-- 一周更新一次 -->\nif (filemtime(\"data.json\") <= (time() - 86400 * 7)) {\n    $dataUrl = 'https://raw.githubusercontent.com/carloscuesta/gitmoji/master/src/data/gitmojis.json';\n    $gitmojis = $w->request($dataUrl);\n    if (isset(json_decode($gitmojis)->gitmojis)) {\n        file_put_contents(\"data.json\", $gitmojis);\n    }\n}\n\n<!-- 将 gitmoji 的数据设置成 Alfred 可读的数据结构  -->\nfunction setResult($gitmojis) {\n    global $w;\n    foreach ($gitmojis as $key => $value) {\n        $id = $value->name;\n        $arg = $value->code;\n        $emoji = $value->emoji;\n        $title = $emoji.\" \".$value->description;\n        $subTitle = \"Copy \".$arg.\" to clipboard\";\n        $w->result($id, $arg, $title, $subTitle, ' ');\n    }\n}\n\n<!-- 通过搜索词过滤出结果 -->\nfunction filter($var) {\n    global $query;\n    $description = strtolower($var->description);\n    $name = strtolower($var->name);\n    return strpos($description,$query) !== false || strpos($name,$query) !== false;\n}\n$gitmojis = json_decode(file_get_contents('data.json'))->gitmojis;\n$data = $gitmojis;\n\n<!-- 没有关键词就显示所有 gitmoji -->\nif (strlen($query) != 0) {\n    $data = array_filter($gitmojis, \"filter\");\n}\n\n<!-- 得到的搜索，设置到缓冲区 -->\nsetResult($data);\n\n<!-- 将结果输出成 Alfred 可读的 xml -->\necho $w->toxml();\n```\n\n脚本只有短短的42行。能这么短的原因是社区有已经封装好的很好用的 [workflow util](https://github.com/jdfwarrior/Workflows)。\n\n我们用到的这个 util 的方法只有`result`，`toxml`。\n\n`result`方法就是把数据推到一个缓冲区，并且设置了 Alfred 最终显示的每一行的数据结构。这个结构包括`$uid, $arg, $title, $sub, $icon`。依次对应唯一ID、结果（复制到粘贴板的字符串）、标题、副标题、icon。注意这里的 icon 只能是本地资源，不能是服务器资源。\n\n`toxml`方法就是把缓冲区的数据转成 Alfred 可读的 `xml` 格式。\n\n\n我做的事情就是获取 gitmoji 托管在 github 上的 json 数据，缓存到本地。根据关键词通过字符串匹配名字和释义。将过滤之后得到的数据转成 Alfred 需要的数据格式，然后转成 xml。\n\n然后再终端运行 `./bin/build`。就得到了一个 Alfred workflow: `gitmoji.workflow`。:tada::tada:\n\n双击`gitmoji.workflow`安装，就可以在 Alfred 中和 gitmoji 尽情玩耍了。\n\n\n## :robot: TODO\n\n其实可以做到事情还有\n\n- 根据不同的语言来搜索 gitmoji。可惜 gitmoji 的维护者说还[没有找到好的方法](https://github.com/carloscuesta/gitmoji/issues/217)维护多语言翻译。\n- 为了保持和 gitmoji 源码数据的同步，没有使用 emoji 图片作为 icon。因为这样每次 gitmoji 数据一更新，这个 workflow 也需要更新。\n- 增加 update 命令：立即同步 github 数据。\n","slug":"how-to-write-alfred-workflow","published":1,"updated":"2019-07-19T01:53:42.606Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhpu92wu0002ak877bzr8f9g","content":"<h2 id=\"sparkles-前言\"><a href=\"#sparkles-前言\" class=\"headerlink\" title=\":sparkles: 前言\"></a><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2728.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/2728.png?v8\">✨</span> 前言</h2><p>每当有人问到有什么 macOS 上的提升效率的神器，<a href=\"https://www.alfredapp.com/\" target=\"_blank\" rel=\"noopener\">Alfred</a> 都是我脑海里第一个蹦出来的答案。Alfred with Powerpack 更是强上加强。<br>几乎 mac 里的一切都可以通过简单的 <code>⌘ + space</code>（我的 Alfred 快捷键）获取到。</p>\n<p>Alfred 的 workflows 是一个使我非常兴奋的功能。它能充分满足程序员自给自足的乐趣。</p>\n<p>今天我们不介绍 Alfred 的那些优秀的功能。只来学习下如何开发自己的 workflow。</p>\n<p>这是成品 <a href=\"https://github.com/Quilljou/alfred-gitmoji-workflow\" target=\"_blank\" rel=\"noopener\">alfred-gitmoji-workflow</a>。效果如下：<br>\b</p><center></center><p></p>\n<p><img src=\"https://github.com/Quilljou/alfred-gitmoji-workflow/blob/master/screenshots/demo.gif?raw=true\" alt=\"alt\"></p>\n<p></p>\n<blockquote>\n<p><a href=\"https://github.com/carloscuesta/gitmoji\" target=\"_blank\" rel=\"noopener\">Gitmoji</a> 是一个标准化和解释在GitHub提交消息上使用emojis的计划。可以理解为用来规范 git commit message 中 emoji 的使用的。</p>\n</blockquote>\n<p>通过在 Alfred 中键入 gitmoji 就会列出所有的 gitmoji，可以通过 <a href=\"https://gitmoji.carloscuesta.me/\" target=\"_blank\" rel=\"noopener\">gitmoji</a> 官网中提供的 emoji 名称和释义来搜索。按下回车就复制到了粘贴板，并且粘贴到你当前 focus 的窗口的输入框。</p>\n<h2 id=\"wrench-搭建工作环境\"><a href=\"#wrench-搭建工作环境\" class=\"headerlink\" title=\":wrench: 搭建工作环境\"></a><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f527.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f527.png?v8\">🔧</span> 搭建工作环境</h2><p>在 Alfred 打开时，键入 <code>⌘ + ,</code> 就会进入到偏好页。在 Alfred偏好页 -> Workflows 左侧 workflow 列表的最下方点击加号新建一个空白的 workflow。</p>\n<center><br><br><img src=\"http://pjcw35d11.bkt.clouddn.com/workflow-list.png\" alt=\"abc\"><br><br></center>\n\n<p>在创建 workflow 的弹窗，填写好基本信息，需要注意的是 Bundle Id 是你这个 workflow 的签名。需要填写的独特一些。</p>\n<center><br><br><img src=\"http://pjcw35d11.bkt.clouddn.com/create-workflow\" alt=\"alt\"><br><br></center>\n\n<p>在空白的 workflow 界面，右键。根据我们这次需要开发的 wolkflow 的特性选择 Inputs 为 Script Filter。</p>\n<center><br><br><img src=\"http://pjcw35d11.bkt.clouddn.com/workflow-script-filter\" alt=\"alt\"><br><br></center>\n\n<p>\b然后填写关键词的一些描述信息，包括输入关键词的标题，副标题，和 Loading 时的占位词等等一些设置。</p>\n<p>当然最重要的就是设置得到\b用户输入之后，对这个输入进行处理然后输出的脚本。</p>\n<center><br><br><img src=\"http://pjcw35d11.bkt.clouddn.com/workflow-hotkey\" alt=\"alt\"><br><br></center>\n\n\n<p>Alfred 提供了几种脚本语言的运行时。</p>\n<center><br><br><img src=\"http://pjcw35d11.bkt.clouddn.com/workflow-langs\" alt=\"languages\"><br><br></center>\n\n<p>一开始觉得这种插件的开发应该是 JS 的天下。没想到在 Github 上用来开发 workflow 的最多的语言居然是 PHP。我也随大流的选择了 PHP 来进行这次开发。</p>\n<p>\b脚本输入框内就是最关键的两行代码，我们的脚本入口：</p>\n<figure class=\"highlight php\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$query = urlencode( <span class=\"string\">\"{query}\"</span> );</span><br><span class=\"line\"><span class=\"keyword\">require_once</span>(<span class=\"string\">\"gitmoji.php\"</span>);</span><br></pre></td></tr></tbody></table></figure>\n<p>在 Alfred 中。输入<code>gitmoji</code>， 这个关键字后面输入的文字就作为 <code>{query}</code> 作为我们脚本的输入。也就是上面我们把这个输入 <code>urlencode</code> 之后赋给了变量 <code>$query</code>。我们然后引用了 <code>gitmoji.php</code>。我们做的搜索逻辑就是在这个 php 文件中完成的。</p>\n<p>在列表中右键这个 workflow, 选择在 Finder 中打开，我们就可以看到两个文件。<code>info.plist</code>, <code>icon.png</code>。<code>info.plist</code> 就包含了我们刚刚填写的所有基本信息和设置选项的 xml 文件。你可以双击打开查看。<br>所以再创建一个 <code>gitmoji.php</code> 就完成了一个 workflow 的开发了。</p>\n<center><br><br><img src=\"http://pjcw35d11.bkt.clouddn.com/workflow\" alt=\"alt\"><br><br></center>\n\n\n<p>刚刚打开的路径是<code>/Users/xxxx/Library/Application\\ Support/Alfred\\3/Alfred.alfredpreferences/workflows/user.workflow.xxxxx/</code>。</p>\n<p>我们一般不会选择直接在上面这个路径我们的开发目录，因为这根本不是我们的开发地盘。</p>\n<p>所以在自己常用的开发目录下新建一个目录，将上面得到的两个文件拷贝过来。我们新建一个空白的 workflow 的目的就是先得到这两个文件。</p>\n<p>我们不在 Alfred 存放 workflow 的目录开发，那我们怎么将我们源码放置到 workflow 指定的目录呢？</p>\n<p>其实 Alfred 的 workflow 的文件扩展是类似 <code>gitmoji.workflow</code> 的一个压缩文件。双击这个压缩文件 Alfred 就会安装这个插件到上面的路径。</p>\n<p>所以我们就需要一个脚本帮我们完成这个压缩（打包）的工作。</p>\n<p>这里借鉴(copy)的是 <a href=\"https://github.com/gharlan/alfred-github-workflow/blob/master/bin/build\" target=\"_blank\" rel=\"noopener\">alfred-github-workflow</a> 的打包\b脚本。</p>\n<figure class=\"highlight php\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env php</span></span><br><span class=\"line\"><span class=\"meta\"><?php</span></span><br><span class=\"line\"><span class=\"comment\">// Forked from https://github.com/gharlan/alfred-github-workflow/blob/master/bin/build</span></span><br><span class=\"line\"></span><br><span class=\"line\">$dir = dirname(<span class=\"keyword\">__DIR__</span>);</span><br><span class=\"line\">$VERSION = <span class=\"string\">\"1.0.0\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">require</span> $dir.<span class=\"string\">'/workflows.php'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">$plist = $dir.<span class=\"string\">'/info.plist'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">exec(sprintf(<span class=\"string\">'/usr/libexec/PlistBuddy -c \"Set :version %s\" %s'</span>, $VERSION, escapeshellarg($plist)));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// $changelog = file_get_contents($dir.'/CHANGELOG.md');</span></span><br><span class=\"line\"><span class=\"comment\">// $changelog = str_replace(\"\\n\", '\\n', $changelog);</span></span><br><span class=\"line\"><span class=\"comment\">// exec(sprintf('/usr/libexec/PlistBuddy -c \"Set :readme \\\"%s\\\"\" %s', escapeshellcmd($changelog), escapeshellarg($plist)));</span></span><br><span class=\"line\"></span><br><span class=\"line\">$zipFile = $dir.<span class=\"string\">'/github.zip'</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (file_exists($zipFile)) {</span><br><span class=\"line\">    unlink($zipFile);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">$zip = <span class=\"keyword\">new</span> PharData($zipFile);</span><br><span class=\"line\"></span><br><span class=\"line\">$files = <span class=\"keyword\">array</span>(</span><br><span class=\"line\">    <span class=\"string\">'icon.png'</span>,</span><br><span class=\"line\">    <span class=\"string\">'info.plist'</span>,</span><br><span class=\"line\">    <span class=\"string\">'gitmoji.php'</span>,</span><br><span class=\"line\">    <span class=\"string\">'README.md'</span>,</span><br><span class=\"line\">    <span class=\"string\">'workflows.php'</span>,</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">foreach</span> ($files <span class=\"keyword\">as</span> $file) {</span><br><span class=\"line\">    $zip->addFile($dir.<span class=\"string\">'/'</span>.$file, $file);</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">foreach</span> (glob($dir.<span class=\"string\">'/icons/*.png'</span>) <span class=\"keyword\">as</span> $path) {</span><br><span class=\"line\">    $zip->addFile($path, <span class=\"string\">'icons/'</span>.basename($path));</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">$zip->compressFiles(Phar::GZ);</span><br><span class=\"line\"></span><br><span class=\"line\">$workflow = $dir.<span class=\"string\">'/gitmoji.alfredworkflow'</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (file_exists($workflow)) {</span><br><span class=\"line\">    unlink($workflow);</span><br><span class=\"line\">}</span><br><span class=\"line\">rename($zipFile, $workflow);</span><br></pre></td></tr></tbody></table></figure>\n<p>它所做的事情就是将源码（workflow 需要的几个文件）通过 php 的 PharData 类将\b生成一个压缩包。双击就能被 Alfred 安装。安装也就是解压缩之后复制到 workflow 的工作目录。</p>\n<h2 id=\"rocket-写脚本\"><a href=\"#rocket-写脚本\" class=\"headerlink\" title=\"\b:rocket: 写脚本\"></a>\b<span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f680.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f680.png?v8\">🚀</span> 写脚本</h2><figure class=\"highlight php\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"><?php</span></span><br><span class=\"line\"><span class=\"keyword\">require_once</span>(<span class=\"string\">'workflows.php'</span>);</span><br><span class=\"line\">$w = <span class=\"keyword\">new</span> Workflows();</span><br><span class=\"line\">$query = urldecode(strtolower(trim($query)));</span><br><span class=\"line\"></span><br><span class=\"line\"><!-- 一周更新一次 --></span><br><span class=\"line\"><span class=\"keyword\">if</span> (filemtime(<span class=\"string\">\"data.json\"</span>) <= (time() - <span class=\"number\">86400</span> * <span class=\"number\">7</span>)) {</span><br><span class=\"line\">    $dataUrl = <span class=\"string\">'https://raw.githubusercontent.com/carloscuesta/gitmoji/master/src/data/gitmojis.json'</span>;</span><br><span class=\"line\">    $gitmojis = $w->request($dataUrl);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">isset</span>(json_decode($gitmojis)->gitmojis)) {</span><br><span class=\"line\">        file_put_contents(<span class=\"string\">\"data.json\"</span>, $gitmojis);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><!-- 将 gitmoji 的数据设置成 Alfred 可读的数据结构  --></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setResult</span><span class=\"params\">($gitmojis)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">global</span> $w;</span><br><span class=\"line\">    <span class=\"keyword\">foreach</span> ($gitmojis <span class=\"keyword\">as</span> $key => $value) {</span><br><span class=\"line\">        $id = $value->name;</span><br><span class=\"line\">        $arg = $value->code;</span><br><span class=\"line\">        $emoji = $value->emoji;</span><br><span class=\"line\">        $title = $emoji.<span class=\"string\">\" \"</span>.$value->description;</span><br><span class=\"line\">        $subTitle = <span class=\"string\">\"Copy \"</span>.$arg.<span class=\"string\">\" to clipboard\"</span>;</span><br><span class=\"line\">        $w->result($id, $arg, $title, $subTitle, <span class=\"string\">' '</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><!-- 通过搜索词过滤出结果 --></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">filter</span><span class=\"params\">($var)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">global</span> $query;</span><br><span class=\"line\">    $description = strtolower($var->description);</span><br><span class=\"line\">    $name = strtolower($var->name);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> strpos($description,$query) !== <span class=\"keyword\">false</span> || strpos($name,$query) !== <span class=\"keyword\">false</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\">$gitmojis = json_decode(file_get_contents(<span class=\"string\">'data.json'</span>))->gitmojis;</span><br><span class=\"line\">$data = $gitmojis;</span><br><span class=\"line\"></span><br><span class=\"line\"><!-- 没有关键词就显示所有 gitmoji --></span><br><span class=\"line\"><span class=\"keyword\">if</span> (strlen($query) != <span class=\"number\">0</span>) {</span><br><span class=\"line\">    $data = array_filter($gitmojis, <span class=\"string\">\"filter\"</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><!-- 得到的搜索，设置到缓冲区 --></span><br><span class=\"line\">setResult($data);</span><br><span class=\"line\"></span><br><span class=\"line\"><!-- 将结果输出成 Alfred 可读的 xml --></span><br><span class=\"line\"><span class=\"keyword\">echo</span> $w->toxml();</span><br></pre></td></tr></tbody></table></figure>\n<p>脚本只有短短的42行。能这么短的原因是社区有已经封装好的很好用的 <a href=\"https://github.com/jdfwarrior/Workflows\" target=\"_blank\" rel=\"noopener\">workflow util</a>。</p>\n<p>我们用到的这个 util 的方法只有<code>result</code>，<code>toxml</code>。</p>\n<p><code>result</code>方法就是把数据推到一个缓冲区，并且设置了 Alfred 最终显示的每一行的数据结构。这个结构包括<code>$uid, $arg, $title, $sub, $icon</code>。依次对应唯一ID、结果（复制到粘贴板的字符串）、标题、副标题、icon。注意这里的 icon 只能是本地资源，不能是服务器资源。</p>\n<p><code>toxml</code>方法就是把缓冲区的数据转成 Alfred 可读的 <code>xml</code> 格式。</p>\n<p>我做的事情就是获取 gitmoji 托管在 github 上的 json 数据，缓存到本地。根据关键词通过字符串匹配名字和释义。将过滤之后得到的数据转成 Alfred 需要的数据格式，然后转成 xml。</p>\n<p>然后再终端运行 <code>./bin/build</code>。就得到了一个 Alfred workflow: <code>gitmoji.workflow</code>。<span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f389.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f389.png?v8\">🎉</span><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f389.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f389.png?v8\">🎉</span></p>\n<p>双击<code>gitmoji.workflow</code>安装，就可以在 Alfred 中和 gitmoji 尽情玩耍了。</p>\n<h2 id=\"robot-TODO\"><a href=\"#robot-TODO\" class=\"headerlink\" title=\":robot: TODO\"></a><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f916.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f916.png?v8\">🤖</span> TODO</h2><p>其实可以做到事情还有</p>\n<ul>\n<li>根据不同的语言来搜索 gitmoji。可惜 gitmoji 的维护者说还<a href=\"https://github.com/carloscuesta/gitmoji/issues/217\" target=\"_blank\" rel=\"noopener\">没有找到好的方法</a>维护多语言翻译。</li>\n<li>为了保持和 gitmoji 源码数据的同步，没有使用 emoji 图片作为 icon。因为这样每次 gitmoji 数据一更新，这个 workflow 也需要更新。</li>\n<li>增加 update 命令：立即同步 github 数据。</li>\n</ul>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"sparkles-前言\"><a href=\"#sparkles-前言\" class=\"headerlink\" title=\":sparkles: 前言\"></a>:sparkles: 前言</h2><p>每当有人问到有什么 macOS 上的提升效率的神器，<a href=\"https://www.alfredapp.com/\" target=\"_blank\" rel=\"noopener\">Alfred</a> 都是我脑海里第一个蹦出来的答案。Alfred with Powerpack 更是强上加强。<br>几乎 mac 里的一切都可以通过简单的 <code>⌘ + space</code>（我的 Alfred 快捷键）获取到。</p>\n<p>Alfred 的 workflows 是一个使我非常兴奋的功能。它能充分满足程序员自给自足的乐趣。</p>\n<p>今天我们不介绍 Alfred 的那些优秀的功能。只来学习下如何开发自己的 workflow。</p>\n<p>这是成品 <a href=\"https://github.com/Quilljou/alfred-gitmoji-workflow\" target=\"_blank\" rel=\"noopener\">alfred-gitmoji-workflow</a>。效果如下：<br>\b<center></center></p>\n<p><img src=\"https://github.com/Quilljou/alfred-gitmoji-workflow/blob/master/screenshots/demo.gif?raw=true\" alt=\"alt\"></p>\n<p></p>\n<blockquote>\n<p><a href=\"https://github.com/carloscuesta/gitmoji\" target=\"_blank\" rel=\"noopener\">Gitmoji</a> 是一个标准化和解释在GitHub提交消息上使用emojis的计划。可以理解为用来规范 git commit message 中 emoji 的使用的。</p>\n</blockquote>\n<p>通过在 Alfred 中键入 gitmoji 就会列出所有的 gitmoji，可以通过 <a href=\"https://gitmoji.carloscuesta.me/\" target=\"_blank\" rel=\"noopener\">gitmoji</a> 官网中提供的 emoji 名称和释义来搜索。按下回车就复制到了粘贴板，并且粘贴到你当前 focus 的窗口的输入框。</p>\n<h2 id=\"wrench-搭建工作环境\"><a href=\"#wrench-搭建工作环境\" class=\"headerlink\" title=\":wrench: 搭建工作环境\"></a>:wrench: 搭建工作环境</h2><p>在 Alfred 打开时，键入 <code>⌘ + ,</code> 就会进入到偏好页。在 Alfred偏好页 -&gt; Workflows 左侧 workflow 列表的最下方点击加号新建一个空白的 workflow。</p>\n<center><br><br><img src=\"http://pjcw35d11.bkt.clouddn.com/workflow-list.png\" alt=\"abc\"><br><br></center>\n\n<p>在创建 workflow 的弹窗，填写好基本信息，需要注意的是 Bundle Id 是你这个 workflow 的签名。需要填写的独特一些。</p>\n<center><br><br><img src=\"http://pjcw35d11.bkt.clouddn.com/create-workflow\" alt=\"alt\"><br><br></center>\n\n<p>在空白的 workflow 界面，右键。根据我们这次需要开发的 wolkflow 的特性选择 Inputs 为 Script Filter。</p>\n<center><br><br><img src=\"http://pjcw35d11.bkt.clouddn.com/workflow-script-filter\" alt=\"alt\"><br><br></center>\n\n<p>\b然后填写关键词的一些描述信息，包括输入关键词的标题，副标题，和 Loading 时的占位词等等一些设置。</p>\n<p>当然最重要的就是设置得到\b用户输入之后，对这个输入进行处理然后输出的脚本。</p>\n<center><br><br><img src=\"http://pjcw35d11.bkt.clouddn.com/workflow-hotkey\" alt=\"alt\"><br><br></center>\n\n\n<p>Alfred 提供了几种脚本语言的运行时。</p>\n<center><br><br><img src=\"http://pjcw35d11.bkt.clouddn.com/workflow-langs\" alt=\"languages\"><br><br></center>\n\n<p>一开始觉得这种插件的开发应该是 JS 的天下。没想到在 Github 上用来开发 workflow 的最多的语言居然是 PHP。我也随大流的选择了 PHP 来进行这次开发。</p>\n<p>\b脚本输入框内就是最关键的两行代码，我们的脚本入口：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$query = urlencode( <span class=\"string\">\"&#123;query&#125;\"</span> );</span><br><span class=\"line\"><span class=\"keyword\">require_once</span>(<span class=\"string\">\"gitmoji.php\"</span>);</span><br></pre></td></tr></table></figure>\n<p>在 Alfred 中。输入<code>gitmoji</code>， 这个关键字后面输入的文字就作为 <code>{query}</code> 作为我们脚本的输入。也就是上面我们把这个输入 <code>urlencode</code> 之后赋给了变量 <code>$query</code>。我们然后引用了 <code>gitmoji.php</code>。我们做的搜索逻辑就是在这个 php 文件中完成的。</p>\n<p>在列表中右键这个 workflow, 选择在 Finder 中打开，我们就可以看到两个文件。<code>info.plist</code>, <code>icon.png</code>。<code>info.plist</code> 就包含了我们刚刚填写的所有基本信息和设置选项的 xml 文件。你可以双击打开查看。<br>所以再创建一个 <code>gitmoji.php</code> 就完成了一个 workflow 的开发了。</p>\n<center><br><br><img src=\"http://pjcw35d11.bkt.clouddn.com/workflow\" alt=\"alt\"><br><br></center>\n\n\n<p>刚刚打开的路径是<code>/Users/xxxx/Library/Application\\ Support/Alfred\\3/Alfred.alfredpreferences/workflows/user.workflow.xxxxx/</code>。</p>\n<p>我们一般不会选择直接在上面这个路径我们的开发目录，因为这根本不是我们的开发地盘。</p>\n<p>所以在自己常用的开发目录下新建一个目录，将上面得到的两个文件拷贝过来。我们新建一个空白的 workflow 的目的就是先得到这两个文件。</p>\n<p>我们不在 Alfred 存放 workflow 的目录开发，那我们怎么将我们源码放置到 workflow 指定的目录呢？</p>\n<p>其实 Alfred 的 workflow 的文件扩展是类似 <code>gitmoji.workflow</code> 的一个压缩文件。双击这个压缩文件 Alfred 就会安装这个插件到上面的路径。</p>\n<p>所以我们就需要一个脚本帮我们完成这个压缩（打包）的工作。</p>\n<p>这里借鉴(copy)的是 <a href=\"https://github.com/gharlan/alfred-github-workflow/blob/master/bin/build\" target=\"_blank\" rel=\"noopener\">alfred-github-workflow</a> 的打包\b脚本。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env php</span></span><br><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"comment\">// Forked from https://github.com/gharlan/alfred-github-workflow/blob/master/bin/build</span></span><br><span class=\"line\"></span><br><span class=\"line\">$dir = dirname(<span class=\"keyword\">__DIR__</span>);</span><br><span class=\"line\">$VERSION = <span class=\"string\">\"1.0.0\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">require</span> $dir.<span class=\"string\">'/workflows.php'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">$plist = $dir.<span class=\"string\">'/info.plist'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">exec(sprintf(<span class=\"string\">'/usr/libexec/PlistBuddy -c \"Set :version %s\" %s'</span>, $VERSION, escapeshellarg($plist)));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// $changelog = file_get_contents($dir.'/CHANGELOG.md');</span></span><br><span class=\"line\"><span class=\"comment\">// $changelog = str_replace(\"\\n\", '\\n', $changelog);</span></span><br><span class=\"line\"><span class=\"comment\">// exec(sprintf('/usr/libexec/PlistBuddy -c \"Set :readme \\\"%s\\\"\" %s', escapeshellcmd($changelog), escapeshellarg($plist)));</span></span><br><span class=\"line\"></span><br><span class=\"line\">$zipFile = $dir.<span class=\"string\">'/github.zip'</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (file_exists($zipFile)) &#123;</span><br><span class=\"line\">    unlink($zipFile);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$zip = <span class=\"keyword\">new</span> PharData($zipFile);</span><br><span class=\"line\"></span><br><span class=\"line\">$files = <span class=\"keyword\">array</span>(</span><br><span class=\"line\">    <span class=\"string\">'icon.png'</span>,</span><br><span class=\"line\">    <span class=\"string\">'info.plist'</span>,</span><br><span class=\"line\">    <span class=\"string\">'gitmoji.php'</span>,</span><br><span class=\"line\">    <span class=\"string\">'README.md'</span>,</span><br><span class=\"line\">    <span class=\"string\">'workflows.php'</span>,</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">foreach</span> ($files <span class=\"keyword\">as</span> $file) &#123;</span><br><span class=\"line\">    $zip-&gt;addFile($dir.<span class=\"string\">'/'</span>.$file, $file);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">foreach</span> (glob($dir.<span class=\"string\">'/icons/*.png'</span>) <span class=\"keyword\">as</span> $path) &#123;</span><br><span class=\"line\">    $zip-&gt;addFile($path, <span class=\"string\">'icons/'</span>.basename($path));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$zip-&gt;compressFiles(Phar::GZ);</span><br><span class=\"line\"></span><br><span class=\"line\">$workflow = $dir.<span class=\"string\">'/gitmoji.alfredworkflow'</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (file_exists($workflow)) &#123;</span><br><span class=\"line\">    unlink($workflow);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">rename($zipFile, $workflow);</span><br></pre></td></tr></table></figure>\n<p>它所做的事情就是将源码（workflow 需要的几个文件）通过 php 的 PharData 类将\b生成一个压缩包。双击就能被 Alfred 安装。安装也就是解压缩之后复制到 workflow 的工作目录。</p>\n<h2 id=\"rocket-写脚本\"><a href=\"#rocket-写脚本\" class=\"headerlink\" title=\"\b:rocket: 写脚本\"></a>\b:rocket: 写脚本</h2><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"keyword\">require_once</span>(<span class=\"string\">'workflows.php'</span>);</span><br><span class=\"line\">$w = <span class=\"keyword\">new</span> Workflows();</span><br><span class=\"line\">$query = urldecode(strtolower(trim($query)));</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 一周更新一次 --&gt;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (filemtime(<span class=\"string\">\"data.json\"</span>) &lt;= (time() - <span class=\"number\">86400</span> * <span class=\"number\">7</span>)) &#123;</span><br><span class=\"line\">    $dataUrl = <span class=\"string\">'https://raw.githubusercontent.com/carloscuesta/gitmoji/master/src/data/gitmojis.json'</span>;</span><br><span class=\"line\">    $gitmojis = $w-&gt;request($dataUrl);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">isset</span>(json_decode($gitmojis)-&gt;gitmojis)) &#123;</span><br><span class=\"line\">        file_put_contents(<span class=\"string\">\"data.json\"</span>, $gitmojis);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 将 gitmoji 的数据设置成 Alfred 可读的数据结构  --&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setResult</span><span class=\"params\">($gitmojis)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">global</span> $w;</span><br><span class=\"line\">    <span class=\"keyword\">foreach</span> ($gitmojis <span class=\"keyword\">as</span> $key =&gt; $value) &#123;</span><br><span class=\"line\">        $id = $value-&gt;name;</span><br><span class=\"line\">        $arg = $value-&gt;code;</span><br><span class=\"line\">        $emoji = $value-&gt;emoji;</span><br><span class=\"line\">        $title = $emoji.<span class=\"string\">\" \"</span>.$value-&gt;description;</span><br><span class=\"line\">        $subTitle = <span class=\"string\">\"Copy \"</span>.$arg.<span class=\"string\">\" to clipboard\"</span>;</span><br><span class=\"line\">        $w-&gt;result($id, $arg, $title, $subTitle, <span class=\"string\">' '</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 通过搜索词过滤出结果 --&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">filter</span><span class=\"params\">($var)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">global</span> $query;</span><br><span class=\"line\">    $description = strtolower($var-&gt;description);</span><br><span class=\"line\">    $name = strtolower($var-&gt;name);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> strpos($description,$query) !== <span class=\"keyword\">false</span> || strpos($name,$query) !== <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$gitmojis = json_decode(file_get_contents(<span class=\"string\">'data.json'</span>))-&gt;gitmojis;</span><br><span class=\"line\">$data = $gitmojis;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 没有关键词就显示所有 gitmoji --&gt;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (strlen($query) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    $data = array_filter($gitmojis, <span class=\"string\">\"filter\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 得到的搜索，设置到缓冲区 --&gt;</span><br><span class=\"line\">setResult($data);</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 将结果输出成 Alfred 可读的 xml --&gt;</span><br><span class=\"line\"><span class=\"keyword\">echo</span> $w-&gt;toxml();</span><br></pre></td></tr></table></figure>\n<p>脚本只有短短的42行。能这么短的原因是社区有已经封装好的很好用的 <a href=\"https://github.com/jdfwarrior/Workflows\" target=\"_blank\" rel=\"noopener\">workflow util</a>。</p>\n<p>我们用到的这个 util 的方法只有<code>result</code>，<code>toxml</code>。</p>\n<p><code>result</code>方法就是把数据推到一个缓冲区，并且设置了 Alfred 最终显示的每一行的数据结构。这个结构包括<code>$uid, $arg, $title, $sub, $icon</code>。依次对应唯一ID、结果（复制到粘贴板的字符串）、标题、副标题、icon。注意这里的 icon 只能是本地资源，不能是服务器资源。</p>\n<p><code>toxml</code>方法就是把缓冲区的数据转成 Alfred 可读的 <code>xml</code> 格式。</p>\n<p>我做的事情就是获取 gitmoji 托管在 github 上的 json 数据，缓存到本地。根据关键词通过字符串匹配名字和释义。将过滤之后得到的数据转成 Alfred 需要的数据格式，然后转成 xml。</p>\n<p>然后再终端运行 <code>./bin/build</code>。就得到了一个 Alfred workflow: <code>gitmoji.workflow</code>。:tada::tada:</p>\n<p>双击<code>gitmoji.workflow</code>安装，就可以在 Alfred 中和 gitmoji 尽情玩耍了。</p>\n<h2 id=\"robot-TODO\"><a href=\"#robot-TODO\" class=\"headerlink\" title=\":robot: TODO\"></a>:robot: TODO</h2><p>其实可以做到事情还有</p>\n<ul>\n<li>根据不同的语言来搜索 gitmoji。可惜 gitmoji 的维护者说还<a href=\"https://github.com/carloscuesta/gitmoji/issues/217\" target=\"_blank\" rel=\"noopener\">没有找到好的方法</a>维护多语言翻译。</li>\n<li>为了保持和 gitmoji 源码数据的同步，没有使用 emoji 图片作为 icon。因为这样每次 gitmoji 数据一更新，这个 workflow 也需要更新。</li>\n<li>增加 update 命令：立即同步 github 数据。</li>\n</ul>\n"},{"title":"和 Github 客户端学习 Electron","date":"2019-07-30T10:50:32.000Z","_content":"\n最近有机会能够使用 Electron 开发一个简单的编辑器。但是写完第一版之后，应用虽然能 work, 但是代码结构简单，就是简单的读取数据，渲染数据，毫无设计可言。所以想看看 Real World 的代码到底是怎样设计的。\n\n最终在 Github 上找到最符合我需求的一个 Electron 项目仓库 -- [Github Desktop](https://github.com/desktop/desktop)（Github 客户端，以下简称 Desktop）。已经发布过多个版本，用户量客观，代码成熟，基于 Typescript 和 React。和我使用的技术栈完全吻合。So Let's Get Started.\n\n## Workflow\n首先先介绍下我的项目的 Workflow。\n\n我们知道 Electron 分为两类进程，main 和 renderer。main 负责创建应用，创建窗口等等。本质上是一个 node 进程。而 renderer 进程用于渲染界面。\n\n所以写了两个 webpack config, `webpack.main.js` 和 `webpack.renderer.js` 分别对应 main 进程和 renderer 进程。\n开发时使用 `npm-run-all` 同时运行这两个 webpack 编译。main 进程虽然采用了 webpack 的 watch 模式。但是编译后需要手动重新运行 `electron .` 才能看到 main 进程修改代码后的效果。为了解决这个问题，使用了 nodeman 监听编译后的 `main.js`，一旦 webpack 重新编译了 main 进程，nodeman 监听到改动就会自动执行 `electron .` 打开应用。renderer 进程就和普通的 web 项目无异，使用 webpack-dev-server HMR 就能有很好的开发体验。在开发环境 main 进程 创建窗口时 loadUrl 使用 localhost 即可。\n\nDesktop ”激进“的使用了 TS 来编写 webpack 配置，这其实是被 webpack 官方支持的，只需要安装 `ts-node` 即可。其实对于 webpack 复杂的配置，能使用 TS 是再好不过了。\n\nDesktop 需要编译的不仅仅是 main 和 renderer 两部分。还包括 cli（Github 客户端命令行工具）, crash-window, akapass（登录验证）, highligter（代码着色）。所以 Desktop 分为 `webpack.dev.ts` 和 `webpack.prod.ts`, 分别对应开发环境和生产环境的代码编译，且分别导出一个 webpack 配置对象数组对应上面的每个部分的 webpack 配置。导出对象数组其实也是被 webpack 官方所支持的。\n\n## 领域模型\n\n## 数据流及状态管理\n\n### 复杂数据持久化\n\n我在看 Desktop 的代码之前一直有一个执念是对磁盘的读写只能在 main 进程进行，renderer 进程只负责渲染界面。所以我设计的是在 renderer 进程渲染数据或者更新数据的时候都需要通过 IPC 到 main 进程来完成最终的磁盘读写。除去读写正常的情况，还要考虑读写磁盘的异常，这样导致数据流异常的绕。\n\n我采用的数据持久化是基于 [electron-store](https://github.com/sindresorhus/electron-store#readme), 它的实现是基于 JSON 文件。Desktop 采用的是 [Dexie](https://github.com/dfahlander/Dexie.js)，这是对浏览器标准数据库 indexedDB 的一个封装。从它的 Readme 可以看到它主要解决了三个 indexedDB 的问题：\n\n1. 不明确的异常处理\n2. 查询很烂\n3. 代码复杂\n\n因为 Desktop 采用的是浏览器存储。所以完全没有我所遇到的问题，读写都在 renderer 进行了，而且有一个好处是能够使用 Chrome Devtools 来查看数据。\n\n### Dexie\nDesktop 定义了一个 `BaseDatabase` 抽象基类, 其继承于 Dexie。Dexie 比较简单，需要注意的点是:\n1. 每一个数据库都是有版本的，后续的版本的 schema 可以通过 Dexie.version(xx).stores(schema) 来更新数据库的 schema。\n2. 对数据库的读写只能发生在 transaction（事务）的上下文中。\n\n### 简单数据持久化\n关于一些 UI 状态的标志位存储，Desktop 使用的是 `localStorage`。值得学习的是它封装了一些工具方法便于操作 `localStorage`.\n\n```typescript\nexport function getBoolean(key: string): boolean | undefined\nexport function getBoolean(key: string, defaultValue: boolean): boolean\nexport function getBoolean(\n  key: string,\n  defaultValue?: boolean\n): boolean | undefined {\n  const value = localStorage.getItem(key)\n  if (value === null) {\n    return defaultValue\n  }\n\n  if (value === '1' || value === 'true') {\n    return true\n  }\n\n  if (value === '0' || value === 'false') {\n    return false\n  }\n\n  return defaultValue\n}\n\nexport function setBoolean(key: string, value: boolean) {\n  localStorage.setItem(key, value ? '1' : '0')\n}\n```\n\n[详见](https://github.com/desktop/desktop/blob/development/app/src/lib/local-storage.ts)\n\n### 状态管理\nDesktop 没有使用目前前端开发中常见的 `Redux`，`Mobx` 等状态管理库。\n\n这些状态管理库的数据流差不多可以用下面的表示\n\n```\nview(store binded) => action dispatced => change the store => react to all views\n```\n\nDesktop 同这些方案类似，只是最后一步不一样，它的 Store 基于事件机制 EventEmitter. 和上述自动更新不同的是在更新了 store 之后，需要手动调用 `emitUpdate` 方法，这个方法触发了 `did-update` 事件, 也就是调用了 `appStore.onDidUpdate` 方法的回调。在 `app.tsx` 初始化的时候，已经绑定了 `appStore.onDidUpdate` 的回调是触发 React 视图的 `setState`。\n\n```ts\nprops.appStore.onDidUpdate(state => {\n    this.setState(state)\n})\n```\n\n这样就实行了修改 store 之后，更新所有视图的操作。\n\n那这里有一个疑问，高频率 store 更新，高频率的调用 `emitUpdate` 岂不是会带来性能问题，这里 Desktop 做了一个优化是，开启了一个队列，只会在浏览器的每一帧绘制的时候才会使用最新的 state 去执行真正的更新视图 `emitUpdateNow` 方法。将高频率的 `emitUpdate` 调用给节流了。\n\n```ts\nprotected emitUpdate() {\n    if (this.windowState === 'hidden') {\n        this.emitUpdateNow()\n        return\n    }\n\n    if (this.emitQueued) {\n        return\n    }\n\n    this.emitQueued = true\n\n    window.requestAnimationFrame(() => {\n        this.emitUpdateNow()\n    })\n}\n\nprivate emitUpdateNow() {\n    this.emitQueued = false\n    const state = this.getState()\n\n    super.emitUpdate(state)\n    updateMenuState(state, this.appMenu)\n}\n```\n\n此外，appStore 还集中管理了所有子 store, 当这些 store 更新的时候触发了 appStore 的 `emitUpdate`。\n\n\n## Menu\n\n### Context-Menu\nDesktop 的 contextmenu 的实现基于原生 IPC 的，比较绕。\n\n首先我们需要知道的是 Menu 类是 main process only 的。\n\n在需要 contextmenu 的 JSX.Element 上绑定 `onContextMenu` 事件。构造对象数组 Array<MenuItem>, 并且为每个 MenuItem 对象绑定触发事件，再通过 IPC 将对象传递至 main 进程，值得一提的是这个时候将 MenuItem 数组赋值给了一个全局对象，暂存起来。在 main 进程构造出真正的 MenuItem 实例，绑定 MenuItem 的点击事件，触发 MenuItem 点击事件的时候记录 MenuItem 的 序列号 index，再将 index 通过 event.sender.send 将 index 传递到 renderer 进程。renderer 进程拿到 index 之后根据之前保存的全局对象取出单个 MenuItem， 执行绑定的事件。\n\n```\nonContextMenu => showContextualMenu (暂存MenuItems，ipcRenderer.send) => icpMain => menu.popup() => MenuItem.onClick(index) => event.sernder.send(index) => MenuItem.action()\n```\n\n所以在我的应用中会使用 remote 对象屏蔽上述复杂的 IPC 通信。在 renderer 进程完成 Menu 的构造展示和事件的绑定触发。\n\n\n## 日志\n完善的日志可用于 debug，了解 UI 状态迁移背后的数据变动和流程的正确与否。\n\nDesktop 的日志基于日志库，[winston](https://github.com/winstonjs/winston#readme)。\n\n在 main 进程和 renderer 进程都提供了全局 log 对象，接口都是一致的。分别是 `debug`, `info`, `warn`, `error`。在 render 进程，简单的封装了 `window.console` 对象上的 `debug`, `info`, `warn`, `error` 方法，日志打印到控制台的时候通过 IPC 传递到 main 进程，由 main 进程统一管理。 \n\nmain 进程接收了来自 renderer 进程的日志信息和 main 进程自身的日志信息。设置了两个 `transports`。`winston.transports.Console` 和 `winston.transports.DailyRotateFile` 分别用于将日志信息打印在控制台和存储在磁盘文件。DailyRotateFile 以天为单位，设置了最多存储 14 天的上限。\n\n在 main 进程和 renderer 进程启动时分别引入日志安装模块。因为 log 方法都是暴露在全局，因此只需要引入一次即可。在 TS 环境中还需要添加 log 方法的类型声明。\n\n[详见](https://github.com/desktop/desktop/tree/development/app/src/lib/logging)\n\n## 其他\n\n### 组件文件命名及模块\n首先需要推荐的的是任何文件命名都以`kebab-case`的方式。\n\n然后在导出一个组件时，如下几种方案我们应该采取哪一种呢\n\n1. \n\n```\n|__button\n|___index.tsx # `export { default as button } from './button'`\n|___button.tsx # `export default class Button extends React.Component{}`\n```\n\n2. \n```\n|__button\n|___index.tsx # `export default class Button extends React.Component{}`\n```\n\n3. \n```\n|__button\n|___button.tsx # `export default class Button extends React.Component{}`\n```\n\nDesktop 采用的第一种方式。这种方式\n\n\n### CSS 目录结构\n尽量一个组件一个样式文件，便于维护更新。","source":"_drafts/github-desktop.md","raw":"---\ntitle: 和 Github 客户端学习 Electron\ndate: 2019-07-30 18:50:32\ntags:\n---\n\n最近有机会能够使用 Electron 开发一个简单的编辑器。但是写完第一版之后，应用虽然能 work, 但是代码结构简单，就是简单的读取数据，渲染数据，毫无设计可言。所以想看看 Real World 的代码到底是怎样设计的。\n\n最终在 Github 上找到最符合我需求的一个 Electron 项目仓库 -- [Github Desktop](https://github.com/desktop/desktop)（Github 客户端，以下简称 Desktop）。已经发布过多个版本，用户量客观，代码成熟，基于 Typescript 和 React。和我使用的技术栈完全吻合。So Let's Get Started.\n\n## Workflow\n首先先介绍下我的项目的 Workflow。\n\n我们知道 Electron 分为两类进程，main 和 renderer。main 负责创建应用，创建窗口等等。本质上是一个 node 进程。而 renderer 进程用于渲染界面。\n\n所以写了两个 webpack config, `webpack.main.js` 和 `webpack.renderer.js` 分别对应 main 进程和 renderer 进程。\n开发时使用 `npm-run-all` 同时运行这两个 webpack 编译。main 进程虽然采用了 webpack 的 watch 模式。但是编译后需要手动重新运行 `electron .` 才能看到 main 进程修改代码后的效果。为了解决这个问题，使用了 nodeman 监听编译后的 `main.js`，一旦 webpack 重新编译了 main 进程，nodeman 监听到改动就会自动执行 `electron .` 打开应用。renderer 进程就和普通的 web 项目无异，使用 webpack-dev-server HMR 就能有很好的开发体验。在开发环境 main 进程 创建窗口时 loadUrl 使用 localhost 即可。\n\nDesktop ”激进“的使用了 TS 来编写 webpack 配置，这其实是被 webpack 官方支持的，只需要安装 `ts-node` 即可。其实对于 webpack 复杂的配置，能使用 TS 是再好不过了。\n\nDesktop 需要编译的不仅仅是 main 和 renderer 两部分。还包括 cli（Github 客户端命令行工具）, crash-window, akapass（登录验证）, highligter（代码着色）。所以 Desktop 分为 `webpack.dev.ts` 和 `webpack.prod.ts`, 分别对应开发环境和生产环境的代码编译，且分别导出一个 webpack 配置对象数组对应上面的每个部分的 webpack 配置。导出对象数组其实也是被 webpack 官方所支持的。\n\n## 领域模型\n\n## 数据流及状态管理\n\n### 复杂数据持久化\n\n我在看 Desktop 的代码之前一直有一个执念是对磁盘的读写只能在 main 进程进行，renderer 进程只负责渲染界面。所以我设计的是在 renderer 进程渲染数据或者更新数据的时候都需要通过 IPC 到 main 进程来完成最终的磁盘读写。除去读写正常的情况，还要考虑读写磁盘的异常，这样导致数据流异常的绕。\n\n我采用的数据持久化是基于 [electron-store](https://github.com/sindresorhus/electron-store#readme), 它的实现是基于 JSON 文件。Desktop 采用的是 [Dexie](https://github.com/dfahlander/Dexie.js)，这是对浏览器标准数据库 indexedDB 的一个封装。从它的 Readme 可以看到它主要解决了三个 indexedDB 的问题：\n\n1. 不明确的异常处理\n2. 查询很烂\n3. 代码复杂\n\n因为 Desktop 采用的是浏览器存储。所以完全没有我所遇到的问题，读写都在 renderer 进行了，而且有一个好处是能够使用 Chrome Devtools 来查看数据。\n\n### Dexie\nDesktop 定义了一个 `BaseDatabase` 抽象基类, 其继承于 Dexie。Dexie 比较简单，需要注意的点是:\n1. 每一个数据库都是有版本的，后续的版本的 schema 可以通过 Dexie.version(xx).stores(schema) 来更新数据库的 schema。\n2. 对数据库的读写只能发生在 transaction（事务）的上下文中。\n\n### 简单数据持久化\n关于一些 UI 状态的标志位存储，Desktop 使用的是 `localStorage`。值得学习的是它封装了一些工具方法便于操作 `localStorage`.\n\n```typescript\nexport function getBoolean(key: string): boolean | undefined\nexport function getBoolean(key: string, defaultValue: boolean): boolean\nexport function getBoolean(\n  key: string,\n  defaultValue?: boolean\n): boolean | undefined {\n  const value = localStorage.getItem(key)\n  if (value === null) {\n    return defaultValue\n  }\n\n  if (value === '1' || value === 'true') {\n    return true\n  }\n\n  if (value === '0' || value === 'false') {\n    return false\n  }\n\n  return defaultValue\n}\n\nexport function setBoolean(key: string, value: boolean) {\n  localStorage.setItem(key, value ? '1' : '0')\n}\n```\n\n[详见](https://github.com/desktop/desktop/blob/development/app/src/lib/local-storage.ts)\n\n### 状态管理\nDesktop 没有使用目前前端开发中常见的 `Redux`，`Mobx` 等状态管理库。\n\n这些状态管理库的数据流差不多可以用下面的表示\n\n```\nview(store binded) => action dispatced => change the store => react to all views\n```\n\nDesktop 同这些方案类似，只是最后一步不一样，它的 Store 基于事件机制 EventEmitter. 和上述自动更新不同的是在更新了 store 之后，需要手动调用 `emitUpdate` 方法，这个方法触发了 `did-update` 事件, 也就是调用了 `appStore.onDidUpdate` 方法的回调。在 `app.tsx` 初始化的时候，已经绑定了 `appStore.onDidUpdate` 的回调是触发 React 视图的 `setState`。\n\n```ts\nprops.appStore.onDidUpdate(state => {\n    this.setState(state)\n})\n```\n\n这样就实行了修改 store 之后，更新所有视图的操作。\n\n那这里有一个疑问，高频率 store 更新，高频率的调用 `emitUpdate` 岂不是会带来性能问题，这里 Desktop 做了一个优化是，开启了一个队列，只会在浏览器的每一帧绘制的时候才会使用最新的 state 去执行真正的更新视图 `emitUpdateNow` 方法。将高频率的 `emitUpdate` 调用给节流了。\n\n```ts\nprotected emitUpdate() {\n    if (this.windowState === 'hidden') {\n        this.emitUpdateNow()\n        return\n    }\n\n    if (this.emitQueued) {\n        return\n    }\n\n    this.emitQueued = true\n\n    window.requestAnimationFrame(() => {\n        this.emitUpdateNow()\n    })\n}\n\nprivate emitUpdateNow() {\n    this.emitQueued = false\n    const state = this.getState()\n\n    super.emitUpdate(state)\n    updateMenuState(state, this.appMenu)\n}\n```\n\n此外，appStore 还集中管理了所有子 store, 当这些 store 更新的时候触发了 appStore 的 `emitUpdate`。\n\n\n## Menu\n\n### Context-Menu\nDesktop 的 contextmenu 的实现基于原生 IPC 的，比较绕。\n\n首先我们需要知道的是 Menu 类是 main process only 的。\n\n在需要 contextmenu 的 JSX.Element 上绑定 `onContextMenu` 事件。构造对象数组 Array<MenuItem>, 并且为每个 MenuItem 对象绑定触发事件，再通过 IPC 将对象传递至 main 进程，值得一提的是这个时候将 MenuItem 数组赋值给了一个全局对象，暂存起来。在 main 进程构造出真正的 MenuItem 实例，绑定 MenuItem 的点击事件，触发 MenuItem 点击事件的时候记录 MenuItem 的 序列号 index，再将 index 通过 event.sender.send 将 index 传递到 renderer 进程。renderer 进程拿到 index 之后根据之前保存的全局对象取出单个 MenuItem， 执行绑定的事件。\n\n```\nonContextMenu => showContextualMenu (暂存MenuItems，ipcRenderer.send) => icpMain => menu.popup() => MenuItem.onClick(index) => event.sernder.send(index) => MenuItem.action()\n```\n\n所以在我的应用中会使用 remote 对象屏蔽上述复杂的 IPC 通信。在 renderer 进程完成 Menu 的构造展示和事件的绑定触发。\n\n\n## 日志\n完善的日志可用于 debug，了解 UI 状态迁移背后的数据变动和流程的正确与否。\n\nDesktop 的日志基于日志库，[winston](https://github.com/winstonjs/winston#readme)。\n\n在 main 进程和 renderer 进程都提供了全局 log 对象，接口都是一致的。分别是 `debug`, `info`, `warn`, `error`。在 render 进程，简单的封装了 `window.console` 对象上的 `debug`, `info`, `warn`, `error` 方法，日志打印到控制台的时候通过 IPC 传递到 main 进程，由 main 进程统一管理。 \n\nmain 进程接收了来自 renderer 进程的日志信息和 main 进程自身的日志信息。设置了两个 `transports`。`winston.transports.Console` 和 `winston.transports.DailyRotateFile` 分别用于将日志信息打印在控制台和存储在磁盘文件。DailyRotateFile 以天为单位，设置了最多存储 14 天的上限。\n\n在 main 进程和 renderer 进程启动时分别引入日志安装模块。因为 log 方法都是暴露在全局，因此只需要引入一次即可。在 TS 环境中还需要添加 log 方法的类型声明。\n\n[详见](https://github.com/desktop/desktop/tree/development/app/src/lib/logging)\n\n## 其他\n\n### 组件文件命名及模块\n首先需要推荐的的是任何文件命名都以`kebab-case`的方式。\n\n然后在导出一个组件时，如下几种方案我们应该采取哪一种呢\n\n1. \n\n```\n|__button\n|___index.tsx # `export { default as button } from './button'`\n|___button.tsx # `export default class Button extends React.Component{}`\n```\n\n2. \n```\n|__button\n|___index.tsx # `export default class Button extends React.Component{}`\n```\n\n3. \n```\n|__button\n|___button.tsx # `export default class Button extends React.Component{}`\n```\n\nDesktop 采用的第一种方式。这种方式\n\n\n### CSS 目录结构\n尽量一个组件一个样式文件，便于维护更新。","slug":"github-desktop","published":0,"updated":"2019-10-09T09:48:03.209Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhpu92wv0003ak87kimovalh","content":"<p>最近有机会能够使用 Electron 开发一个简单的编辑器。但是写完第一版之后，应用虽然能 work, 但是代码结构简单，就是简单的读取数据，渲染数据，毫无设计可言。所以想看看 Real World 的代码到底是怎样设计的。</p>\n<p>最终在 Github 上找到最符合我需求的一个 Electron 项目仓库 – <a href=\"https://github.com/desktop/desktop\" target=\"_blank\" rel=\"noopener\">Github Desktop</a>（Github 客户端，以下简称 Desktop）。已经发布过多个版本，用户量客观，代码成熟，基于 Typescript 和 React。和我使用的技术栈完全吻合。So Let’s Get Started.</p>\n<h2 id=\"Workflow\"><a href=\"#Workflow\" class=\"headerlink\" title=\"Workflow\"></a>Workflow</h2><p>首先先介绍下我的项目的 Workflow。</p>\n<p>我们知道 Electron 分为两类进程，main 和 renderer。main 负责创建应用，创建窗口等等。本质上是一个 node 进程。而 renderer 进程用于渲染界面。</p>\n<p>所以写了两个 webpack config, <code>webpack.main.js</code> 和 <code>webpack.renderer.js</code> 分别对应 main 进程和 renderer 进程。<br>开发时使用 <code>npm-run-all</code> 同时运行这两个 webpack 编译。main 进程虽然采用了 webpack 的 watch 模式。但是编译后需要手动重新运行 <code>electron .</code> 才能看到 main 进程修改代码后的效果。为了解决这个问题，使用了 nodeman 监听编译后的 <code>main.js</code>，一旦 webpack 重新编译了 main 进程，nodeman 监听到改动就会自动执行 <code>electron .</code> 打开应用。renderer 进程就和普通的 web 项目无异，使用 webpack-dev-server HMR 就能有很好的开发体验。在开发环境 main 进程 创建窗口时 loadUrl 使用 localhost 即可。</p>\n<p>Desktop ”激进“的使用了 TS 来编写 webpack 配置，这其实是被 webpack 官方支持的，只需要安装 <code>ts-node</code> 即可。其实对于 webpack 复杂的配置，能使用 TS 是再好不过了。</p>\n<p>Desktop 需要编译的不仅仅是 main 和 renderer 两部分。还包括 cli（Github 客户端命令行工具）, crash-window, akapass（登录验证）, highligter（代码着色）。所以 Desktop 分为 <code>webpack.dev.ts</code> 和 <code>webpack.prod.ts</code>, 分别对应开发环境和生产环境的代码编译，且分别导出一个 webpack 配置对象数组对应上面的每个部分的 webpack 配置。导出对象数组其实也是被 webpack 官方所支持的。</p>\n<h2 id=\"领域模型\"><a href=\"#领域模型\" class=\"headerlink\" title=\"领域模型\"></a>领域模型</h2><h2 id=\"数据流及状态管理\"><a href=\"#数据流及状态管理\" class=\"headerlink\" title=\"数据流及状态管理\"></a>数据流及状态管理</h2><h3 id=\"复杂数据持久化\"><a href=\"#复杂数据持久化\" class=\"headerlink\" title=\"复杂数据持久化\"></a>复杂数据持久化</h3><p>我在看 Desktop 的代码之前一直有一个执念是对磁盘的读写只能在 main 进程进行，renderer 进程只负责渲染界面。所以我设计的是在 renderer 进程渲染数据或者更新数据的时候都需要通过 IPC 到 main 进程来完成最终的磁盘读写。除去读写正常的情况，还要考虑读写磁盘的异常，这样导致数据流异常的绕。</p>\n<p>我采用的数据持久化是基于 <a href=\"https://github.com/sindresorhus/electron-store#readme\" target=\"_blank\" rel=\"noopener\">electron-store</a>, 它的实现是基于 JSON 文件。Desktop 采用的是 <a href=\"https://github.com/dfahlander/Dexie.js\" target=\"_blank\" rel=\"noopener\">Dexie</a>，这是对浏览器标准数据库 indexedDB 的一个封装。从它的 Readme 可以看到它主要解决了三个 indexedDB 的问题：</p>\n<ol>\n<li>不明确的异常处理</li>\n<li>查询很烂</li>\n<li>代码复杂</li>\n</ol>\n<p>因为 Desktop 采用的是浏览器存储。所以完全没有我所遇到的问题，读写都在 renderer 进行了，而且有一个好处是能够使用 Chrome Devtools 来查看数据。</p>\n<h3 id=\"Dexie\"><a href=\"#Dexie\" class=\"headerlink\" title=\"Dexie\"></a>Dexie</h3><p>Desktop 定义了一个 <code>BaseDatabase</code> 抽象基类, 其继承于 Dexie。Dexie 比较简单，需要注意的点是:</p>\n<ol>\n<li>每一个数据库都是有版本的，后续的版本的 schema 可以通过 Dexie.version(xx).stores(schema) 来更新数据库的 schema。</li>\n<li>对数据库的读写只能发生在 transaction（事务）的上下文中。</li>\n</ol>\n<h3 id=\"简单数据持久化\"><a href=\"#简单数据持久化\" class=\"headerlink\" title=\"简单数据持久化\"></a>简单数据持久化</h3><p>关于一些 UI 状态的标志位存储，Desktop 使用的是 <code>localStorage</code>。值得学习的是它封装了一些工具方法便于操作 <code>localStorage</code>.</p>\n<figure class=\"highlight typescript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getBoolean</span>(<span class=\"params\">key: <span class=\"built_in\">string</span></span>): <span class=\"title\">boolean</span> | <span class=\"title\">undefined</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getBoolean</span>(<span class=\"params\">key: <span class=\"built_in\">string</span>, defaultValue: <span class=\"built_in\">boolean</span></span>): <span class=\"title\">boolean</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\"><span class=\"title\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getBoolean</span>(<span class=\"params\"></span></span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\"><span class=\"function\"><span class=\"params\">  key: <span class=\"built_in\">string</span>,</span></span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\"><span class=\"function\"><span class=\"params\">  defaultValue?: <span class=\"built_in\">boolean</span></span></span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">boolean</span> | <span class=\"title\">undefined</span> </span>{</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\">  <span class=\"title\">const</span> <span class=\"title\">value</span> = <span class=\"title\">localStorage</span>.<span class=\"title\">getItem</span>(<span class=\"params\">key</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\">  <span class=\"title\">if</span> (<span class=\"params\">value === <span class=\"literal\">null</span></span>) </span>{</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">return</span> <span class=\"title\">defaultValue</span></span></span><br><span class=\"line\"><span class=\"function\">  }</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"title\">if</span> (<span class=\"params\">value === '1' || value === '<span class=\"literal\">true</span>'</span>) </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (value === <span class=\"string\">'0'</span> || value === <span class=\"string\">'false'</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> defaultValue</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setBoolean</span>(<span class=\"params\">key: <span class=\"built_in\">string</span>, value: <span class=\"built_in\">boolean</span></span>) </span>{</span><br><span class=\"line\">  localStorage.setItem(key, value ? <span class=\"string\">'1'</span> : <span class=\"string\">'0'</span>)</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p><a href=\"https://github.com/desktop/desktop/blob/development/app/src/lib/local-storage.ts\" target=\"_blank\" rel=\"noopener\">详见</a></p>\n<h3 id=\"状态管理\"><a href=\"#状态管理\" class=\"headerlink\" title=\"状态管理\"></a>状态管理</h3><p>Desktop 没有使用目前前端开发中常见的 <code>Redux</code>，<code>Mobx</code> 等状态管理库。</p>\n<p>这些状态管理库的数据流差不多可以用下面的表示</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">view(store binded) => action dispatced => change the store => react to all views</span><br></pre></td></tr></tbody></table></figure>\n<p>Desktop 同这些方案类似，只是最后一步不一样，它的 Store 基于事件机制 EventEmitter. 和上述自动更新不同的是在更新了 store 之后，需要手动调用 <code>emitUpdate</code> 方法，这个方法触发了 <code>did-update</code> 事件, 也就是调用了 <code>appStore.onDidUpdate</code> 方法的回调。在 <code>app.tsx</code> 初始化的时候，已经绑定了 <code>appStore.onDidUpdate</code> 的回调是触发 React 视图的 <code>setState</code>。</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">props.appStore.onDidUpdate(<span class=\"function\"><span class=\"params\">state</span> =></span> {</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(state)</span><br><span class=\"line\">})</span><br></pre></td></tr></tbody></table></figure>\n<p>这样就实行了修改 store 之后，更新所有视图的操作。</p>\n<p>那这里有一个疑问，高频率 store 更新，高频率的调用 <code>emitUpdate</code> 岂不是会带来性能问题，这里 Desktop 做了一个优化是，开启了一个队列，只会在浏览器的每一帧绘制的时候才会使用最新的 state 去执行真正的更新视图 <code>emitUpdateNow</code> 方法。将高频率的 <code>emitUpdate</code> 调用给节流了。</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> emitUpdate() {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.windowState === <span class=\"string\">'hidden'</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.emitUpdateNow()</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.emitQueued) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.emitQueued = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">window</span>.requestAnimationFrame(<span class=\"function\"><span class=\"params\">()</span> =></span> {</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.emitUpdateNow()</span><br><span class=\"line\">    })</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> emitUpdateNow() {</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.emitQueued = <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> state = <span class=\"keyword\">this</span>.getState()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">super</span>.emitUpdate(state)</span><br><span class=\"line\">    updateMenuState(state, <span class=\"keyword\">this</span>.appMenu)</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>此外，appStore 还集中管理了所有子 store, 当这些 store 更新的时候触发了 appStore 的 <code>emitUpdate</code>。</p>\n<h2 id=\"Menu\"><a href=\"#Menu\" class=\"headerlink\" title=\"Menu\"></a>Menu</h2><h3 id=\"Context-Menu\"><a href=\"#Context-Menu\" class=\"headerlink\" title=\"Context-Menu\"></a>Context-Menu</h3><p>Desktop 的 contextmenu 的实现基于原生 IPC 的，比较绕。</p>\n<p>首先我们需要知道的是 Menu 类是 main process only 的。</p>\n<p>在需要 contextmenu 的 JSX.Element 上绑定 <code>onContextMenu</code> 事件。构造对象数组 Array<menuitem>, 并且为每个 MenuItem 对象绑定触发事件，再通过 IPC 将对象传递至 main 进程，值得一提的是这个时候将 MenuItem 数组赋值给了一个全局对象，暂存起来。在 main 进程构造出真正的 MenuItem 实例，绑定 MenuItem 的点击事件，触发 MenuItem 点击事件的时候记录 MenuItem 的 序列号 index，再将 index 通过 event.sender.send 将 index 传递到 renderer 进程。renderer 进程拿到 index 之后根据之前保存的全局对象取出单个 MenuItem， 执行绑定的事件。</menuitem></p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onContextMenu => showContextualMenu (暂存MenuItems，ipcRenderer.send) => icpMain => menu.popup() => MenuItem.onClick(index) => event.sernder.send(index) => MenuItem.action()</span><br></pre></td></tr></tbody></table></figure>\n<p>所以在我的应用中会使用 remote 对象屏蔽上述复杂的 IPC 通信。在 renderer 进程完成 Menu 的构造展示和事件的绑定触发。</p>\n<h2 id=\"日志\"><a href=\"#日志\" class=\"headerlink\" title=\"日志\"></a>日志</h2><p>完善的日志可用于 debug，了解 UI 状态迁移背后的数据变动和流程的正确与否。</p>\n<p>Desktop 的日志基于日志库，<a href=\"https://github.com/winstonjs/winston#readme\" target=\"_blank\" rel=\"noopener\">winston</a>。</p>\n<p>在 main 进程和 renderer 进程都提供了全局 log 对象，接口都是一致的。分别是 <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code>。在 render 进程，简单的封装了 <code>window.console</code> 对象上的 <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code> 方法，日志打印到控制台的时候通过 IPC 传递到 main 进程，由 main 进程统一管理。 </p>\n<p>main 进程接收了来自 renderer 进程的日志信息和 main 进程自身的日志信息。设置了两个 <code>transports</code>。<code>winston.transports.Console</code> 和 <code>winston.transports.DailyRotateFile</code> 分别用于将日志信息打印在控制台和存储在磁盘文件。DailyRotateFile 以天为单位，设置了最多存储 14 天的上限。</p>\n<p>在 main 进程和 renderer 进程启动时分别引入日志安装模块。因为 log 方法都是暴露在全局，因此只需要引入一次即可。在 TS 环境中还需要添加 log 方法的类型声明。</p>\n<p><a href=\"https://github.com/desktop/desktop/tree/development/app/src/lib/logging\" target=\"_blank\" rel=\"noopener\">详见</a></p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"组件文件命名及模块\"><a href=\"#组件文件命名及模块\" class=\"headerlink\" title=\"组件文件命名及模块\"></a>组件文件命名及模块</h3><p>首先需要推荐的的是任何文件命名都以<code>kebab-case</code>的方式。</p>\n<p>然后在导出一个组件时，如下几种方案我们应该采取哪一种呢</p>\n<ol>\n<li><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|__button</span><br><span class=\"line\">|___index.tsx # `export { default as button } from './button'`</span><br><span class=\"line\">|___button.tsx # `export default class Button extends React.Component{}`</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|__button</span><br><span class=\"line\">|___index.tsx # `export default class Button extends React.Component{}`</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|__button</span><br><span class=\"line\">|___button.tsx # `export default class Button extends React.Component{}`</span><br></pre></td></tr></tbody></table></figure>\n</li>\n</ol>\n<p>Desktop 采用的第一种方式。这种方式</p>\n<h3 id=\"CSS-目录结构\"><a href=\"#CSS-目录结构\" class=\"headerlink\" title=\"CSS 目录结构\"></a>CSS 目录结构</h3><p>尽量一个组件一个样式文件，便于维护更新。</p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"excerpt":"","more":"<p>最近有机会能够使用 Electron 开发一个简单的编辑器。但是写完第一版之后，应用虽然能 work, 但是代码结构简单，就是简单的读取数据，渲染数据，毫无设计可言。所以想看看 Real World 的代码到底是怎样设计的。</p>\n<p>最终在 Github 上找到最符合我需求的一个 Electron 项目仓库 – <a href=\"https://github.com/desktop/desktop\" target=\"_blank\" rel=\"noopener\">Github Desktop</a>（Github 客户端，以下简称 Desktop）。已经发布过多个版本，用户量客观，代码成熟，基于 Typescript 和 React。和我使用的技术栈完全吻合。So Let’s Get Started.</p>\n<h2 id=\"Workflow\"><a href=\"#Workflow\" class=\"headerlink\" title=\"Workflow\"></a>Workflow</h2><p>首先先介绍下我的项目的 Workflow。</p>\n<p>我们知道 Electron 分为两类进程，main 和 renderer。main 负责创建应用，创建窗口等等。本质上是一个 node 进程。而 renderer 进程用于渲染界面。</p>\n<p>所以写了两个 webpack config, <code>webpack.main.js</code> 和 <code>webpack.renderer.js</code> 分别对应 main 进程和 renderer 进程。<br>开发时使用 <code>npm-run-all</code> 同时运行这两个 webpack 编译。main 进程虽然采用了 webpack 的 watch 模式。但是编译后需要手动重新运行 <code>electron .</code> 才能看到 main 进程修改代码后的效果。为了解决这个问题，使用了 nodeman 监听编译后的 <code>main.js</code>，一旦 webpack 重新编译了 main 进程，nodeman 监听到改动就会自动执行 <code>electron .</code> 打开应用。renderer 进程就和普通的 web 项目无异，使用 webpack-dev-server HMR 就能有很好的开发体验。在开发环境 main 进程 创建窗口时 loadUrl 使用 localhost 即可。</p>\n<p>Desktop ”激进“的使用了 TS 来编写 webpack 配置，这其实是被 webpack 官方支持的，只需要安装 <code>ts-node</code> 即可。其实对于 webpack 复杂的配置，能使用 TS 是再好不过了。</p>\n<p>Desktop 需要编译的不仅仅是 main 和 renderer 两部分。还包括 cli（Github 客户端命令行工具）, crash-window, akapass（登录验证）, highligter（代码着色）。所以 Desktop 分为 <code>webpack.dev.ts</code> 和 <code>webpack.prod.ts</code>, 分别对应开发环境和生产环境的代码编译，且分别导出一个 webpack 配置对象数组对应上面的每个部分的 webpack 配置。导出对象数组其实也是被 webpack 官方所支持的。</p>\n<h2 id=\"领域模型\"><a href=\"#领域模型\" class=\"headerlink\" title=\"领域模型\"></a>领域模型</h2><h2 id=\"数据流及状态管理\"><a href=\"#数据流及状态管理\" class=\"headerlink\" title=\"数据流及状态管理\"></a>数据流及状态管理</h2><h3 id=\"复杂数据持久化\"><a href=\"#复杂数据持久化\" class=\"headerlink\" title=\"复杂数据持久化\"></a>复杂数据持久化</h3><p>我在看 Desktop 的代码之前一直有一个执念是对磁盘的读写只能在 main 进程进行，renderer 进程只负责渲染界面。所以我设计的是在 renderer 进程渲染数据或者更新数据的时候都需要通过 IPC 到 main 进程来完成最终的磁盘读写。除去读写正常的情况，还要考虑读写磁盘的异常，这样导致数据流异常的绕。</p>\n<p>我采用的数据持久化是基于 <a href=\"https://github.com/sindresorhus/electron-store#readme\" target=\"_blank\" rel=\"noopener\">electron-store</a>, 它的实现是基于 JSON 文件。Desktop 采用的是 <a href=\"https://github.com/dfahlander/Dexie.js\" target=\"_blank\" rel=\"noopener\">Dexie</a>，这是对浏览器标准数据库 indexedDB 的一个封装。从它的 Readme 可以看到它主要解决了三个 indexedDB 的问题：</p>\n<ol>\n<li>不明确的异常处理</li>\n<li>查询很烂</li>\n<li>代码复杂</li>\n</ol>\n<p>因为 Desktop 采用的是浏览器存储。所以完全没有我所遇到的问题，读写都在 renderer 进行了，而且有一个好处是能够使用 Chrome Devtools 来查看数据。</p>\n<h3 id=\"Dexie\"><a href=\"#Dexie\" class=\"headerlink\" title=\"Dexie\"></a>Dexie</h3><p>Desktop 定义了一个 <code>BaseDatabase</code> 抽象基类, 其继承于 Dexie。Dexie 比较简单，需要注意的点是:</p>\n<ol>\n<li>每一个数据库都是有版本的，后续的版本的 schema 可以通过 Dexie.version(xx).stores(schema) 来更新数据库的 schema。</li>\n<li>对数据库的读写只能发生在 transaction（事务）的上下文中。</li>\n</ol>\n<h3 id=\"简单数据持久化\"><a href=\"#简单数据持久化\" class=\"headerlink\" title=\"简单数据持久化\"></a>简单数据持久化</h3><p>关于一些 UI 状态的标志位存储，Desktop 使用的是 <code>localStorage</code>。值得学习的是它封装了一些工具方法便于操作 <code>localStorage</code>.</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getBoolean</span>(<span class=\"params\">key: <span class=\"built_in\">string</span></span>): <span class=\"title\">boolean</span> | <span class=\"title\">undefined</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getBoolean</span>(<span class=\"params\">key: <span class=\"built_in\">string</span>, defaultValue: <span class=\"built_in\">boolean</span></span>): <span class=\"title\">boolean</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\"><span class=\"title\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getBoolean</span>(<span class=\"params\"></span></span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\"><span class=\"function\"><span class=\"params\">  key: <span class=\"built_in\">string</span>,</span></span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\"><span class=\"function\"><span class=\"params\">  defaultValue?: <span class=\"built_in\">boolean</span></span></span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">boolean</span> | <span class=\"title\">undefined</span> </span>&#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\">  <span class=\"title\">const</span> <span class=\"title\">value</span> = <span class=\"title\">localStorage</span>.<span class=\"title\">getItem</span>(<span class=\"params\">key</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\">  <span class=\"title\">if</span> (<span class=\"params\">value === <span class=\"literal\">null</span></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">return</span> <span class=\"title\">defaultValue</span></span></span><br><span class=\"line\"><span class=\"function\">  &#125;</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"title\">if</span> (<span class=\"params\">value === '1' || value === '<span class=\"literal\">true</span>'</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (value === <span class=\"string\">'0'</span> || value === <span class=\"string\">'false'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> defaultValue</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setBoolean</span>(<span class=\"params\">key: <span class=\"built_in\">string</span>, value: <span class=\"built_in\">boolean</span></span>) </span>&#123;</span><br><span class=\"line\">  localStorage.setItem(key, value ? <span class=\"string\">'1'</span> : <span class=\"string\">'0'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/desktop/desktop/blob/development/app/src/lib/local-storage.ts\" target=\"_blank\" rel=\"noopener\">详见</a></p>\n<h3 id=\"状态管理\"><a href=\"#状态管理\" class=\"headerlink\" title=\"状态管理\"></a>状态管理</h3><p>Desktop 没有使用目前前端开发中常见的 <code>Redux</code>，<code>Mobx</code> 等状态管理库。</p>\n<p>这些状态管理库的数据流差不多可以用下面的表示</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">view(store binded) =&gt; action dispatced =&gt; change the store =&gt; react to all views</span><br></pre></td></tr></table></figure>\n<p>Desktop 同这些方案类似，只是最后一步不一样，它的 Store 基于事件机制 EventEmitter. 和上述自动更新不同的是在更新了 store 之后，需要手动调用 <code>emitUpdate</code> 方法，这个方法触发了 <code>did-update</code> 事件, 也就是调用了 <code>appStore.onDidUpdate</code> 方法的回调。在 <code>app.tsx</code> 初始化的时候，已经绑定了 <code>appStore.onDidUpdate</code> 的回调是触发 React 视图的 <code>setState</code>。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">props.appStore.onDidUpdate(<span class=\"function\"><span class=\"params\">state</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(state)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这样就实行了修改 store 之后，更新所有视图的操作。</p>\n<p>那这里有一个疑问，高频率 store 更新，高频率的调用 <code>emitUpdate</code> 岂不是会带来性能问题，这里 Desktop 做了一个优化是，开启了一个队列，只会在浏览器的每一帧绘制的时候才会使用最新的 state 去执行真正的更新视图 <code>emitUpdateNow</code> 方法。将高频率的 <code>emitUpdate</code> 调用给节流了。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> emitUpdate() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.windowState === <span class=\"string\">'hidden'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.emitUpdateNow()</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.emitQueued) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.emitQueued = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">window</span>.requestAnimationFrame(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.emitUpdateNow()</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> emitUpdateNow() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.emitQueued = <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> state = <span class=\"keyword\">this</span>.getState()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">super</span>.emitUpdate(state)</span><br><span class=\"line\">    updateMenuState(state, <span class=\"keyword\">this</span>.appMenu)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此外，appStore 还集中管理了所有子 store, 当这些 store 更新的时候触发了 appStore 的 <code>emitUpdate</code>。</p>\n<h2 id=\"Menu\"><a href=\"#Menu\" class=\"headerlink\" title=\"Menu\"></a>Menu</h2><h3 id=\"Context-Menu\"><a href=\"#Context-Menu\" class=\"headerlink\" title=\"Context-Menu\"></a>Context-Menu</h3><p>Desktop 的 contextmenu 的实现基于原生 IPC 的，比较绕。</p>\n<p>首先我们需要知道的是 Menu 类是 main process only 的。</p>\n<p>在需要 contextmenu 的 JSX.Element 上绑定 <code>onContextMenu</code> 事件。构造对象数组 Array<menuitem>, 并且为每个 MenuItem 对象绑定触发事件，再通过 IPC 将对象传递至 main 进程，值得一提的是这个时候将 MenuItem 数组赋值给了一个全局对象，暂存起来。在 main 进程构造出真正的 MenuItem 实例，绑定 MenuItem 的点击事件，触发 MenuItem 点击事件的时候记录 MenuItem 的 序列号 index，再将 index 通过 event.sender.send 将 index 传递到 renderer 进程。renderer 进程拿到 index 之后根据之前保存的全局对象取出单个 MenuItem， 执行绑定的事件。</menuitem></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onContextMenu =&gt; showContextualMenu (暂存MenuItems，ipcRenderer.send) =&gt; icpMain =&gt; menu.popup() =&gt; MenuItem.onClick(index) =&gt; event.sernder.send(index) =&gt; MenuItem.action()</span><br></pre></td></tr></table></figure>\n<p>所以在我的应用中会使用 remote 对象屏蔽上述复杂的 IPC 通信。在 renderer 进程完成 Menu 的构造展示和事件的绑定触发。</p>\n<h2 id=\"日志\"><a href=\"#日志\" class=\"headerlink\" title=\"日志\"></a>日志</h2><p>完善的日志可用于 debug，了解 UI 状态迁移背后的数据变动和流程的正确与否。</p>\n<p>Desktop 的日志基于日志库，<a href=\"https://github.com/winstonjs/winston#readme\" target=\"_blank\" rel=\"noopener\">winston</a>。</p>\n<p>在 main 进程和 renderer 进程都提供了全局 log 对象，接口都是一致的。分别是 <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code>。在 render 进程，简单的封装了 <code>window.console</code> 对象上的 <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code> 方法，日志打印到控制台的时候通过 IPC 传递到 main 进程，由 main 进程统一管理。 </p>\n<p>main 进程接收了来自 renderer 进程的日志信息和 main 进程自身的日志信息。设置了两个 <code>transports</code>。<code>winston.transports.Console</code> 和 <code>winston.transports.DailyRotateFile</code> 分别用于将日志信息打印在控制台和存储在磁盘文件。DailyRotateFile 以天为单位，设置了最多存储 14 天的上限。</p>\n<p>在 main 进程和 renderer 进程启动时分别引入日志安装模块。因为 log 方法都是暴露在全局，因此只需要引入一次即可。在 TS 环境中还需要添加 log 方法的类型声明。</p>\n<p><a href=\"https://github.com/desktop/desktop/tree/development/app/src/lib/logging\" target=\"_blank\" rel=\"noopener\">详见</a></p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"组件文件命名及模块\"><a href=\"#组件文件命名及模块\" class=\"headerlink\" title=\"组件文件命名及模块\"></a>组件文件命名及模块</h3><p>首先需要推荐的的是任何文件命名都以<code>kebab-case</code>的方式。</p>\n<p>然后在导出一个组件时，如下几种方案我们应该采取哪一种呢</p>\n<ol>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|__button</span><br><span class=\"line\">|___index.tsx # `export &#123; default as button &#125; from &apos;./button&apos;`</span><br><span class=\"line\">|___button.tsx # `export default class Button extends React.Component&#123;&#125;`</span><br></pre></td></tr></table></figure>\n</li>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|__button</span><br><span class=\"line\">|___index.tsx # `export default class Button extends React.Component&#123;&#125;`</span><br></pre></td></tr></table></figure>\n</li>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|__button</span><br><span class=\"line\">|___button.tsx # `export default class Button extends React.Component&#123;&#125;`</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>Desktop 采用的第一种方式。这种方式</p>\n<h3 id=\"CSS-目录结构\"><a href=\"#CSS-目录结构\" class=\"headerlink\" title=\"CSS 目录结构\"></a>CSS 目录结构</h3><p>尽量一个组件一个样式文件，便于维护更新。</p>\n"},{"title":"Typescript 高阶类型","date":"2019-06-19T07:10:42.000Z","_content":"\n大部分示例和教程来自优秀的 [A. Sharif](https://dev.to/busypeoples) 的系列文章 \n\n## 泛型 和 extends\n\n```ts\nfunction prop(obj, key) {\n  return obj[key]\n}\n```\n\n这样一个函数如何让其类型安全呢？\n\n```ts\nfunction prop<T, Key extends keyof T>(obj: T, key: Key) {\n  return obj[key];\n}\n\nconst user: User = {\n  id: 1,\n  name: \"Test User\",\n  points: 0\n};\n\nconst userName = prop(user, \"name\"); // const userName : string;\n```\n\n需要像这样使用到泛型，因为我们不知道这个 obj 的类型定义是怎样的，所以我们需要使用 T 来作为 obj 的定义的占位，T 是第一个泛型参数。Key 是第二个泛型参数，它 extends 自 T 的所有 key 值，Key 在这里就是 `\"id\" | \"name\" | \"points\"` 的所有子集。\n\n在使用的时候我们可以不用显式的传入泛型参数，因为我们给函数传参的时候，TS 编译器就已经帮我们推到出来正确的泛型参数了，并且验证了第二个参数的类型必须是 extends 自 T 的所有 key 值。这就为我们提供了鲁棒性非常的类型安全的函数了，还有自动补全的功能哦。\n\n##  Conditional Types\n\n条件类型自 Typescript 2.8 引入。 它的定义是\n\n> \"A conditional type selects one of two possible types based on a condition expressed as a type relationship test\"\n\n```ts\ntype S = string extends any ? \"string\" : never;\n\n/*\ntype S = \"string\"\n*/\n```\n\n这个三元操作符的解释是如果 `string` 类型 extends 自 `any` 类型，（答案是明显的YES）。那么类型 S 的定义就是 `string`，否则就是 `never`。\n\n常见的应用就是标准库中 `Exclude` 的定义。\n\n```ts\n/**\n * Exclude from T those types that are assignable to U\n */\ntype Exclude<T, U> = T extends U ? never : T;\n```\n\n`Exclude`可用于两个联合类型之间取差集。\n\n\n\n## Pick、Exclude 和 Omit\n\n在 `lodash` 库中有两个实用的方法，`pick` 和 `omit`. \n\n```js\nvar object = { 'a': 1, 'b': '2', 'c': 3 };\n \n_.pick(object, ['a', 'c']);\n// => { 'a': 1, 'c': 3 }\n```\n\n`pick` 用于由选取的对象属性组成新的对象。\n\n```js\nvar object = { 'a': 1, 'b': '2', 'c': 3 };\n \n_.omit(object, ['a', 'c']);\n// => { 'b': '2' }\n```\n`omit` 的释义是消除。与 `pick` 相反; 此方法创建一个对象，消除指定的属性，剩下的对象属性组成一个新的对象。\n\n\n### Pick\n\n在 Typescript 中也有类似的概念。只不过被操作的对象不是对象字面量，而是类型.\n\nPick 在 Typescript 的标准库中的定义是\n\n```ts\ntype Pick<T, K extends keyof T> = { \n    [P in K]: T[P];\n}\n```\n\n可以看出 Pick 也是一种类型，可用于创造新的类型。这个新的类型的 key 值为泛型 T 的所有 key 值的联合类型的子集。\n\n\n```ts\ninterface Person {\n    name: string;\n    age: number;\n    location: string;\n}\ntype PersonWithouLocation = Pick<Person, 'name' | 'age'>\n// => type PersonWithouLocation = {\n//     name: string;\n//     age: number;\n// }\n```\n\n那如何为 `_.pick` 加上类型呢？\n\n```ts\ndeclare function pick<T extends object, K extends keyof T>(object: T, paths?: K[]): Pick<T, K>\n\nvar object = { 'a': 1, 'b': '2', 'c': 3 };\nconst result = pick(object, ['a', 'c']); \n// const result: Pick<{\n//     'a': number;\n//     'b': string;\n//     'c': number;\n// }, \"a\" | \"b\">\n```\n使用泛型和 `Pick` ,我们就得到了一个类型安全的 `pick` 方法\n\n\n### Omit\n\n在 Typescript 3.5 版本才引入 `Omit` 类型。\n\n`Omit` 作为 `Pick` 的反操作，我们想得到和上面 Pick 相同的操作只需要对类型的键值取反即可。\n\n```ts\ninterface Person {\n    name: string;\n    age: number;\n    location: string;\n}\ntype PersonWithouLocation = Omit<Person, 'location'>\n// 结果是\n// type PersonWithouLocation = {\n//     name: string;\n//     age: number;\n// }\n```\n\nOmit 在标准库中的定义是\n\n```ts\n/**\n * Construct a type with the properties of T except for those in type K.\n */\ntype Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;\n```\n\nOmit 实现中的第二个泛型参数为什么不是 `K extends keyof T`，而是使用的 `K extends keyof any`呢？这样 IDE 就不能在第二个参数帮助补全了，这是我的一个疑问。在 Stack Overflow 上有找到 key 值可能是 `string | number | symbol` 三种类型。\n\n让我们看看 Omit 的实现，就是 Pick 出 T 中 keyof T 和 K 的差集组成新的类型。也就是说消除了第二个参数中为键值的类型组成新的类型。\n\n那如何为 `_.omit` 加上类型呢？\n\n```ts\ndeclare function omit<T extends object, K extends keyof T>(object: T, paths: K[]): Omit<T, K>\n\nconst result = omit(object, ['a', 'b']); \n// const result: Pick<{\n//     'a': number;\n//     'b': string;\n//     'c': number;\n// }, \"c\">\n```\n\n扩展一下，也许某些时候 `omit` 方法的第二个参数可能是扩展运算符。例如\n\n```js\nfunction omit(object, ...rest) {\n    // do omit\n}\nomit(object, 'a', 'b')\n```\n\n那这个时候的类型定义应该是这样\n\n```ts\ndeclare function omit<T extends object, K extends keyof T>(object: T, ...paths: K[]): Omit<T, K>\n```\n\n\n\n\n\n\n## infer\ninfer 是 TS 的一个关键字，用于显式类型推断。与之相关的常见的两个类型就是 `ReturnType` 和 `Parameters`\n\n```ts\nfunction getInt(a: string) {\n  return parseInt(a);\n}\n\ntype A = ReturnType<typeof getInt>; // => number\n```\n\n再这个例子中，我们先需要使用 `typeof` 关键字获取函数的类型定义，也就是 `(a: string) => number`, 然后再将其作为泛型参数传入 `ReturnType`。这样就能从一个函数声明得到它的返回类型，这可以在写代码的时候减少我们一些心智负担，能够非常灵活的获取类型。\n\n`ReturnType` 在标准库中的实现是 \n\n```ts\ntype ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;\n```\n\n对这个实现的解释是，如果类型 T 是扩展自函数类型，那么返回值就是 infer 关键字推断出的 R 类型，如果不是，就返回 `any` 类型。\n\n根据这个实现我们还能实现一个高阶类型用于推断函数参数。\n\n```ts\ntype ParametersType<T> = T extends (...args: infer K) => any ? K : any;\n```\n\n使用这个类型推断出的类型是参数元组类型。\n\n其实这个类型在标准库中的的实现是这样的，只不过这个标准库实现了限定了泛型入参的类型必须为函数类型。\n\n```ts\n/**\n * Obtain the parameters of a function type in a tuple\n */\ntype Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never;\n```\n\n`lib.es5.d.ts` 中还实现了很多类似的高阶类型。可参考 [官网](https://www.typescriptlang.org/docs/handbook/utility-types.html)\n\n## Mapped types 映射类型\n\n常见的 Mapped types 都很简单, 可以简单过一下\n\n### Readonly\n\n假设我们有如下类型。\n\n```ts\ntype User = {\n  readonly id: number;\n  name: string;\n}\n```\n\n```ts\ntype Readonly<Type> = {readonly [key in keyof Type ]: Type[key]};\ntype ReadonlyUser =  Readonly<User>;\n```\n\n`Readonly` 的实现就是让泛型的每一个 key 都用 `readonly` 关键字标注，这样就能得到每一个 key 都是 readonly 只读的类型了。\n\n### Partial\n\n```ts\n/**\n * Make all properties in T optional\n */\ntype Partial<T> = {\n    [P in keyof T]?: T[P];\n};\n```\n\n同理使用 `?` 让每一个 key 都可选。\n\n```ts\ntype BlogPost = {\n  id: number;\n  title: string;\n  description?: string;\n}\n\ntype PartialBlogPost = Partial<BlogPost>;\n/*\n=> type PartialBlogPost {\n  id?: number | undefined;\n  title?: string / undefined;\n  description?: string / undefined;\n}\n*/\n```\n\n### Required\n\n```ts\n/**\n * Make all properties in T required\n */\ntype Required<T> = {\n    [P in keyof T]-?: T[P];\n};\n```\n\n`Required` 类型和上两个差不多，需要注意的是 `-` 这个修饰符，它意味着去除后面的可选修饰符 `?`, 那就是每一个 key 都是必需。同理也存在 `+` 修饰符。\n\n```ts\ntype BlogPost = {\n  id: number;\n  title: string;\n  description?: string;\n}\n\ntype RequiredBlogPost = Required<BlogPost>;\n/*\n=> type RequiredBlogPost {\n  id: number;\n  title: string;\n  description: string;\n}\n*/\n```\n\n### Record\n\n在刚开始学习 TS 的时候，`Record` 的实现和使用场景让我比较困惑。\n\n```ts\n/**\n * Construct a type with a set of properties K of type T\n */\ntype Record<K extends keyof any, T> = {\n    [P in K]: T;\n};\n```\n\n```ts\ntype ExportFormat = \"jsonMiniDiary\" | \"md\" | \"pdf\" | \"txtDayOne\";\nconst fileExtensions: Record<ExportFormat, string> = {\n\tjsonMiniDiary: \"json\",\n\tmd: \"md\",\n\tpdf: \"pdf\",\n\ttxtDayOne: \"txt\",\n};\n```\n\n这是一段来自 real world 的代码。通过这段代码，能看到 `Record` 能够帮助我们获得类型安全的对象声明。","source":"_posts/typescript-advanced-type.md","raw":"---\ntitle: Typescript 高阶类型\ndate: 2019-06-19 15:10:42\ntags:\n---\n\n大部分示例和教程来自优秀的 [A. Sharif](https://dev.to/busypeoples) 的系列文章 \n\n## 泛型 和 extends\n\n```ts\nfunction prop(obj, key) {\n  return obj[key]\n}\n```\n\n这样一个函数如何让其类型安全呢？\n\n```ts\nfunction prop<T, Key extends keyof T>(obj: T, key: Key) {\n  return obj[key];\n}\n\nconst user: User = {\n  id: 1,\n  name: \"Test User\",\n  points: 0\n};\n\nconst userName = prop(user, \"name\"); // const userName : string;\n```\n\n需要像这样使用到泛型，因为我们不知道这个 obj 的类型定义是怎样的，所以我们需要使用 T 来作为 obj 的定义的占位，T 是第一个泛型参数。Key 是第二个泛型参数，它 extends 自 T 的所有 key 值，Key 在这里就是 `\"id\" | \"name\" | \"points\"` 的所有子集。\n\n在使用的时候我们可以不用显式的传入泛型参数，因为我们给函数传参的时候，TS 编译器就已经帮我们推到出来正确的泛型参数了，并且验证了第二个参数的类型必须是 extends 自 T 的所有 key 值。这就为我们提供了鲁棒性非常的类型安全的函数了，还有自动补全的功能哦。\n\n##  Conditional Types\n\n条件类型自 Typescript 2.8 引入。 它的定义是\n\n> \"A conditional type selects one of two possible types based on a condition expressed as a type relationship test\"\n\n```ts\ntype S = string extends any ? \"string\" : never;\n\n/*\ntype S = \"string\"\n*/\n```\n\n这个三元操作符的解释是如果 `string` 类型 extends 自 `any` 类型，（答案是明显的YES）。那么类型 S 的定义就是 `string`，否则就是 `never`。\n\n常见的应用就是标准库中 `Exclude` 的定义。\n\n```ts\n/**\n * Exclude from T those types that are assignable to U\n */\ntype Exclude<T, U> = T extends U ? never : T;\n```\n\n`Exclude`可用于两个联合类型之间取差集。\n\n\n\n## Pick、Exclude 和 Omit\n\n在 `lodash` 库中有两个实用的方法，`pick` 和 `omit`. \n\n```js\nvar object = { 'a': 1, 'b': '2', 'c': 3 };\n \n_.pick(object, ['a', 'c']);\n// => { 'a': 1, 'c': 3 }\n```\n\n`pick` 用于由选取的对象属性组成新的对象。\n\n```js\nvar object = { 'a': 1, 'b': '2', 'c': 3 };\n \n_.omit(object, ['a', 'c']);\n// => { 'b': '2' }\n```\n`omit` 的释义是消除。与 `pick` 相反; 此方法创建一个对象，消除指定的属性，剩下的对象属性组成一个新的对象。\n\n\n### Pick\n\n在 Typescript 中也有类似的概念。只不过被操作的对象不是对象字面量，而是类型.\n\nPick 在 Typescript 的标准库中的定义是\n\n```ts\ntype Pick<T, K extends keyof T> = { \n    [P in K]: T[P];\n}\n```\n\n可以看出 Pick 也是一种类型，可用于创造新的类型。这个新的类型的 key 值为泛型 T 的所有 key 值的联合类型的子集。\n\n\n```ts\ninterface Person {\n    name: string;\n    age: number;\n    location: string;\n}\ntype PersonWithouLocation = Pick<Person, 'name' | 'age'>\n// => type PersonWithouLocation = {\n//     name: string;\n//     age: number;\n// }\n```\n\n那如何为 `_.pick` 加上类型呢？\n\n```ts\ndeclare function pick<T extends object, K extends keyof T>(object: T, paths?: K[]): Pick<T, K>\n\nvar object = { 'a': 1, 'b': '2', 'c': 3 };\nconst result = pick(object, ['a', 'c']); \n// const result: Pick<{\n//     'a': number;\n//     'b': string;\n//     'c': number;\n// }, \"a\" | \"b\">\n```\n使用泛型和 `Pick` ,我们就得到了一个类型安全的 `pick` 方法\n\n\n### Omit\n\n在 Typescript 3.5 版本才引入 `Omit` 类型。\n\n`Omit` 作为 `Pick` 的反操作，我们想得到和上面 Pick 相同的操作只需要对类型的键值取反即可。\n\n```ts\ninterface Person {\n    name: string;\n    age: number;\n    location: string;\n}\ntype PersonWithouLocation = Omit<Person, 'location'>\n// 结果是\n// type PersonWithouLocation = {\n//     name: string;\n//     age: number;\n// }\n```\n\nOmit 在标准库中的定义是\n\n```ts\n/**\n * Construct a type with the properties of T except for those in type K.\n */\ntype Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;\n```\n\nOmit 实现中的第二个泛型参数为什么不是 `K extends keyof T`，而是使用的 `K extends keyof any`呢？这样 IDE 就不能在第二个参数帮助补全了，这是我的一个疑问。在 Stack Overflow 上有找到 key 值可能是 `string | number | symbol` 三种类型。\n\n让我们看看 Omit 的实现，就是 Pick 出 T 中 keyof T 和 K 的差集组成新的类型。也就是说消除了第二个参数中为键值的类型组成新的类型。\n\n那如何为 `_.omit` 加上类型呢？\n\n```ts\ndeclare function omit<T extends object, K extends keyof T>(object: T, paths: K[]): Omit<T, K>\n\nconst result = omit(object, ['a', 'b']); \n// const result: Pick<{\n//     'a': number;\n//     'b': string;\n//     'c': number;\n// }, \"c\">\n```\n\n扩展一下，也许某些时候 `omit` 方法的第二个参数可能是扩展运算符。例如\n\n```js\nfunction omit(object, ...rest) {\n    // do omit\n}\nomit(object, 'a', 'b')\n```\n\n那这个时候的类型定义应该是这样\n\n```ts\ndeclare function omit<T extends object, K extends keyof T>(object: T, ...paths: K[]): Omit<T, K>\n```\n\n\n\n\n\n\n## infer\ninfer 是 TS 的一个关键字，用于显式类型推断。与之相关的常见的两个类型就是 `ReturnType` 和 `Parameters`\n\n```ts\nfunction getInt(a: string) {\n  return parseInt(a);\n}\n\ntype A = ReturnType<typeof getInt>; // => number\n```\n\n再这个例子中，我们先需要使用 `typeof` 关键字获取函数的类型定义，也就是 `(a: string) => number`, 然后再将其作为泛型参数传入 `ReturnType`。这样就能从一个函数声明得到它的返回类型，这可以在写代码的时候减少我们一些心智负担，能够非常灵活的获取类型。\n\n`ReturnType` 在标准库中的实现是 \n\n```ts\ntype ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;\n```\n\n对这个实现的解释是，如果类型 T 是扩展自函数类型，那么返回值就是 infer 关键字推断出的 R 类型，如果不是，就返回 `any` 类型。\n\n根据这个实现我们还能实现一个高阶类型用于推断函数参数。\n\n```ts\ntype ParametersType<T> = T extends (...args: infer K) => any ? K : any;\n```\n\n使用这个类型推断出的类型是参数元组类型。\n\n其实这个类型在标准库中的的实现是这样的，只不过这个标准库实现了限定了泛型入参的类型必须为函数类型。\n\n```ts\n/**\n * Obtain the parameters of a function type in a tuple\n */\ntype Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never;\n```\n\n`lib.es5.d.ts` 中还实现了很多类似的高阶类型。可参考 [官网](https://www.typescriptlang.org/docs/handbook/utility-types.html)\n\n## Mapped types 映射类型\n\n常见的 Mapped types 都很简单, 可以简单过一下\n\n### Readonly\n\n假设我们有如下类型。\n\n```ts\ntype User = {\n  readonly id: number;\n  name: string;\n}\n```\n\n```ts\ntype Readonly<Type> = {readonly [key in keyof Type ]: Type[key]};\ntype ReadonlyUser =  Readonly<User>;\n```\n\n`Readonly` 的实现就是让泛型的每一个 key 都用 `readonly` 关键字标注，这样就能得到每一个 key 都是 readonly 只读的类型了。\n\n### Partial\n\n```ts\n/**\n * Make all properties in T optional\n */\ntype Partial<T> = {\n    [P in keyof T]?: T[P];\n};\n```\n\n同理使用 `?` 让每一个 key 都可选。\n\n```ts\ntype BlogPost = {\n  id: number;\n  title: string;\n  description?: string;\n}\n\ntype PartialBlogPost = Partial<BlogPost>;\n/*\n=> type PartialBlogPost {\n  id?: number | undefined;\n  title?: string / undefined;\n  description?: string / undefined;\n}\n*/\n```\n\n### Required\n\n```ts\n/**\n * Make all properties in T required\n */\ntype Required<T> = {\n    [P in keyof T]-?: T[P];\n};\n```\n\n`Required` 类型和上两个差不多，需要注意的是 `-` 这个修饰符，它意味着去除后面的可选修饰符 `?`, 那就是每一个 key 都是必需。同理也存在 `+` 修饰符。\n\n```ts\ntype BlogPost = {\n  id: number;\n  title: string;\n  description?: string;\n}\n\ntype RequiredBlogPost = Required<BlogPost>;\n/*\n=> type RequiredBlogPost {\n  id: number;\n  title: string;\n  description: string;\n}\n*/\n```\n\n### Record\n\n在刚开始学习 TS 的时候，`Record` 的实现和使用场景让我比较困惑。\n\n```ts\n/**\n * Construct a type with a set of properties K of type T\n */\ntype Record<K extends keyof any, T> = {\n    [P in K]: T;\n};\n```\n\n```ts\ntype ExportFormat = \"jsonMiniDiary\" | \"md\" | \"pdf\" | \"txtDayOne\";\nconst fileExtensions: Record<ExportFormat, string> = {\n\tjsonMiniDiary: \"json\",\n\tmd: \"md\",\n\tpdf: \"pdf\",\n\ttxtDayOne: \"txt\",\n};\n```\n\n这是一段来自 real world 的代码。通过这段代码，能看到 `Record` 能够帮助我们获得类型安全的对象声明。","slug":"typescript-advanced-type","published":1,"updated":"2019-07-19T01:53:42.606Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhpu92wy0005ak87koqz2yxo","content":"<p>大部分示例和教程来自优秀的 <a href=\"https://dev.to/busypeoples\" target=\"_blank\" rel=\"noopener\">A. Sharif</a> 的系列文章 </p>\n<h2 id=\"泛型-和-extends\"><a href=\"#泛型-和-extends\" class=\"headerlink\" title=\"泛型 和 extends\"></a>泛型 和 extends</h2><figure class=\"highlight ts\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">prop</span>(<span class=\"params\">obj, key</span>) </span>{</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj[key]</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>这样一个函数如何让其类型安全呢？</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">prop</span><<span class=\"title\">T</span>, <span class=\"title\">Key</span> <span class=\"title\">extends</span> <span class=\"title\">keyof</span> <span class=\"title\">T</span>>(<span class=\"params\">obj: T, key: Key</span>) </span>{</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj[key];</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> user: User = {</span><br><span class=\"line\">  id: <span class=\"number\">1</span>,</span><br><span class=\"line\">  name: <span class=\"string\">\"Test User\"</span>,</span><br><span class=\"line\">  points: <span class=\"number\">0</span></span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> userName = prop(user, <span class=\"string\">\"name\"</span>); <span class=\"comment\">// const userName : string;</span></span><br></pre></td></tr></tbody></table></figure>\n<p>需要像这样使用到泛型，因为我们不知道这个 obj 的类型定义是怎样的，所以我们需要使用 T 来作为 obj 的定义的占位，T 是第一个泛型参数。Key 是第二个泛型参数，它 extends 自 T 的所有 key 值，Key 在这里就是 <code>\"id\" | \"name\" | \"points\"</code> 的所有子集。</p>\n<p>在使用的时候我们可以不用显式的传入泛型参数，因为我们给函数传参的时候，TS 编译器就已经帮我们推到出来正确的泛型参数了，并且验证了第二个参数的类型必须是 extends 自 T 的所有 key 值。这就为我们提供了鲁棒性非常的类型安全的函数了，还有自动补全的功能哦。</p>\n<h2 id=\"Conditional-Types\"><a href=\"#Conditional-Types\" class=\"headerlink\" title=\"Conditional Types\"></a>Conditional Types</h2><p>条件类型自 Typescript 2.8 引入。 它的定义是</p>\n<blockquote>\n<p>“A conditional type selects one of two possible types based on a condition expressed as a type relationship test”</p>\n</blockquote>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> S = <span class=\"built_in\">string</span> <span class=\"keyword\">extends</span> <span class=\"built_in\">any</span> ? <span class=\"string\">\"string\"</span> : never;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">type S = \"string\"</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></tbody></table></figure>\n<p>这个三元操作符的解释是如果 <code>string</code> 类型 extends 自 <code>any</code> 类型，（答案是明显的YES）。那么类型 S 的定义就是 <code>string</code>，否则就是 <code>never</code>。</p>\n<p>常见的应用就是标准库中 <code>Exclude</code> 的定义。</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Exclude from T those types that are assignable to U</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Exclude<T, U> = T <span class=\"keyword\">extends</span> U ? never : T;</span><br></pre></td></tr></tbody></table></figure>\n<p><code>Exclude</code>可用于两个联合类型之间取差集。</p>\n<h2 id=\"Pick、Exclude-和-Omit\"><a href=\"#Pick、Exclude-和-Omit\" class=\"headerlink\" title=\"Pick、Exclude 和 Omit\"></a>Pick、Exclude 和 Omit</h2><p>在 <code>lodash</code> 库中有两个实用的方法，<code>pick</code> 和 <code>omit</code>. </p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> object = { <span class=\"string\">'a'</span>: <span class=\"number\">1</span>, <span class=\"string\">'b'</span>: <span class=\"string\">'2'</span>, <span class=\"string\">'c'</span>: <span class=\"number\">3</span> };</span><br><span class=\"line\"> </span><br><span class=\"line\">_.pick(object, [<span class=\"string\">'a'</span>, <span class=\"string\">'c'</span>]);</span><br><span class=\"line\"><span class=\"comment\">// => { 'a': 1, 'c': 3 }</span></span><br></pre></td></tr></tbody></table></figure>\n<p><code>pick</code> 用于由选取的对象属性组成新的对象。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> object = { <span class=\"string\">'a'</span>: <span class=\"number\">1</span>, <span class=\"string\">'b'</span>: <span class=\"string\">'2'</span>, <span class=\"string\">'c'</span>: <span class=\"number\">3</span> };</span><br><span class=\"line\"> </span><br><span class=\"line\">_.omit(object, [<span class=\"string\">'a'</span>, <span class=\"string\">'c'</span>]);</span><br><span class=\"line\"><span class=\"comment\">// => { 'b': '2' }</span></span><br></pre></td></tr></tbody></table></figure>\n<p><code>omit</code> 的释义是消除。与 <code>pick</code> 相反; 此方法创建一个对象，消除指定的属性，剩下的对象属性组成一个新的对象。</p>\n<h3 id=\"Pick\"><a href=\"#Pick\" class=\"headerlink\" title=\"Pick\"></a>Pick</h3><p>在 Typescript 中也有类似的概念。只不过被操作的对象不是对象字面量，而是类型.</p>\n<p>Pick 在 Typescript 的标准库中的定义是</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Pick<T, K <span class=\"keyword\">extends</span> keyof T> = { </span><br><span class=\"line\">    [P <span class=\"keyword\">in</span> K]: T[P];</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>可以看出 Pick 也是一种类型，可用于创造新的类型。这个新的类型的 key 值为泛型 T 的所有 key 值的联合类型的子集。</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Person {</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    age: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    location: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">type</span> PersonWithouLocation = Pick<Person, <span class=\"string\">'name'</span> | <span class=\"string\">'age'</span>></span><br><span class=\"line\"><span class=\"comment\">// => type PersonWithouLocation = {</span></span><br><span class=\"line\"><span class=\"comment\">//     name: string;</span></span><br><span class=\"line\"><span class=\"comment\">//     age: number;</span></span><br><span class=\"line\"><span class=\"comment\">// }</span></span><br></pre></td></tr></tbody></table></figure>\n<p>那如何为 <code>_.pick</code> 加上类型呢？</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pick</span><<span class=\"title\">T</span> <span class=\"title\">extends</span> <span class=\"title\">object</span>, <span class=\"title\">K</span> <span class=\"title\">extends</span> <span class=\"title\">keyof</span> <span class=\"title\">T</span>>(<span class=\"params\">object: T, paths?: K[]</span>): <span class=\"title\">Pick</span><<span class=\"title\">T</span>, <span class=\"title\">K</span>></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">var</span> <span class=\"title\">object</span> = </span>{ <span class=\"string\">'a'</span>: <span class=\"number\">1</span>, <span class=\"string\">'b'</span>: <span class=\"string\">'2'</span>, <span class=\"string\">'c'</span>: <span class=\"number\">3</span> };</span><br><span class=\"line\"><span class=\"keyword\">const</span> result = pick(object, [<span class=\"string\">'a'</span>, <span class=\"string\">'c'</span>]); </span><br><span class=\"line\"><span class=\"comment\">// const result: Pick<{</span></span><br><span class=\"line\"><span class=\"comment\">//     'a': number;</span></span><br><span class=\"line\"><span class=\"comment\">//     'b': string;</span></span><br><span class=\"line\"><span class=\"comment\">//     'c': number;</span></span><br><span class=\"line\"><span class=\"comment\">// }, \"a\" | \"b\"></span></span><br></pre></td></tr></tbody></table></figure>\n<p>使用泛型和 <code>Pick</code> ,我们就得到了一个类型安全的 <code>pick</code> 方法</p>\n<h3 id=\"Omit\"><a href=\"#Omit\" class=\"headerlink\" title=\"Omit\"></a>Omit</h3><p>在 Typescript 3.5 版本才引入 <code>Omit</code> 类型。</p>\n<p><code>Omit</code> 作为 <code>Pick</code> 的反操作，我们想得到和上面 Pick 相同的操作只需要对类型的键值取反即可。</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Person {</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    age: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    location: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">type</span> PersonWithouLocation = Omit<Person, <span class=\"string\">'location'</span>></span><br><span class=\"line\"><span class=\"comment\">// 结果是</span></span><br><span class=\"line\"><span class=\"comment\">// type PersonWithouLocation = {</span></span><br><span class=\"line\"><span class=\"comment\">//     name: string;</span></span><br><span class=\"line\"><span class=\"comment\">//     age: number;</span></span><br><span class=\"line\"><span class=\"comment\">// }</span></span><br></pre></td></tr></tbody></table></figure>\n<p>Omit 在标准库中的定义是</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Construct a type with the properties of T except for those in type K.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Omit<T, K <span class=\"keyword\">extends</span> keyof <span class=\"built_in\">any</span>> = Pick<T, Exclude<keyof T, K>>;</span><br></pre></td></tr></tbody></table></figure>\n<p>Omit 实现中的第二个泛型参数为什么不是 <code>K extends keyof T</code>，而是使用的 <code>K extends keyof any</code>呢？这样 IDE 就不能在第二个参数帮助补全了，这是我的一个疑问。在 Stack Overflow 上有找到 key 值可能是 <code>string | number | symbol</code> 三种类型。</p>\n<p>让我们看看 Omit 的实现，就是 Pick 出 T 中 keyof T 和 K 的差集组成新的类型。也就是说消除了第二个参数中为键值的类型组成新的类型。</p>\n<p>那如何为 <code>_.omit</code> 加上类型呢？</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">omit</span><<span class=\"title\">T</span> <span class=\"title\">extends</span> <span class=\"title\">object</span>, <span class=\"title\">K</span> <span class=\"title\">extends</span> <span class=\"title\">keyof</span> <span class=\"title\">T</span>>(<span class=\"params\">object: T, paths: K[]</span>): <span class=\"title\">Omit</span><<span class=\"title\">T</span>, <span class=\"title\">K</span>></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">const</span> <span class=\"title\">result</span> = <span class=\"title\">omit</span>(<span class=\"params\">object, ['a', 'b']</span>)</span>; </span><br><span class=\"line\"><span class=\"comment\">// const result: Pick<{</span></span><br><span class=\"line\"><span class=\"comment\">//     'a': number;</span></span><br><span class=\"line\"><span class=\"comment\">//     'b': string;</span></span><br><span class=\"line\"><span class=\"comment\">//     'c': number;</span></span><br><span class=\"line\"><span class=\"comment\">// }, \"c\"></span></span><br></pre></td></tr></tbody></table></figure>\n<p>扩展一下，也许某些时候 <code>omit</code> 方法的第二个参数可能是扩展运算符。例如</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">omit</span>(<span class=\"params\">object, ...rest</span>) </span>{</span><br><span class=\"line\">    <span class=\"comment\">// do omit</span></span><br><span class=\"line\">}</span><br><span class=\"line\">omit(object, <span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>)</span><br></pre></td></tr></tbody></table></figure>\n<p>那这个时候的类型定义应该是这样</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">omit</span><<span class=\"title\">T</span> <span class=\"title\">extends</span> <span class=\"title\">object</span>, <span class=\"title\">K</span> <span class=\"title\">extends</span> <span class=\"title\">keyof</span> <span class=\"title\">T</span>>(<span class=\"params\">object: T, ...paths: K[]</span>): <span class=\"title\">Omit</span><<span class=\"title\">T</span>, <span class=\"title\">K</span>></span></span><br></pre></td></tr></tbody></table></figure>\n<h2 id=\"infer\"><a href=\"#infer\" class=\"headerlink\" title=\"infer\"></a>infer</h2><p>infer 是 TS 的一个关键字，用于显式类型推断。与之相关的常见的两个类型就是 <code>ReturnType</code> 和 <code>Parameters</code></p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getInt</span>(<span class=\"params\">a: <span class=\"built_in\">string</span></span>) </span>{</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">parseInt</span>(a);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> A = ReturnType<<span class=\"keyword\">typeof</span> getInt>; <span class=\"comment\">// => number</span></span><br></pre></td></tr></tbody></table></figure>\n<p>再这个例子中，我们先需要使用 <code>typeof</code> 关键字获取函数的类型定义，也就是 <code>(a: string) => number</code>, 然后再将其作为泛型参数传入 <code>ReturnType</code>。这样就能从一个函数声明得到它的返回类型，这可以在写代码的时候减少我们一些心智负担，能够非常灵活的获取类型。</p>\n<p><code>ReturnType</code> 在标准库中的实现是 </p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ReturnType<T> = T <span class=\"keyword\">extends</span> (...args: <span class=\"built_in\">any</span>[]) => infer R ? R : <span class=\"built_in\">any</span>;</span><br></pre></td></tr></tbody></table></figure>\n<p>对这个实现的解释是，如果类型 T 是扩展自函数类型，那么返回值就是 infer 关键字推断出的 R 类型，如果不是，就返回 <code>any</code> 类型。</p>\n<p>根据这个实现我们还能实现一个高阶类型用于推断函数参数。</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ParametersType<T> = T <span class=\"keyword\">extends</span> (...args: infer K) => <span class=\"built_in\">any</span> ? K : <span class=\"built_in\">any</span>;</span><br></pre></td></tr></tbody></table></figure>\n<p>使用这个类型推断出的类型是参数元组类型。</p>\n<p>其实这个类型在标准库中的的实现是这样的，只不过这个标准库实现了限定了泛型入参的类型必须为函数类型。</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Obtain the parameters of a function type in a tuple</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Parameters<T <span class=\"keyword\">extends</span> (...args: <span class=\"built_in\">any</span>) => <span class=\"built_in\">any</span>> = T <span class=\"keyword\">extends</span> (...args: infer P) => <span class=\"built_in\">any</span> ? P : never;</span><br></pre></td></tr></tbody></table></figure>\n<p><code>lib.es5.d.ts</code> 中还实现了很多类似的高阶类型。可参考 <a href=\"https://www.typescriptlang.org/docs/handbook/utility-types.html\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n<h2 id=\"Mapped-types-映射类型\"><a href=\"#Mapped-types-映射类型\" class=\"headerlink\" title=\"Mapped types 映射类型\"></a>Mapped types 映射类型</h2><p>常见的 Mapped types 都很简单, 可以简单过一下</p>\n<h3 id=\"Readonly\"><a href=\"#Readonly\" class=\"headerlink\" title=\"Readonly\"></a>Readonly</h3><p>假设我们有如下类型。</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> User = {</span><br><span class=\"line\">  readonly id: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Readonly<Type> = {readonly [key <span class=\"keyword\">in</span> keyof Type ]: Type[key]};</span><br><span class=\"line\"><span class=\"keyword\">type</span> ReadonlyUser =  Readonly<User>;</span><br></pre></td></tr></tbody></table></figure>\n<p><code>Readonly</code> 的实现就是让泛型的每一个 key 都用 <code>readonly</code> 关键字标注，这样就能得到每一个 key 都是 readonly 只读的类型了。</p>\n<h3 id=\"Partial\"><a href=\"#Partial\" class=\"headerlink\" title=\"Partial\"></a>Partial</h3><figure class=\"highlight ts\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Make all properties in T optional</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Partial<T> = {</span><br><span class=\"line\">    [P <span class=\"keyword\">in</span> keyof T]?: T[P];</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n<p>同理使用 <code>?</code> 让每一个 key 都可选。</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> BlogPost = {</span><br><span class=\"line\">  id: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  title: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  description?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> PartialBlogPost = Partial<BlogPost>;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">=> type PartialBlogPost {</span></span><br><span class=\"line\"><span class=\"comment\">  id?: number | undefined;</span></span><br><span class=\"line\"><span class=\"comment\">  title?: string / undefined;</span></span><br><span class=\"line\"><span class=\"comment\">  description?: string / undefined;</span></span><br><span class=\"line\"><span class=\"comment\">}</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"Required\"><a href=\"#Required\" class=\"headerlink\" title=\"Required\"></a>Required</h3><figure class=\"highlight ts\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Make all properties in T required</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Required<T> = {</span><br><span class=\"line\">    [P <span class=\"keyword\">in</span> keyof T]-?: T[P];</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n<p><code>Required</code> 类型和上两个差不多，需要注意的是 <code>-</code> 这个修饰符，它意味着去除后面的可选修饰符 <code>?</code>, 那就是每一个 key 都是必需。同理也存在 <code>+</code> 修饰符。</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> BlogPost = {</span><br><span class=\"line\">  id: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  title: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  description?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> RequiredBlogPost = Required<BlogPost>;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">=> type RequiredBlogPost {</span></span><br><span class=\"line\"><span class=\"comment\">  id: number;</span></span><br><span class=\"line\"><span class=\"comment\">  title: string;</span></span><br><span class=\"line\"><span class=\"comment\">  description: string;</span></span><br><span class=\"line\"><span class=\"comment\">}</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"Record\"><a href=\"#Record\" class=\"headerlink\" title=\"Record\"></a>Record</h3><p>在刚开始学习 TS 的时候，<code>Record</code> 的实现和使用场景让我比较困惑。</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Construct a type with a set of properties K of type T</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Record<K <span class=\"keyword\">extends</span> keyof <span class=\"built_in\">any</span>, T> = {</span><br><span class=\"line\">    [P <span class=\"keyword\">in</span> K]: T;</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ExportFormat = <span class=\"string\">\"jsonMiniDiary\"</span> | <span class=\"string\">\"md\"</span> | <span class=\"string\">\"pdf\"</span> | <span class=\"string\">\"txtDayOne\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> fileExtensions: Record<ExportFormat, <span class=\"built_in\">string</span>> = {</span><br><span class=\"line\">\tjsonMiniDiary: <span class=\"string\">\"json\"</span>,</span><br><span class=\"line\">\tmd: <span class=\"string\">\"md\"</span>,</span><br><span class=\"line\">\tpdf: <span class=\"string\">\"pdf\"</span>,</span><br><span class=\"line\">\ttxtDayOne: <span class=\"string\">\"txt\"</span>,</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n<p>这是一段来自 real world 的代码。通过这段代码，能看到 <code>Record</code> 能够帮助我们获得类型安全的对象声明。</p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"excerpt":"","more":"<p>大部分示例和教程来自优秀的 <a href=\"https://dev.to/busypeoples\" target=\"_blank\" rel=\"noopener\">A. Sharif</a> 的系列文章 </p>\n<h2 id=\"泛型-和-extends\"><a href=\"#泛型-和-extends\" class=\"headerlink\" title=\"泛型 和 extends\"></a>泛型 和 extends</h2><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">prop</span>(<span class=\"params\">obj, key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj[key]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样一个函数如何让其类型安全呢？</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">prop</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">Key</span> <span class=\"title\">extends</span> <span class=\"title\">keyof</span> <span class=\"title\">T</span>&gt;(<span class=\"params\">obj: T, key: Key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj[key];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> user: User = &#123;</span><br><span class=\"line\">  id: <span class=\"number\">1</span>,</span><br><span class=\"line\">  name: <span class=\"string\">\"Test User\"</span>,</span><br><span class=\"line\">  points: <span class=\"number\">0</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> userName = prop(user, <span class=\"string\">\"name\"</span>); <span class=\"comment\">// const userName : string;</span></span><br></pre></td></tr></table></figure>\n<p>需要像这样使用到泛型，因为我们不知道这个 obj 的类型定义是怎样的，所以我们需要使用 T 来作为 obj 的定义的占位，T 是第一个泛型参数。Key 是第二个泛型参数，它 extends 自 T 的所有 key 值，Key 在这里就是 <code>&quot;id&quot; | &quot;name&quot; | &quot;points&quot;</code> 的所有子集。</p>\n<p>在使用的时候我们可以不用显式的传入泛型参数，因为我们给函数传参的时候，TS 编译器就已经帮我们推到出来正确的泛型参数了，并且验证了第二个参数的类型必须是 extends 自 T 的所有 key 值。这就为我们提供了鲁棒性非常的类型安全的函数了，还有自动补全的功能哦。</p>\n<h2 id=\"Conditional-Types\"><a href=\"#Conditional-Types\" class=\"headerlink\" title=\"Conditional Types\"></a>Conditional Types</h2><p>条件类型自 Typescript 2.8 引入。 它的定义是</p>\n<blockquote>\n<p>“A conditional type selects one of two possible types based on a condition expressed as a type relationship test”</p>\n</blockquote>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> S = <span class=\"built_in\">string</span> <span class=\"keyword\">extends</span> <span class=\"built_in\">any</span> ? <span class=\"string\">\"string\"</span> : never;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">type S = \"string\"</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>这个三元操作符的解释是如果 <code>string</code> 类型 extends 自 <code>any</code> 类型，（答案是明显的YES）。那么类型 S 的定义就是 <code>string</code>，否则就是 <code>never</code>。</p>\n<p>常见的应用就是标准库中 <code>Exclude</code> 的定义。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Exclude from T those types that are assignable to U</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Exclude&lt;T, U&gt; = T <span class=\"keyword\">extends</span> U ? never : T;</span><br></pre></td></tr></table></figure>\n<p><code>Exclude</code>可用于两个联合类型之间取差集。</p>\n<h2 id=\"Pick、Exclude-和-Omit\"><a href=\"#Pick、Exclude-和-Omit\" class=\"headerlink\" title=\"Pick、Exclude 和 Omit\"></a>Pick、Exclude 和 Omit</h2><p>在 <code>lodash</code> 库中有两个实用的方法，<code>pick</code> 和 <code>omit</code>. </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> object = &#123; <span class=\"string\">'a'</span>: <span class=\"number\">1</span>, <span class=\"string\">'b'</span>: <span class=\"string\">'2'</span>, <span class=\"string\">'c'</span>: <span class=\"number\">3</span> &#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">_.pick(object, [<span class=\"string\">'a'</span>, <span class=\"string\">'c'</span>]);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; &#123; 'a': 1, 'c': 3 &#125;</span></span><br></pre></td></tr></table></figure>\n<p><code>pick</code> 用于由选取的对象属性组成新的对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> object = &#123; <span class=\"string\">'a'</span>: <span class=\"number\">1</span>, <span class=\"string\">'b'</span>: <span class=\"string\">'2'</span>, <span class=\"string\">'c'</span>: <span class=\"number\">3</span> &#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">_.omit(object, [<span class=\"string\">'a'</span>, <span class=\"string\">'c'</span>]);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; &#123; 'b': '2' &#125;</span></span><br></pre></td></tr></table></figure>\n<p><code>omit</code> 的释义是消除。与 <code>pick</code> 相反; 此方法创建一个对象，消除指定的属性，剩下的对象属性组成一个新的对象。</p>\n<h3 id=\"Pick\"><a href=\"#Pick\" class=\"headerlink\" title=\"Pick\"></a>Pick</h3><p>在 Typescript 中也有类似的概念。只不过被操作的对象不是对象字面量，而是类型.</p>\n<p>Pick 在 Typescript 的标准库中的定义是</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Pick&lt;T, K <span class=\"keyword\">extends</span> keyof T&gt; = &#123; </span><br><span class=\"line\">    [P <span class=\"keyword\">in</span> K]: T[P];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出 Pick 也是一种类型，可用于创造新的类型。这个新的类型的 key 值为泛型 T 的所有 key 值的联合类型的子集。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Person &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    age: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    location: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> PersonWithouLocation = Pick&lt;Person, <span class=\"string\">'name'</span> | <span class=\"string\">'age'</span>&gt;</span><br><span class=\"line\"><span class=\"comment\">// =&gt; type PersonWithouLocation = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     name: string;</span></span><br><span class=\"line\"><span class=\"comment\">//     age: number;</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br></pre></td></tr></table></figure>\n<p>那如何为 <code>_.pick</code> 加上类型呢？</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pick</span>&lt;<span class=\"title\">T</span> <span class=\"title\">extends</span> <span class=\"title\">object</span>, <span class=\"title\">K</span> <span class=\"title\">extends</span> <span class=\"title\">keyof</span> <span class=\"title\">T</span>&gt;(<span class=\"params\">object: T, paths?: K[]</span>): <span class=\"title\">Pick</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">K</span>&gt;</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">var</span> <span class=\"title\">object</span> = </span>&#123; <span class=\"string\">'a'</span>: <span class=\"number\">1</span>, <span class=\"string\">'b'</span>: <span class=\"string\">'2'</span>, <span class=\"string\">'c'</span>: <span class=\"number\">3</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> result = pick(object, [<span class=\"string\">'a'</span>, <span class=\"string\">'c'</span>]); </span><br><span class=\"line\"><span class=\"comment\">// const result: Pick&lt;&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     'a': number;</span></span><br><span class=\"line\"><span class=\"comment\">//     'b': string;</span></span><br><span class=\"line\"><span class=\"comment\">//     'c': number;</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;, \"a\" | \"b\"&gt;</span></span><br></pre></td></tr></table></figure>\n<p>使用泛型和 <code>Pick</code> ,我们就得到了一个类型安全的 <code>pick</code> 方法</p>\n<h3 id=\"Omit\"><a href=\"#Omit\" class=\"headerlink\" title=\"Omit\"></a>Omit</h3><p>在 Typescript 3.5 版本才引入 <code>Omit</code> 类型。</p>\n<p><code>Omit</code> 作为 <code>Pick</code> 的反操作，我们想得到和上面 Pick 相同的操作只需要对类型的键值取反即可。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Person &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    age: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    location: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> PersonWithouLocation = Omit&lt;Person, <span class=\"string\">'location'</span>&gt;</span><br><span class=\"line\"><span class=\"comment\">// 结果是</span></span><br><span class=\"line\"><span class=\"comment\">// type PersonWithouLocation = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     name: string;</span></span><br><span class=\"line\"><span class=\"comment\">//     age: number;</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br></pre></td></tr></table></figure>\n<p>Omit 在标准库中的定义是</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Construct a type with the properties of T except for those in type K.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Omit&lt;T, K <span class=\"keyword\">extends</span> keyof <span class=\"built_in\">any</span>&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;</span><br></pre></td></tr></table></figure>\n<p>Omit 实现中的第二个泛型参数为什么不是 <code>K extends keyof T</code>，而是使用的 <code>K extends keyof any</code>呢？这样 IDE 就不能在第二个参数帮助补全了，这是我的一个疑问。在 Stack Overflow 上有找到 key 值可能是 <code>string | number | symbol</code> 三种类型。</p>\n<p>让我们看看 Omit 的实现，就是 Pick 出 T 中 keyof T 和 K 的差集组成新的类型。也就是说消除了第二个参数中为键值的类型组成新的类型。</p>\n<p>那如何为 <code>_.omit</code> 加上类型呢？</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">omit</span>&lt;<span class=\"title\">T</span> <span class=\"title\">extends</span> <span class=\"title\">object</span>, <span class=\"title\">K</span> <span class=\"title\">extends</span> <span class=\"title\">keyof</span> <span class=\"title\">T</span>&gt;(<span class=\"params\">object: T, paths: K[]</span>): <span class=\"title\">Omit</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">K</span>&gt;</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">const</span> <span class=\"title\">result</span> = <span class=\"title\">omit</span>(<span class=\"params\">object, ['a', 'b']</span>)</span>; </span><br><span class=\"line\"><span class=\"comment\">// const result: Pick&lt;&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     'a': number;</span></span><br><span class=\"line\"><span class=\"comment\">//     'b': string;</span></span><br><span class=\"line\"><span class=\"comment\">//     'c': number;</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;, \"c\"&gt;</span></span><br></pre></td></tr></table></figure>\n<p>扩展一下，也许某些时候 <code>omit</code> 方法的第二个参数可能是扩展运算符。例如</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">omit</span>(<span class=\"params\">object, ...rest</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do omit</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">omit(object, <span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>)</span><br></pre></td></tr></table></figure>\n<p>那这个时候的类型定义应该是这样</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">omit</span>&lt;<span class=\"title\">T</span> <span class=\"title\">extends</span> <span class=\"title\">object</span>, <span class=\"title\">K</span> <span class=\"title\">extends</span> <span class=\"title\">keyof</span> <span class=\"title\">T</span>&gt;(<span class=\"params\">object: T, ...paths: K[]</span>): <span class=\"title\">Omit</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">K</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"infer\"><a href=\"#infer\" class=\"headerlink\" title=\"infer\"></a>infer</h2><p>infer 是 TS 的一个关键字，用于显式类型推断。与之相关的常见的两个类型就是 <code>ReturnType</code> 和 <code>Parameters</code></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getInt</span>(<span class=\"params\">a: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">parseInt</span>(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> A = ReturnType&lt;<span class=\"keyword\">typeof</span> getInt&gt;; <span class=\"comment\">// =&gt; number</span></span><br></pre></td></tr></table></figure>\n<p>再这个例子中，我们先需要使用 <code>typeof</code> 关键字获取函数的类型定义，也就是 <code>(a: string) =&gt; number</code>, 然后再将其作为泛型参数传入 <code>ReturnType</code>。这样就能从一个函数声明得到它的返回类型，这可以在写代码的时候减少我们一些心智负担，能够非常灵活的获取类型。</p>\n<p><code>ReturnType</code> 在标准库中的实现是 </p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ReturnType&lt;T&gt; = T <span class=\"keyword\">extends</span> (...args: <span class=\"built_in\">any</span>[]) =&gt; infer R ? R : <span class=\"built_in\">any</span>;</span><br></pre></td></tr></table></figure>\n<p>对这个实现的解释是，如果类型 T 是扩展自函数类型，那么返回值就是 infer 关键字推断出的 R 类型，如果不是，就返回 <code>any</code> 类型。</p>\n<p>根据这个实现我们还能实现一个高阶类型用于推断函数参数。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ParametersType&lt;T&gt; = T <span class=\"keyword\">extends</span> (...args: infer K) =&gt; <span class=\"built_in\">any</span> ? K : <span class=\"built_in\">any</span>;</span><br></pre></td></tr></table></figure>\n<p>使用这个类型推断出的类型是参数元组类型。</p>\n<p>其实这个类型在标准库中的的实现是这样的，只不过这个标准库实现了限定了泛型入参的类型必须为函数类型。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Obtain the parameters of a function type in a tuple</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Parameters&lt;T <span class=\"keyword\">extends</span> (...args: <span class=\"built_in\">any</span>) =&gt; <span class=\"built_in\">any</span>&gt; = T <span class=\"keyword\">extends</span> (...args: infer P) =&gt; <span class=\"built_in\">any</span> ? P : never;</span><br></pre></td></tr></table></figure>\n<p><code>lib.es5.d.ts</code> 中还实现了很多类似的高阶类型。可参考 <a href=\"https://www.typescriptlang.org/docs/handbook/utility-types.html\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n<h2 id=\"Mapped-types-映射类型\"><a href=\"#Mapped-types-映射类型\" class=\"headerlink\" title=\"Mapped types 映射类型\"></a>Mapped types 映射类型</h2><p>常见的 Mapped types 都很简单, 可以简单过一下</p>\n<h3 id=\"Readonly\"><a href=\"#Readonly\" class=\"headerlink\" title=\"Readonly\"></a>Readonly</h3><p>假设我们有如下类型。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> User = &#123;</span><br><span class=\"line\">  readonly id: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Readonly&lt;Type&gt; = &#123;readonly [key <span class=\"keyword\">in</span> keyof Type ]: Type[key]&#125;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> ReadonlyUser =  Readonly&lt;User&gt;;</span><br></pre></td></tr></table></figure>\n<p><code>Readonly</code> 的实现就是让泛型的每一个 key 都用 <code>readonly</code> 关键字标注，这样就能得到每一个 key 都是 readonly 只读的类型了。</p>\n<h3 id=\"Partial\"><a href=\"#Partial\" class=\"headerlink\" title=\"Partial\"></a>Partial</h3><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Make all properties in T optional</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Partial&lt;T&gt; = &#123;</span><br><span class=\"line\">    [P <span class=\"keyword\">in</span> keyof T]?: T[P];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>同理使用 <code>?</code> 让每一个 key 都可选。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> BlogPost = &#123;</span><br><span class=\"line\">  id: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  title: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  description?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> PartialBlogPost = Partial&lt;BlogPost&gt;;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">=&gt; type PartialBlogPost &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  id?: number | undefined;</span></span><br><span class=\"line\"><span class=\"comment\">  title?: string / undefined;</span></span><br><span class=\"line\"><span class=\"comment\">  description?: string / undefined;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Required\"><a href=\"#Required\" class=\"headerlink\" title=\"Required\"></a>Required</h3><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Make all properties in T required</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Required&lt;T&gt; = &#123;</span><br><span class=\"line\">    [P <span class=\"keyword\">in</span> keyof T]-?: T[P];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>Required</code> 类型和上两个差不多，需要注意的是 <code>-</code> 这个修饰符，它意味着去除后面的可选修饰符 <code>?</code>, 那就是每一个 key 都是必需。同理也存在 <code>+</code> 修饰符。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> BlogPost = &#123;</span><br><span class=\"line\">  id: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  title: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  description?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> RequiredBlogPost = Required&lt;BlogPost&gt;;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">=&gt; type RequiredBlogPost &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  id: number;</span></span><br><span class=\"line\"><span class=\"comment\">  title: string;</span></span><br><span class=\"line\"><span class=\"comment\">  description: string;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Record\"><a href=\"#Record\" class=\"headerlink\" title=\"Record\"></a>Record</h3><p>在刚开始学习 TS 的时候，<code>Record</code> 的实现和使用场景让我比较困惑。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Construct a type with a set of properties K of type T</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Record&lt;K <span class=\"keyword\">extends</span> keyof <span class=\"built_in\">any</span>, T&gt; = &#123;</span><br><span class=\"line\">    [P <span class=\"keyword\">in</span> K]: T;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ExportFormat = <span class=\"string\">\"jsonMiniDiary\"</span> | <span class=\"string\">\"md\"</span> | <span class=\"string\">\"pdf\"</span> | <span class=\"string\">\"txtDayOne\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> fileExtensions: Record&lt;ExportFormat, <span class=\"built_in\">string</span>&gt; = &#123;</span><br><span class=\"line\">\tjsonMiniDiary: <span class=\"string\">\"json\"</span>,</span><br><span class=\"line\">\tmd: <span class=\"string\">\"md\"</span>,</span><br><span class=\"line\">\tpdf: <span class=\"string\">\"pdf\"</span>,</span><br><span class=\"line\">\ttxtDayOne: <span class=\"string\">\"txt\"</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这是一段来自 real world 的代码。通过这段代码，能看到 <code>Record</code> 能够帮助我们获得类型安全的对象声明。</p>\n"},{"title":"【译】理解 express.js","date":"2020-11-09T02:55:34.000Z","_content":"\n> [原文链接](https://blog.laputa.io/understanding-expressjs-d5ef4f4646c8)\n\n## 回顾 express api\n\n在我们开始之前，先来快速回顾下 express 的 api。\n\nExpressjs 主要有两种类型的 api：中间件和路由。\n\n在创建了一个 express 应用后，我们做的第一件事就是通过调用 `app.use` 添加一些有用的中间件，比如：\n\n```js\nvar app = express()\nvar bodyParser = require('body-parser')\n\n// third party middleware\n// parse application/json\napp.use(bodyParser.json())\n\n// user defined middleware\napp.use(function (req, res, next) {\n  console.log('Time:', Date.now())\n  next()\n})\n\n// use middleware for specific url path\napp.use('/user/:id', function (req, res, next) {\n  checkUser(req.params.id)\n  next()\n})\n```\n\n\n这个中间件函数会按照他们被调用的顺序被执行。`next()` 方法会把请求（request）传到下一个中间件，当请求被处理的时候这就形成了一个链路。\n\n路由 api 包括了 `app.METHOD()` 和 `app.route().METHOD()`，*METHOD* 可以试任何 HTTP 方法。它们被用来为指定的 url 路径和 http 方法设置一个 handler 函数。\n\n```js\nvar app = express()\n\n// handle GET /foo\napp.get('/foo', function (req, res, next) {\n  res.end('foo')\n})\n\n// define a route and a group of handlers\napp.route('/book')\n  .get(function (req, res) {\n    res.send('Get a random book')\n  })\n  .post(function (req, res) {\n    res.send('Add a book')\n  })\n  .put(function (req, res) {\n    res.send('Update the book')\n  })\n```\n\n## 如何实现\n\n让我们先看看这些 api 是怎么在 express 中实现的。\n\nexpress 的源代码有着非常简单的结构。\n\n![alt](https://img10.360buyimg.com/jdphoto/jfs/t1/150192/31/13662/19143/5fa8e603E010f22f1/0c02010c35e76fa5.png)\n\n所有的内部逻辑都在 *lib* 目录，*application.js* 定义了 express application，中间件和路由逻辑在 *router* 目录下。（middleware目录包含了两个内置的中间件，在这篇文章中我们会跳过）\n\n> 译者注：两个内置的中间件分别是 expressInit 和 query。分别用于初始化 express 的 req、res 和解析 req 的 querystring 成 query 对象。\n\n每个 express 应用都有一个 *_router* 属性，它是 Router \b的一个实例，[app.use](https://github.com/expressjs/express/blob/3ed5090ca91f6a387e66370d57ead94d886275e1/lib/application.js#L187-L221) 和 [app.route](https://github.com/expressjs/express/blob/3ed5090ca91f6a387e66370d57ead94d886275e1/lib/application.js#L254-L257) 仅仅是代理到 *_router* 对象的同名函数上。\n\n```js\napp.use = function use(fn) {\n...\n  fns.forEach(function (fn) {\n// non-express app\n    if (!fn || !fn.handle || !fn.set) {\n      return router.use(path, fn);\n    }\n...\n}\napp.route = function route(path) {\n  this.lazyrouter();\n  return this._router.route(path);\n};\n```\n\n而将 [app.method](https://github.com/expressjs/express/blob/3ed5090ca91f6a387e66370d57ead94d886275e1/lib/application.js#L472-L485) 委托给 _router 来为特定的HTTP方法创建Route:\n\n```js\n// methods is an array of all HTTP verbs\nmethods.forEach(function(method){\n  app[method] = function(path){\n  ...\n    var route = this._router.route(path);\n    route[method].apply(route, slice.call(arguments, 1));\n    return this;\n  };\n});\n```\n\n到现在为止，我们知道了一个 Express 应用基本上是它内部的 *_router* 对象的一个包装。\n\n*_router* 是如何实现这些中间件和路由逻辑的呢？秘密就放在 *lib/router* 目录下。它有三个核心的组件，分别是 **Router**，**Route**，**Layer**。\n\n在我们更深入之前，我会使用一个 express 的示例应用来帮助解释这些内部组件。\n\n\n```js\nconst express = require('express')\nconst app = express()\n\napp.use(function middlewareWithoutPath(req, res, next) {\n    console.log('use middleware without path')\n    next()\n})\n\napp.use('/foo', function middlewareWithPath(req, res, next) {\n    console.log('use middleware with path')\n    next()\n})\n\napp.route('/bar')\n    .get(function routeBarGet(req, res) {\n        res.send('ok')\n    })\n    .post(function routeBarPost(req, res) {\n        res.send('ok')\n    })\n\napp.get('/zoo', function getZoo(req, res) {\n    res.send('ok')\n})\n\napp.listen(3000, () => {\n    console.log('listen on 3000...')\n})\n```\n\n上面的代码创建了一个 express 应用，然后调用了 `app.use()` 方法两次。第一次没有带 path 参数，第二次传入了 path `/foo`。然后调用了 `route` 方法为路径 `/bar` 创建了一个路由，并且为这个路径分别定义了 `get` 和 `post` 方法的 handler。最后在 `app` 上调用了 `get` 方法，为路径 `/zoo` 定义了一个 handler。\n\n这里应用内部的样子：\n\n![alt](https://img10.360buyimg.com/jdphoto/jfs/t1/155146/1/5229/15738/5fa8f8a0Ed8c4360f/084ebfa9387cb459.png)\n\n## Layer\n\nlayer 是最简单的组件，它具有一个 *path* 属性或者是 *method* 属性用于匹配请求，还有一个 *handle* 字段用于存储中间件函数。\n\n```js\nLayer {\n  path   // when it's in the router\n  method // when it's in the route\n  handle = middleware_func\n}\n```\n\nlayer 会调用它的 `match` 方法，如果传入请求（incoming request）的属性匹配上 layer 的 `path` 或者 `method`，那么它就会把请求（request）传给 middleware_func。\n\n\n## The Router\n\n它是 express 应用中的主要组件。它维护了一个 *Layer* 的队列（使用 array 实现），当 `app.use(path, fn)` 被调用时，`_router` 会创建一个新的 Layer 对象，并且把 `path` 和 `middleware` 赋给这个 layer 对象，然后把它推进队列。\n\n```js\napp.use(path, fn) ==>\n\n_router:\n\nlayer = new Layer()\nlayer.path = path\nlayer.handle = fn\nstack.push(layer)\n```\n\n在没有 path 参数的情况下添加一个中间件，这个 layer 的 `path` 会被默认设置为 `/`，而 `/` 会匹配任意路径，这意味着这个中间件会在任何请求进入时都会被执行。\n\n当 `app.route(path).get(fn)` 或者 `app.get(path, fn)` 被调用时，_router [会创建](https://github.com/expressjs/express/blob/3ed5090ca91f6a387e66370d57ead94d886275e1/lib/router/index.js#L491-L504) 一个新的 Route 对象，和一个新的 Layer 对象，这个 Layer 对象的 path 属性会被设置参数 path，而 Layer 对象的 handle 函数会被设置成新的 Route 对象的 dispatch 方法。\n\n```js\napp.route(path).get(fn) ==>\n\n// _router\nroute = new Route()\nroute.get(fn)\n\nlayer = new Layer()\nlayer.path = path\nlayer.handle = route.dispatch\nstack.push(layer)\n```\n\n所有的路径匹配都发生在 _router 的队列中，当一个请求进入，_router 会遍历它队列中的所有 layer，如果 layer 的 path 匹配上了请求的 path，那么这个 layer 对象的 handle 函数就会被执行，这个函数既可能是中间件方法，也可能是一个路由的 dispatch 方法。\n\n如果匹配的 layer 指向一个 route 的 dispatch 方法，则请求将被传递到该 route 对象，让我们来看看Route是如何工作的\n\n## Route\n\n*Router* 处理 path 匹配，*Route* 处理 http method 匹配。每个 Route 有它自己的 layer 队列，队列中的每个 layer 在创建时都会存储 http 方法名。\n\n\n\n```js\napp.get(path, fn) ==>\n\n// _router:\nroute = new Route()\nroute.get(fn)\n...\n\n// route.get(fn)\nlayer = new Layer()\nlayer.method = 'get'\nlayer.handle = fn\nroute.stack.push(layer)\n```\n\n`app.route(path).get(fn)` 也是相同的逻辑","source":"_posts/understanding-expressjs.md","raw":"---\ntitle: 【译】理解 express.js\ndate: 2020-11-09 10:55:34\ntags:\n---\n\n> [原文链接](https://blog.laputa.io/understanding-expressjs-d5ef4f4646c8)\n\n## 回顾 express api\n\n在我们开始之前，先来快速回顾下 express 的 api。\n\nExpressjs 主要有两种类型的 api：中间件和路由。\n\n在创建了一个 express 应用后，我们做的第一件事就是通过调用 `app.use` 添加一些有用的中间件，比如：\n\n```js\nvar app = express()\nvar bodyParser = require('body-parser')\n\n// third party middleware\n// parse application/json\napp.use(bodyParser.json())\n\n// user defined middleware\napp.use(function (req, res, next) {\n  console.log('Time:', Date.now())\n  next()\n})\n\n// use middleware for specific url path\napp.use('/user/:id', function (req, res, next) {\n  checkUser(req.params.id)\n  next()\n})\n```\n\n\n这个中间件函数会按照他们被调用的顺序被执行。`next()` 方法会把请求（request）传到下一个中间件，当请求被处理的时候这就形成了一个链路。\n\n路由 api 包括了 `app.METHOD()` 和 `app.route().METHOD()`，*METHOD* 可以试任何 HTTP 方法。它们被用来为指定的 url 路径和 http 方法设置一个 handler 函数。\n\n```js\nvar app = express()\n\n// handle GET /foo\napp.get('/foo', function (req, res, next) {\n  res.end('foo')\n})\n\n// define a route and a group of handlers\napp.route('/book')\n  .get(function (req, res) {\n    res.send('Get a random book')\n  })\n  .post(function (req, res) {\n    res.send('Add a book')\n  })\n  .put(function (req, res) {\n    res.send('Update the book')\n  })\n```\n\n## 如何实现\n\n让我们先看看这些 api 是怎么在 express 中实现的。\n\nexpress 的源代码有着非常简单的结构。\n\n![alt](https://img10.360buyimg.com/jdphoto/jfs/t1/150192/31/13662/19143/5fa8e603E010f22f1/0c02010c35e76fa5.png)\n\n所有的内部逻辑都在 *lib* 目录，*application.js* 定义了 express application，中间件和路由逻辑在 *router* 目录下。（middleware目录包含了两个内置的中间件，在这篇文章中我们会跳过）\n\n> 译者注：两个内置的中间件分别是 expressInit 和 query。分别用于初始化 express 的 req、res 和解析 req 的 querystring 成 query 对象。\n\n每个 express 应用都有一个 *_router* 属性，它是 Router \b的一个实例，[app.use](https://github.com/expressjs/express/blob/3ed5090ca91f6a387e66370d57ead94d886275e1/lib/application.js#L187-L221) 和 [app.route](https://github.com/expressjs/express/blob/3ed5090ca91f6a387e66370d57ead94d886275e1/lib/application.js#L254-L257) 仅仅是代理到 *_router* 对象的同名函数上。\n\n```js\napp.use = function use(fn) {\n...\n  fns.forEach(function (fn) {\n// non-express app\n    if (!fn || !fn.handle || !fn.set) {\n      return router.use(path, fn);\n    }\n...\n}\napp.route = function route(path) {\n  this.lazyrouter();\n  return this._router.route(path);\n};\n```\n\n而将 [app.method](https://github.com/expressjs/express/blob/3ed5090ca91f6a387e66370d57ead94d886275e1/lib/application.js#L472-L485) 委托给 _router 来为特定的HTTP方法创建Route:\n\n```js\n// methods is an array of all HTTP verbs\nmethods.forEach(function(method){\n  app[method] = function(path){\n  ...\n    var route = this._router.route(path);\n    route[method].apply(route, slice.call(arguments, 1));\n    return this;\n  };\n});\n```\n\n到现在为止，我们知道了一个 Express 应用基本上是它内部的 *_router* 对象的一个包装。\n\n*_router* 是如何实现这些中间件和路由逻辑的呢？秘密就放在 *lib/router* 目录下。它有三个核心的组件，分别是 **Router**，**Route**，**Layer**。\n\n在我们更深入之前，我会使用一个 express 的示例应用来帮助解释这些内部组件。\n\n\n```js\nconst express = require('express')\nconst app = express()\n\napp.use(function middlewareWithoutPath(req, res, next) {\n    console.log('use middleware without path')\n    next()\n})\n\napp.use('/foo', function middlewareWithPath(req, res, next) {\n    console.log('use middleware with path')\n    next()\n})\n\napp.route('/bar')\n    .get(function routeBarGet(req, res) {\n        res.send('ok')\n    })\n    .post(function routeBarPost(req, res) {\n        res.send('ok')\n    })\n\napp.get('/zoo', function getZoo(req, res) {\n    res.send('ok')\n})\n\napp.listen(3000, () => {\n    console.log('listen on 3000...')\n})\n```\n\n上面的代码创建了一个 express 应用，然后调用了 `app.use()` 方法两次。第一次没有带 path 参数，第二次传入了 path `/foo`。然后调用了 `route` 方法为路径 `/bar` 创建了一个路由，并且为这个路径分别定义了 `get` 和 `post` 方法的 handler。最后在 `app` 上调用了 `get` 方法，为路径 `/zoo` 定义了一个 handler。\n\n这里应用内部的样子：\n\n![alt](https://img10.360buyimg.com/jdphoto/jfs/t1/155146/1/5229/15738/5fa8f8a0Ed8c4360f/084ebfa9387cb459.png)\n\n## Layer\n\nlayer 是最简单的组件，它具有一个 *path* 属性或者是 *method* 属性用于匹配请求，还有一个 *handle* 字段用于存储中间件函数。\n\n```js\nLayer {\n  path   // when it's in the router\n  method // when it's in the route\n  handle = middleware_func\n}\n```\n\nlayer 会调用它的 `match` 方法，如果传入请求（incoming request）的属性匹配上 layer 的 `path` 或者 `method`，那么它就会把请求（request）传给 middleware_func。\n\n\n## The Router\n\n它是 express 应用中的主要组件。它维护了一个 *Layer* 的队列（使用 array 实现），当 `app.use(path, fn)` 被调用时，`_router` 会创建一个新的 Layer 对象，并且把 `path` 和 `middleware` 赋给这个 layer 对象，然后把它推进队列。\n\n```js\napp.use(path, fn) ==>\n\n_router:\n\nlayer = new Layer()\nlayer.path = path\nlayer.handle = fn\nstack.push(layer)\n```\n\n在没有 path 参数的情况下添加一个中间件，这个 layer 的 `path` 会被默认设置为 `/`，而 `/` 会匹配任意路径，这意味着这个中间件会在任何请求进入时都会被执行。\n\n当 `app.route(path).get(fn)` 或者 `app.get(path, fn)` 被调用时，_router [会创建](https://github.com/expressjs/express/blob/3ed5090ca91f6a387e66370d57ead94d886275e1/lib/router/index.js#L491-L504) 一个新的 Route 对象，和一个新的 Layer 对象，这个 Layer 对象的 path 属性会被设置参数 path，而 Layer 对象的 handle 函数会被设置成新的 Route 对象的 dispatch 方法。\n\n```js\napp.route(path).get(fn) ==>\n\n// _router\nroute = new Route()\nroute.get(fn)\n\nlayer = new Layer()\nlayer.path = path\nlayer.handle = route.dispatch\nstack.push(layer)\n```\n\n所有的路径匹配都发生在 _router 的队列中，当一个请求进入，_router 会遍历它队列中的所有 layer，如果 layer 的 path 匹配上了请求的 path，那么这个 layer 对象的 handle 函数就会被执行，这个函数既可能是中间件方法，也可能是一个路由的 dispatch 方法。\n\n如果匹配的 layer 指向一个 route 的 dispatch 方法，则请求将被传递到该 route 对象，让我们来看看Route是如何工作的\n\n## Route\n\n*Router* 处理 path 匹配，*Route* 处理 http method 匹配。每个 Route 有它自己的 layer 队列，队列中的每个 layer 在创建时都会存储 http 方法名。\n\n\n\n```js\napp.get(path, fn) ==>\n\n// _router:\nroute = new Route()\nroute.get(fn)\n...\n\n// route.get(fn)\nlayer = new Layer()\nlayer.method = 'get'\nlayer.handle = fn\nroute.stack.push(layer)\n```\n\n`app.route(path).get(fn)` 也是相同的逻辑","slug":"understanding-expressjs","published":1,"updated":"2020-11-09T09:04:54.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhpu92wz0006ak87ap557x4z","content":"<blockquote>\n<p><a href=\"https://blog.laputa.io/understanding-expressjs-d5ef4f4646c8\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n</blockquote>\n<h2 id=\"回顾-express-api\"><a href=\"#回顾-express-api\" class=\"headerlink\" title=\"回顾 express api\"></a>回顾 express api</h2><p>在我们开始之前，先来快速回顾下 express 的 api。</p>\n<p>Expressjs 主要有两种类型的 api：中间件和路由。</p>\n<p>在创建了一个 express 应用后，我们做的第一件事就是通过调用 <code>app.use</code> 添加一些有用的中间件，比如：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = express()</span><br><span class=\"line\"><span class=\"keyword\">var</span> bodyParser = <span class=\"built_in\">require</span>(<span class=\"string\">'body-parser'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// third party middleware</span></span><br><span class=\"line\"><span class=\"comment\">// parse application/json</span></span><br><span class=\"line\">app.use(bodyParser.json())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// user defined middleware</span></span><br><span class=\"line\">app.use(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res, next</span>) </span>{</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Time:'</span>, <span class=\"built_in\">Date</span>.now())</span><br><span class=\"line\">  next()</span><br><span class=\"line\">})</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// use middleware for specific url path</span></span><br><span class=\"line\">app.use(<span class=\"string\">'/user/:id'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res, next</span>) </span>{</span><br><span class=\"line\">  checkUser(req.params.id)</span><br><span class=\"line\">  next()</span><br><span class=\"line\">})</span><br></pre></td></tr></tbody></table></figure>\n<p>这个中间件函数会按照他们被调用的顺序被执行。<code>next()</code> 方法会把请求（request）传到下一个中间件，当请求被处理的时候这就形成了一个链路。</p>\n<p>路由 api 包括了 <code>app.METHOD()</code> 和 <code>app.route().METHOD()</code>，<em>METHOD</em> 可以试任何 HTTP 方法。它们被用来为指定的 url 路径和 http 方法设置一个 handler 函数。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = express()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// handle GET /foo</span></span><br><span class=\"line\">app.get(<span class=\"string\">'/foo'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res, next</span>) </span>{</span><br><span class=\"line\">  res.end(<span class=\"string\">'foo'</span>)</span><br><span class=\"line\">})</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// define a route and a group of handlers</span></span><br><span class=\"line\">app.route(<span class=\"string\">'/book'</span>)</span><br><span class=\"line\">  .get(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>{</span><br><span class=\"line\">    res.send(<span class=\"string\">'Get a random book'</span>)</span><br><span class=\"line\">  })</span><br><span class=\"line\">  .post(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>{</span><br><span class=\"line\">    res.send(<span class=\"string\">'Add a book'</span>)</span><br><span class=\"line\">  })</span><br><span class=\"line\">  .put(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>{</span><br><span class=\"line\">    res.send(<span class=\"string\">'Update the book'</span>)</span><br><span class=\"line\">  })</span><br></pre></td></tr></tbody></table></figure>\n<h2 id=\"如何实现\"><a href=\"#如何实现\" class=\"headerlink\" title=\"如何实现\"></a>如何实现</h2><p>让我们先看看这些 api 是怎么在 express 中实现的。</p>\n<p>express 的源代码有着非常简单的结构。</p>\n<p><img src=\"https://img10.360buyimg.com/jdphoto/jfs/t1/150192/31/13662/19143/5fa8e603E010f22f1/0c02010c35e76fa5.png\" alt=\"alt\"></p>\n<p>所有的内部逻辑都在 <em>lib</em> 目录，<em>application.js</em> 定义了 express application，中间件和路由逻辑在 <em>router</em> 目录下。（middleware目录包含了两个内置的中间件，在这篇文章中我们会跳过）</p>\n<blockquote>\n<p>译者注：两个内置的中间件分别是 expressInit 和 query。分别用于初始化 express 的 req、res 和解析 req 的 querystring 成 query 对象。</p>\n</blockquote>\n<p>每个 express 应用都有一个 <em>_router</em> 属性，它是 Router \b的一个实例，<a href=\"https://github.com/expressjs/express/blob/3ed5090ca91f6a387e66370d57ead94d886275e1/lib/application.js#L187-L221\" target=\"_blank\" rel=\"noopener\">app.use</a> 和 <a href=\"https://github.com/expressjs/express/blob/3ed5090ca91f6a387e66370d57ead94d886275e1/lib/application.js#L254-L257\" target=\"_blank\" rel=\"noopener\">app.route</a> 仅仅是代理到 <em>_router</em> 对象的同名函数上。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">use</span>(<span class=\"params\">fn</span>) </span>{</span><br><span class=\"line\">...</span><br><span class=\"line\">  fns.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn</span>) </span>{</span><br><span class=\"line\"><span class=\"comment\">// non-express app</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!fn || !fn.handle || !fn.set) {</span><br><span class=\"line\">      <span class=\"keyword\">return</span> router.use(path, fn);</span><br><span class=\"line\">    }</span><br><span class=\"line\">...</span><br><span class=\"line\">}</span><br><span class=\"line\">app.route = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">route</span>(<span class=\"params\">path</span>) </span>{</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.lazyrouter();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._router.route(path);</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n<p>而将 <a href=\"https://github.com/expressjs/express/blob/3ed5090ca91f6a387e66370d57ead94d886275e1/lib/application.js#L472-L485\" target=\"_blank\" rel=\"noopener\">app.method</a> 委托给 _router 来为特定的HTTP方法创建Route:</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// methods is an array of all HTTP verbs</span></span><br><span class=\"line\">methods.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">method</span>)</span>{</span><br><span class=\"line\">  app[method] = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">path</span>)</span>{</span><br><span class=\"line\">  ...</span><br><span class=\"line\">    <span class=\"keyword\">var</span> route = <span class=\"keyword\">this</span>._router.route(path);</span><br><span class=\"line\">    route[method].apply(route, slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  };</span><br><span class=\"line\">});</span><br></pre></td></tr></tbody></table></figure>\n<p>到现在为止，我们知道了一个 Express 应用基本上是它内部的 <em>_router</em> 对象的一个包装。</p>\n<p><em>_router</em> 是如何实现这些中间件和路由逻辑的呢？秘密就放在 <em>lib/router</em> 目录下。它有三个核心的组件，分别是 <strong>Router</strong>，<strong>Route</strong>，<strong>Layer</strong>。</p>\n<p>在我们更深入之前，我会使用一个 express 的示例应用来帮助解释这些内部组件。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = express()</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">middlewareWithoutPath</span>(<span class=\"params\">req, res, next</span>) </span>{</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'use middleware without path'</span>)</span><br><span class=\"line\">    next()</span><br><span class=\"line\">})</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"string\">'/foo'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">middlewareWithPath</span>(<span class=\"params\">req, res, next</span>) </span>{</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'use middleware with path'</span>)</span><br><span class=\"line\">    next()</span><br><span class=\"line\">})</span><br><span class=\"line\"></span><br><span class=\"line\">app.route(<span class=\"string\">'/bar'</span>)</span><br><span class=\"line\">    .get(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">routeBarGet</span>(<span class=\"params\">req, res</span>) </span>{</span><br><span class=\"line\">        res.send(<span class=\"string\">'ok'</span>)</span><br><span class=\"line\">    })</span><br><span class=\"line\">    .post(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">routeBarPost</span>(<span class=\"params\">req, res</span>) </span>{</span><br><span class=\"line\">        res.send(<span class=\"string\">'ok'</span>)</span><br><span class=\"line\">    })</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">'/zoo'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getZoo</span>(<span class=\"params\">req, res</span>) </span>{</span><br><span class=\"line\">    res.send(<span class=\"string\">'ok'</span>)</span><br><span class=\"line\">})</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>, () => {</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'listen on 3000...'</span>)</span><br><span class=\"line\">})</span><br></pre></td></tr></tbody></table></figure>\n<p>上面的代码创建了一个 express 应用，然后调用了 <code>app.use()</code> 方法两次。第一次没有带 path 参数，第二次传入了 path <code>/foo</code>。然后调用了 <code>route</code> 方法为路径 <code>/bar</code> 创建了一个路由，并且为这个路径分别定义了 <code>get</code> 和 <code>post</code> 方法的 handler。最后在 <code>app</code> 上调用了 <code>get</code> 方法，为路径 <code>/zoo</code> 定义了一个 handler。</p>\n<p>这里应用内部的样子：</p>\n<p><img src=\"https://img10.360buyimg.com/jdphoto/jfs/t1/155146/1/5229/15738/5fa8f8a0Ed8c4360f/084ebfa9387cb459.png\" alt=\"alt\"></p>\n<h2 id=\"Layer\"><a href=\"#Layer\" class=\"headerlink\" title=\"Layer\"></a>Layer</h2><p>layer 是最简单的组件，它具有一个 <em>path</em> 属性或者是 <em>method</em> 属性用于匹配请求，还有一个 <em>handle</em> 字段用于存储中间件函数。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Layer {</span><br><span class=\"line\">  path   <span class=\"comment\">// when it's in the router</span></span><br><span class=\"line\">  method <span class=\"comment\">// when it's in the route</span></span><br><span class=\"line\">  handle = middleware_func</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>layer 会调用它的 <code>match</code> 方法，如果传入请求（incoming request）的属性匹配上 layer 的 <code>path</code> 或者 <code>method</code>，那么它就会把请求（request）传给 middleware_func。</p>\n<h2 id=\"The-Router\"><a href=\"#The-Router\" class=\"headerlink\" title=\"The Router\"></a>The Router</h2><p>它是 express 应用中的主要组件。它维护了一个 <em>Layer</em> 的队列（使用 array 实现），当 <code>app.use(path, fn)</code> 被调用时，<code>_router</code> 会创建一个新的 Layer 对象，并且把 <code>path</code> 和 <code>middleware</code> 赋给这个 layer 对象，然后把它推进队列。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(path, fn) ==></span><br><span class=\"line\"></span><br><span class=\"line\">_router:</span><br><span class=\"line\"></span><br><span class=\"line\">layer = <span class=\"keyword\">new</span> Layer()</span><br><span class=\"line\">layer.path = path</span><br><span class=\"line\">layer.handle = fn</span><br><span class=\"line\">stack.push(layer)</span><br></pre></td></tr></tbody></table></figure>\n<p>在没有 path 参数的情况下添加一个中间件，这个 layer 的 <code>path</code> 会被默认设置为 <code>/</code>，而 <code>/</code> 会匹配任意路径，这意味着这个中间件会在任何请求进入时都会被执行。</p>\n<p>当 <code>app.route(path).get(fn)</code> 或者 <code>app.get(path, fn)</code> 被调用时，_router <a href=\"https://github.com/expressjs/express/blob/3ed5090ca91f6a387e66370d57ead94d886275e1/lib/router/index.js#L491-L504\" target=\"_blank\" rel=\"noopener\">会创建</a> 一个新的 Route 对象，和一个新的 Layer 对象，这个 Layer 对象的 path 属性会被设置参数 path，而 Layer 对象的 handle 函数会被设置成新的 Route 对象的 dispatch 方法。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.route(path).get(fn) ==></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// _router</span></span><br><span class=\"line\">route = <span class=\"keyword\">new</span> Route()</span><br><span class=\"line\">route.get(fn)</span><br><span class=\"line\"></span><br><span class=\"line\">layer = <span class=\"keyword\">new</span> Layer()</span><br><span class=\"line\">layer.path = path</span><br><span class=\"line\">layer.handle = route.dispatch</span><br><span class=\"line\">stack.push(layer)</span><br></pre></td></tr></tbody></table></figure>\n<p>所有的路径匹配都发生在 _router 的队列中，当一个请求进入，_router 会遍历它队列中的所有 layer，如果 layer 的 path 匹配上了请求的 path，那么这个 layer 对象的 handle 函数就会被执行，这个函数既可能是中间件方法，也可能是一个路由的 dispatch 方法。</p>\n<p>如果匹配的 layer 指向一个 route 的 dispatch 方法，则请求将被传递到该 route 对象，让我们来看看Route是如何工作的</p>\n<h2 id=\"Route\"><a href=\"#Route\" class=\"headerlink\" title=\"Route\"></a>Route</h2><p><em>Router</em> 处理 path 匹配，<em>Route</em> 处理 http method 匹配。每个 Route 有它自己的 layer 队列，队列中的每个 layer 在创建时都会存储 http 方法名。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.get(path, fn) ==></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// _router:</span></span><br><span class=\"line\">route = <span class=\"keyword\">new</span> Route()</span><br><span class=\"line\">route.get(fn)</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// route.get(fn)</span></span><br><span class=\"line\">layer = <span class=\"keyword\">new</span> Layer()</span><br><span class=\"line\">layer.method = <span class=\"string\">'get'</span></span><br><span class=\"line\">layer.handle = fn</span><br><span class=\"line\">route.stack.push(layer)</span><br></pre></td></tr></tbody></table></figure>\n<p><code>app.route(path).get(fn)</code> 也是相同的逻辑</p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p><a href=\"https://blog.laputa.io/understanding-expressjs-d5ef4f4646c8\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n</blockquote>\n<h2 id=\"回顾-express-api\"><a href=\"#回顾-express-api\" class=\"headerlink\" title=\"回顾 express api\"></a>回顾 express api</h2><p>在我们开始之前，先来快速回顾下 express 的 api。</p>\n<p>Expressjs 主要有两种类型的 api：中间件和路由。</p>\n<p>在创建了一个 express 应用后，我们做的第一件事就是通过调用 <code>app.use</code> 添加一些有用的中间件，比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = express()</span><br><span class=\"line\"><span class=\"keyword\">var</span> bodyParser = <span class=\"built_in\">require</span>(<span class=\"string\">'body-parser'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// third party middleware</span></span><br><span class=\"line\"><span class=\"comment\">// parse application/json</span></span><br><span class=\"line\">app.use(bodyParser.json())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// user defined middleware</span></span><br><span class=\"line\">app.use(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Time:'</span>, <span class=\"built_in\">Date</span>.now())</span><br><span class=\"line\">  next()</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// use middleware for specific url path</span></span><br><span class=\"line\">app.use(<span class=\"string\">'/user/:id'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">  checkUser(req.params.id)</span><br><span class=\"line\">  next()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这个中间件函数会按照他们被调用的顺序被执行。<code>next()</code> 方法会把请求（request）传到下一个中间件，当请求被处理的时候这就形成了一个链路。</p>\n<p>路由 api 包括了 <code>app.METHOD()</code> 和 <code>app.route().METHOD()</code>，<em>METHOD</em> 可以试任何 HTTP 方法。它们被用来为指定的 url 路径和 http 方法设置一个 handler 函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = express()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// handle GET /foo</span></span><br><span class=\"line\">app.get(<span class=\"string\">'/foo'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">  res.end(<span class=\"string\">'foo'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// define a route and a group of handlers</span></span><br><span class=\"line\">app.route(<span class=\"string\">'/book'</span>)</span><br><span class=\"line\">  .get(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    res.send(<span class=\"string\">'Get a random book'</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .post(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    res.send(<span class=\"string\">'Add a book'</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .put(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    res.send(<span class=\"string\">'Update the book'</span>)</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"如何实现\"><a href=\"#如何实现\" class=\"headerlink\" title=\"如何实现\"></a>如何实现</h2><p>让我们先看看这些 api 是怎么在 express 中实现的。</p>\n<p>express 的源代码有着非常简单的结构。</p>\n<p><img src=\"https://img10.360buyimg.com/jdphoto/jfs/t1/150192/31/13662/19143/5fa8e603E010f22f1/0c02010c35e76fa5.png\" alt=\"alt\"></p>\n<p>所有的内部逻辑都在 <em>lib</em> 目录，<em>application.js</em> 定义了 express application，中间件和路由逻辑在 <em>router</em> 目录下。（middleware目录包含了两个内置的中间件，在这篇文章中我们会跳过）</p>\n<blockquote>\n<p>译者注：两个内置的中间件分别是 expressInit 和 query。分别用于初始化 express 的 req、res 和解析 req 的 querystring 成 query 对象。</p>\n</blockquote>\n<p>每个 express 应用都有一个 <em>_router</em> 属性，它是 Router \b的一个实例，<a href=\"https://github.com/expressjs/express/blob/3ed5090ca91f6a387e66370d57ead94d886275e1/lib/application.js#L187-L221\" target=\"_blank\" rel=\"noopener\">app.use</a> 和 <a href=\"https://github.com/expressjs/express/blob/3ed5090ca91f6a387e66370d57ead94d886275e1/lib/application.js#L254-L257\" target=\"_blank\" rel=\"noopener\">app.route</a> 仅仅是代理到 <em>_router</em> 对象的同名函数上。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">use</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">  fns.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// non-express app</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!fn || !fn.handle || !fn.set) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> router.use(path, fn);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">app.route = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">route</span>(<span class=\"params\">path</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.lazyrouter();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._router.route(path);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>而将 <a href=\"https://github.com/expressjs/express/blob/3ed5090ca91f6a387e66370d57ead94d886275e1/lib/application.js#L472-L485\" target=\"_blank\" rel=\"noopener\">app.method</a> 委托给 _router 来为特定的HTTP方法创建Route:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// methods is an array of all HTTP verbs</span></span><br><span class=\"line\">methods.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">method</span>)</span>&#123;</span><br><span class=\"line\">  app[method] = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">path</span>)</span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">    <span class=\"keyword\">var</span> route = <span class=\"keyword\">this</span>._router.route(path);</span><br><span class=\"line\">    route[method].apply(route, slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>到现在为止，我们知道了一个 Express 应用基本上是它内部的 <em>_router</em> 对象的一个包装。</p>\n<p><em>_router</em> 是如何实现这些中间件和路由逻辑的呢？秘密就放在 <em>lib/router</em> 目录下。它有三个核心的组件，分别是 <strong>Router</strong>，<strong>Route</strong>，<strong>Layer</strong>。</p>\n<p>在我们更深入之前，我会使用一个 express 的示例应用来帮助解释这些内部组件。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = express()</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">middlewareWithoutPath</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'use middleware without path'</span>)</span><br><span class=\"line\">    next()</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"string\">'/foo'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">middlewareWithPath</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'use middleware with path'</span>)</span><br><span class=\"line\">    next()</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.route(<span class=\"string\">'/bar'</span>)</span><br><span class=\"line\">    .get(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">routeBarGet</span>(<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">        res.send(<span class=\"string\">'ok'</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .post(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">routeBarPost</span>(<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">        res.send(<span class=\"string\">'ok'</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">'/zoo'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getZoo</span>(<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    res.send(<span class=\"string\">'ok'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>, () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'listen on 3000...'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>上面的代码创建了一个 express 应用，然后调用了 <code>app.use()</code> 方法两次。第一次没有带 path 参数，第二次传入了 path <code>/foo</code>。然后调用了 <code>route</code> 方法为路径 <code>/bar</code> 创建了一个路由，并且为这个路径分别定义了 <code>get</code> 和 <code>post</code> 方法的 handler。最后在 <code>app</code> 上调用了 <code>get</code> 方法，为路径 <code>/zoo</code> 定义了一个 handler。</p>\n<p>这里应用内部的样子：</p>\n<p><img src=\"https://img10.360buyimg.com/jdphoto/jfs/t1/155146/1/5229/15738/5fa8f8a0Ed8c4360f/084ebfa9387cb459.png\" alt=\"alt\"></p>\n<h2 id=\"Layer\"><a href=\"#Layer\" class=\"headerlink\" title=\"Layer\"></a>Layer</h2><p>layer 是最简单的组件，它具有一个 <em>path</em> 属性或者是 <em>method</em> 属性用于匹配请求，还有一个 <em>handle</em> 字段用于存储中间件函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Layer &#123;</span><br><span class=\"line\">  path   <span class=\"comment\">// when it's in the router</span></span><br><span class=\"line\">  method <span class=\"comment\">// when it's in the route</span></span><br><span class=\"line\">  handle = middleware_func</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>layer 会调用它的 <code>match</code> 方法，如果传入请求（incoming request）的属性匹配上 layer 的 <code>path</code> 或者 <code>method</code>，那么它就会把请求（request）传给 middleware_func。</p>\n<h2 id=\"The-Router\"><a href=\"#The-Router\" class=\"headerlink\" title=\"The Router\"></a>The Router</h2><p>它是 express 应用中的主要组件。它维护了一个 <em>Layer</em> 的队列（使用 array 实现），当 <code>app.use(path, fn)</code> 被调用时，<code>_router</code> 会创建一个新的 Layer 对象，并且把 <code>path</code> 和 <code>middleware</code> 赋给这个 layer 对象，然后把它推进队列。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(path, fn) ==&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">_router:</span><br><span class=\"line\"></span><br><span class=\"line\">layer = <span class=\"keyword\">new</span> Layer()</span><br><span class=\"line\">layer.path = path</span><br><span class=\"line\">layer.handle = fn</span><br><span class=\"line\">stack.push(layer)</span><br></pre></td></tr></table></figure>\n<p>在没有 path 参数的情况下添加一个中间件，这个 layer 的 <code>path</code> 会被默认设置为 <code>/</code>，而 <code>/</code> 会匹配任意路径，这意味着这个中间件会在任何请求进入时都会被执行。</p>\n<p>当 <code>app.route(path).get(fn)</code> 或者 <code>app.get(path, fn)</code> 被调用时，_router <a href=\"https://github.com/expressjs/express/blob/3ed5090ca91f6a387e66370d57ead94d886275e1/lib/router/index.js#L491-L504\" target=\"_blank\" rel=\"noopener\">会创建</a> 一个新的 Route 对象，和一个新的 Layer 对象，这个 Layer 对象的 path 属性会被设置参数 path，而 Layer 对象的 handle 函数会被设置成新的 Route 对象的 dispatch 方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.route(path).get(fn) ==&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// _router</span></span><br><span class=\"line\">route = <span class=\"keyword\">new</span> Route()</span><br><span class=\"line\">route.get(fn)</span><br><span class=\"line\"></span><br><span class=\"line\">layer = <span class=\"keyword\">new</span> Layer()</span><br><span class=\"line\">layer.path = path</span><br><span class=\"line\">layer.handle = route.dispatch</span><br><span class=\"line\">stack.push(layer)</span><br></pre></td></tr></table></figure>\n<p>所有的路径匹配都发生在 _router 的队列中，当一个请求进入，_router 会遍历它队列中的所有 layer，如果 layer 的 path 匹配上了请求的 path，那么这个 layer 对象的 handle 函数就会被执行，这个函数既可能是中间件方法，也可能是一个路由的 dispatch 方法。</p>\n<p>如果匹配的 layer 指向一个 route 的 dispatch 方法，则请求将被传递到该 route 对象，让我们来看看Route是如何工作的</p>\n<h2 id=\"Route\"><a href=\"#Route\" class=\"headerlink\" title=\"Route\"></a>Route</h2><p><em>Router</em> 处理 path 匹配，<em>Route</em> 处理 http method 匹配。每个 Route 有它自己的 layer 队列，队列中的每个 layer 在创建时都会存储 http 方法名。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.get(path, fn) ==&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// _router:</span></span><br><span class=\"line\">route = <span class=\"keyword\">new</span> Route()</span><br><span class=\"line\">route.get(fn)</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// route.get(fn)</span></span><br><span class=\"line\">layer = <span class=\"keyword\">new</span> Layer()</span><br><span class=\"line\">layer.method = <span class=\"string\">'get'</span></span><br><span class=\"line\">layer.handle = fn</span><br><span class=\"line\">route.stack.push(layer)</span><br></pre></td></tr></table></figure>\n<p><code>app.route(path).get(fn)</code> 也是相同的逻辑</p>\n"},{"title":"打造最高效的 macOS 工作流（一）","date":"2018-11-14T06:02:10.000Z","_content":"\n\n减少鼠标和键盘之间来回耗费的时间，使得绝大部分工作能够只使用键盘就能完成。\n\n\n## Mac 篇\n## Alfred 篇\n## Chrome 篇\n## VSCODE 篇\n## iTerm2 篇\n\n\n\n## Alfred with Powerpack\n\n- alfred-gitmoji-workflow \n[alfred-gitmoji-workflow](https://github.com/Quilljou/alfred-gitmoji-workflow)\n\n\n\n\n\n## iTerm2\n\n## VSCODE","source":"_drafts/mac-guide-series-one.md","raw":"---\ntitle: 打造最高效的 macOS 工作流（一）\ndate: 2018-11-14 14:02:10\ntags:\n---\n\n\n减少鼠标和键盘之间来回耗费的时间，使得绝大部分工作能够只使用键盘就能完成。\n\n\n## Mac 篇\n## Alfred 篇\n## Chrome 篇\n## VSCODE 篇\n## iTerm2 篇\n\n\n\n## Alfred with Powerpack\n\n- alfred-gitmoji-workflow \n[alfred-gitmoji-workflow](https://github.com/Quilljou/alfred-gitmoji-workflow)\n\n\n\n\n\n## iTerm2\n\n## VSCODE","slug":"mac-guide-series-one","published":0,"updated":"2019-07-19T01:53:42.605Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhpu92x00007ak870w4k5x9u","content":"<p>减少鼠标和键盘之间来回耗费的时间，使得绝大部分工作能够只使用键盘就能完成。</p>\n<h2 id=\"Mac-篇\"><a href=\"#Mac-篇\" class=\"headerlink\" title=\"Mac 篇\"></a>Mac 篇</h2><h2 id=\"Alfred-篇\"><a href=\"#Alfred-篇\" class=\"headerlink\" title=\"Alfred 篇\"></a>Alfred 篇</h2><h2 id=\"Chrome-篇\"><a href=\"#Chrome-篇\" class=\"headerlink\" title=\"Chrome 篇\"></a>Chrome 篇</h2><h2 id=\"VSCODE-篇\"><a href=\"#VSCODE-篇\" class=\"headerlink\" title=\"VSCODE 篇\"></a>VSCODE 篇</h2><h2 id=\"iTerm2-篇\"><a href=\"#iTerm2-篇\" class=\"headerlink\" title=\"iTerm2 篇\"></a>iTerm2 篇</h2><h2 id=\"Alfred-with-Powerpack\"><a href=\"#Alfred-with-Powerpack\" class=\"headerlink\" title=\"Alfred with Powerpack\"></a>Alfred with Powerpack</h2><ul>\n<li>alfred-gitmoji-workflow<br><a href=\"https://github.com/Quilljou/alfred-gitmoji-workflow\" target=\"_blank\" rel=\"noopener\">alfred-gitmoji-workflow</a></li>\n</ul>\n<h2 id=\"iTerm2\"><a href=\"#iTerm2\" class=\"headerlink\" title=\"iTerm2\"></a>iTerm2</h2><h2 id=\"VSCODE\"><a href=\"#VSCODE\" class=\"headerlink\" title=\"VSCODE\"></a>VSCODE</h2><script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"excerpt":"","more":"<p>减少鼠标和键盘之间来回耗费的时间，使得绝大部分工作能够只使用键盘就能完成。</p>\n<h2 id=\"Mac-篇\"><a href=\"#Mac-篇\" class=\"headerlink\" title=\"Mac 篇\"></a>Mac 篇</h2><h2 id=\"Alfred-篇\"><a href=\"#Alfred-篇\" class=\"headerlink\" title=\"Alfred 篇\"></a>Alfred 篇</h2><h2 id=\"Chrome-篇\"><a href=\"#Chrome-篇\" class=\"headerlink\" title=\"Chrome 篇\"></a>Chrome 篇</h2><h2 id=\"VSCODE-篇\"><a href=\"#VSCODE-篇\" class=\"headerlink\" title=\"VSCODE 篇\"></a>VSCODE 篇</h2><h2 id=\"iTerm2-篇\"><a href=\"#iTerm2-篇\" class=\"headerlink\" title=\"iTerm2 篇\"></a>iTerm2 篇</h2><h2 id=\"Alfred-with-Powerpack\"><a href=\"#Alfred-with-Powerpack\" class=\"headerlink\" title=\"Alfred with Powerpack\"></a>Alfred with Powerpack</h2><ul>\n<li>alfred-gitmoji-workflow<br><a href=\"https://github.com/Quilljou/alfred-gitmoji-workflow\" target=\"_blank\" rel=\"noopener\">alfred-gitmoji-workflow</a></li>\n</ul>\n<h2 id=\"iTerm2\"><a href=\"#iTerm2\" class=\"headerlink\" title=\"iTerm2\"></a>iTerm2</h2><h2 id=\"VSCODE\"><a href=\"#VSCODE\" class=\"headerlink\" title=\"VSCODE\"></a>VSCODE</h2>"},{"title":"how-to-write-a-vscode-plugin","date":"2019-06-19T07:10:42.000Z","_content":"\nhttp://www.matthiassommer.it/programming/testing/run-npm-scripts-in-visual-studio-code-with-a-click-of-a-button/\n\n\nnpm.enableScriptExplorer","source":"_drafts/how-to-write-a-vscode-plugin.md","raw":"---\ntitle: how-to-write-a-vscode-plugin\ndate: 2019-06-19 15:10:42\ntags:\n---\n\nhttp://www.matthiassommer.it/programming/testing/run-npm-scripts-in-visual-studio-code-with-a-click-of-a-button/\n\n\nnpm.enableScriptExplorer","slug":"how-to-write-a-vscode-plugin","published":0,"updated":"2019-07-19T01:53:42.605Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhpu92x10008ak87r5njrk7x","content":"<p><a href=\"http://www.matthiassommer.it/programming/testing/run-npm-scripts-in-visual-studio-code-with-a-click-of-a-button/\" target=\"_blank\" rel=\"noopener\">http://www.matthiassommer.it/programming/testing/run-npm-scripts-in-visual-studio-code-with-a-click-of-a-button/</a></p>\n<p>npm.enableScriptExplorer</p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://www.matthiassommer.it/programming/testing/run-npm-scripts-in-visual-studio-code-with-a-click-of-a-button/\" target=\"_blank\" rel=\"noopener\">http://www.matthiassommer.it/programming/testing/run-npm-scripts-in-visual-studio-code-with-a-click-of-a-button/</a></p>\n<p>npm.enableScriptExplorer</p>\n"},{"title":"express","date":"2020-10-14T02:36:09.000Z","_content":"\n\n\n## 应用\n\n先使用 expres-generator 初始化一个 express 项目，看看一个 express server 运行功能有哪些？\n\n\n```\n├── app.js           # 应用入口\n├── bin\n│   └── www          # server 启动入口\n├── package.json\n├── public           # 静态资源\n│   ├── images\n│   ├── javascripts\n│   └── stylesheets\n│       └── style.css\n├── routes           # 控制器代码\n│   ├── index.js\n│   └── users.js\n└── views            # 视图代码\n    ├── error.jade\n    ├── index.jade\n    └── layout.jade\n```\n\n可以看出来这个项目里是一个缺少 M 层的 MVC 架构。从 server 启动入口开始\n\n```js\nvar app = require('../app');\nvar server = http.createServer(app);\n\nserver.listen(port);\nserver.on('error', onError);\nserver.on('listening', onListening);\n```\n\n核心代码调用就是这几行，使用 node 的 http 模块创建了一个 http server。app 是应用入口，我们可以从 http.createServer 的函数签名 `function createServer(requestListener?: RequestListener): Server;` 看出来 app 是一个 `RequestListener`, 具体的类型定义是 `type RequestListener = (req: IncomingMessage, res: ServerResponse) => void;`。根据 nodejs 官方文档对 http.createServer 的解释\n\n![alt](https://img10.360buyimg.com/jdphoto/jfs/t1/116330/38/20073/31068/5f866d4bE0497f679/350b79b24f257a89.png)\n\n\nRequestListener 会被作为 server 的 request 事件的回调函数，接收的参数分别是 `http.IncomingMessage` 和 `http.ServerResponse`，翻译成白话就是每一个 http 请求过来都会被 app 所处理。\n\n我们知道了 app 是一个函数类型，具体在 app.js 里执行了怎样的逻辑我们继续看。\n\n```js\nvar app = express();\n\n// view engine setup\napp.set('views', path.join(__dirname, 'views'));\napp.set('view engine', 'jade');\n\napp.use(logger('dev'));\napp.use(express.json());\napp.use(express.urlencoded({ extended: false }));\napp.use(cookieParser());\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use('/', indexRouter);\napp.use('/users', usersRouter);\n\n// catch 404 and forward to error handler\napp.use(function(req, res, next) {\n  next(createError(404));\n});\n\n// error handler\napp.use(function(err, req, res, next) {\n  // set locals, only providing error in development\n  res.locals.message = err.message;\n  res.locals.error = req.app.get('env') === 'development' ? err : {};\n\n  // render the error page\n  res.status(err.status || 500);\n  res.render('error');\n});\n\nmodule.exports = app;\n```\n\napp 是 express 函数的返回值，执行完后用 app 函数上挂载的一些方法进行了一系列配置，包括配置模板引擎，配置视图文件地址，配置 cookie 解析，配置路由等等那可以猜想 express 是一个闭包，返回了 RequestListener, 而且在 RequestListener 上挂载了很多方法和属性。具体是不是这样的就可以进入到 express 的源码部分了。我们知道 express 作为一个 web 框架，核心特性是可以设置中间件来响应 HTTP 请求、定义了路由表用于执行不同的 HTTP 请求动作、可以通过向模板传递参数来动态渲染 HTML 页面。那我们就带着疑问看看 express 具体是怎么实现这些功能的。\n\n\n\n## 入口\n\n```js\nvar mixin = require('merge-descriptors');\nvar proto = require('./application');\nvar req = require('./request');\nvar res = require('./response');\n\nexports = module.exports = createApplication;\n\n/**\n * Create an express application.\n *\n * @return {Function}\n * @api public\n */\n\nfunction createApplication() {\n  var app = function(req, res, next) {\n    app.handle(req, res, next);\n  };\n\n  mixin(app, EventEmitter.prototype, false);\n  mixin(app, proto, false);\n\n  // expose the prototype that will get set on requests\n  app.request = Object.create(req, {\n    app: { configurable: true, enumerable: true, writable: true, value: app }\n  })\n\n  // expose the prototype that will get set on responses\n  app.response = Object.create(res, {\n    app: { configurable: true, enumerable: true, writable: true, value: app }\n  })\n\n  app.init();\n  return app;\n}\n```\n\nexpress 模块默认导出的是 `createApplication` 方法。逐行来分析 `createApplication` 方法，第一行先声明了 `app` 方法，最后被作为返回值返回。那么 app 方法就是上文提到的传递给 `http.createServer` 的 `RequestListener`。当请求进入，`app` 方法被执行，实际执行的是 `app.handle` 方法，`handle` 方法的声明在后面会看到。\n\n在上节中我们看到 `app` 这个函数上挂载了 `use`、`set` 方法和刚刚看到的 `handle` 方法，那应该就是和 `mixin` 这两行相关，这两行分别混入了 node 的 `EventEmitter` 和 express 的核心实现 `proto`。即使不看 `mixin` 的实现，我们也能猜测出 `mixin` 方法是把原型对象的方法挂载在 app 函数上。我们找到提供 `mixin` 方法的 `merge-descriptors` 模块的源码来看看。\n\n```js\nmodule.exports = merge\n\n/**\n * Merge the property descriptors of `src` into `dest`\n *\n * @param {object} dest Object to add descriptors to\n * @param {object} src Object to clone descriptors from\n * @param {boolean} [redefine=true] Redefine `dest` properties with `src` properties\n * @returns {object} Reference to dest\n * @public\n */\nfunction merge(dest, src, redefine) {\n  Object.getOwnPropertyNames(src).forEach(function forEachOwnPropertyName(name) {\n    if (!redefine && hasOwnProperty.call(dest, name)) {\n      // Skip desriptor\n      return\n    }\n\n    // Copy descriptor\n    var descriptor = Object.getOwnPropertyDescriptor(src, name)\n    Object.defineProperty(dest, name, descriptor)\n  })\n\n  return dest\n}\n```\n可以看到 mixin（merge）方法就是将 src 的属性通过 getOwnPropertyDescriptor 和 defineProperty 实现拷贝到 dest。回到 express 中就是将EventEmitter.prototype 和 `application.js` 模块的所有方法拷贝到 app 函数。\n\n\n\n\n## Router\n\n\n## 参考\nhttps://www.runoob.com/nodejs/nodejs-express-framework.html\n\n\n\nRefactor\n\n## 中间件原理\n\n\n## express 在 http 的基础上还做了什么\n\n### 对 req/res 对象的扩展\n","source":"_drafts/how-express.md","raw":"---\ntitle: express\ndate: 2020-10-14 10:36:09\ntags:\n---\n\n\n\n## 应用\n\n先使用 expres-generator 初始化一个 express 项目，看看一个 express server 运行功能有哪些？\n\n\n```\n├── app.js           # 应用入口\n├── bin\n│   └── www          # server 启动入口\n├── package.json\n├── public           # 静态资源\n│   ├── images\n│   ├── javascripts\n│   └── stylesheets\n│       └── style.css\n├── routes           # 控制器代码\n│   ├── index.js\n│   └── users.js\n└── views            # 视图代码\n    ├── error.jade\n    ├── index.jade\n    └── layout.jade\n```\n\n可以看出来这个项目里是一个缺少 M 层的 MVC 架构。从 server 启动入口开始\n\n```js\nvar app = require('../app');\nvar server = http.createServer(app);\n\nserver.listen(port);\nserver.on('error', onError);\nserver.on('listening', onListening);\n```\n\n核心代码调用就是这几行，使用 node 的 http 模块创建了一个 http server。app 是应用入口，我们可以从 http.createServer 的函数签名 `function createServer(requestListener?: RequestListener): Server;` 看出来 app 是一个 `RequestListener`, 具体的类型定义是 `type RequestListener = (req: IncomingMessage, res: ServerResponse) => void;`。根据 nodejs 官方文档对 http.createServer 的解释\n\n![alt](https://img10.360buyimg.com/jdphoto/jfs/t1/116330/38/20073/31068/5f866d4bE0497f679/350b79b24f257a89.png)\n\n\nRequestListener 会被作为 server 的 request 事件的回调函数，接收的参数分别是 `http.IncomingMessage` 和 `http.ServerResponse`，翻译成白话就是每一个 http 请求过来都会被 app 所处理。\n\n我们知道了 app 是一个函数类型，具体在 app.js 里执行了怎样的逻辑我们继续看。\n\n```js\nvar app = express();\n\n// view engine setup\napp.set('views', path.join(__dirname, 'views'));\napp.set('view engine', 'jade');\n\napp.use(logger('dev'));\napp.use(express.json());\napp.use(express.urlencoded({ extended: false }));\napp.use(cookieParser());\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use('/', indexRouter);\napp.use('/users', usersRouter);\n\n// catch 404 and forward to error handler\napp.use(function(req, res, next) {\n  next(createError(404));\n});\n\n// error handler\napp.use(function(err, req, res, next) {\n  // set locals, only providing error in development\n  res.locals.message = err.message;\n  res.locals.error = req.app.get('env') === 'development' ? err : {};\n\n  // render the error page\n  res.status(err.status || 500);\n  res.render('error');\n});\n\nmodule.exports = app;\n```\n\napp 是 express 函数的返回值，执行完后用 app 函数上挂载的一些方法进行了一系列配置，包括配置模板引擎，配置视图文件地址，配置 cookie 解析，配置路由等等那可以猜想 express 是一个闭包，返回了 RequestListener, 而且在 RequestListener 上挂载了很多方法和属性。具体是不是这样的就可以进入到 express 的源码部分了。我们知道 express 作为一个 web 框架，核心特性是可以设置中间件来响应 HTTP 请求、定义了路由表用于执行不同的 HTTP 请求动作、可以通过向模板传递参数来动态渲染 HTML 页面。那我们就带着疑问看看 express 具体是怎么实现这些功能的。\n\n\n\n## 入口\n\n```js\nvar mixin = require('merge-descriptors');\nvar proto = require('./application');\nvar req = require('./request');\nvar res = require('./response');\n\nexports = module.exports = createApplication;\n\n/**\n * Create an express application.\n *\n * @return {Function}\n * @api public\n */\n\nfunction createApplication() {\n  var app = function(req, res, next) {\n    app.handle(req, res, next);\n  };\n\n  mixin(app, EventEmitter.prototype, false);\n  mixin(app, proto, false);\n\n  // expose the prototype that will get set on requests\n  app.request = Object.create(req, {\n    app: { configurable: true, enumerable: true, writable: true, value: app }\n  })\n\n  // expose the prototype that will get set on responses\n  app.response = Object.create(res, {\n    app: { configurable: true, enumerable: true, writable: true, value: app }\n  })\n\n  app.init();\n  return app;\n}\n```\n\nexpress 模块默认导出的是 `createApplication` 方法。逐行来分析 `createApplication` 方法，第一行先声明了 `app` 方法，最后被作为返回值返回。那么 app 方法就是上文提到的传递给 `http.createServer` 的 `RequestListener`。当请求进入，`app` 方法被执行，实际执行的是 `app.handle` 方法，`handle` 方法的声明在后面会看到。\n\n在上节中我们看到 `app` 这个函数上挂载了 `use`、`set` 方法和刚刚看到的 `handle` 方法，那应该就是和 `mixin` 这两行相关，这两行分别混入了 node 的 `EventEmitter` 和 express 的核心实现 `proto`。即使不看 `mixin` 的实现，我们也能猜测出 `mixin` 方法是把原型对象的方法挂载在 app 函数上。我们找到提供 `mixin` 方法的 `merge-descriptors` 模块的源码来看看。\n\n```js\nmodule.exports = merge\n\n/**\n * Merge the property descriptors of `src` into `dest`\n *\n * @param {object} dest Object to add descriptors to\n * @param {object} src Object to clone descriptors from\n * @param {boolean} [redefine=true] Redefine `dest` properties with `src` properties\n * @returns {object} Reference to dest\n * @public\n */\nfunction merge(dest, src, redefine) {\n  Object.getOwnPropertyNames(src).forEach(function forEachOwnPropertyName(name) {\n    if (!redefine && hasOwnProperty.call(dest, name)) {\n      // Skip desriptor\n      return\n    }\n\n    // Copy descriptor\n    var descriptor = Object.getOwnPropertyDescriptor(src, name)\n    Object.defineProperty(dest, name, descriptor)\n  })\n\n  return dest\n}\n```\n可以看到 mixin（merge）方法就是将 src 的属性通过 getOwnPropertyDescriptor 和 defineProperty 实现拷贝到 dest。回到 express 中就是将EventEmitter.prototype 和 `application.js` 模块的所有方法拷贝到 app 函数。\n\n\n\n\n## Router\n\n\n## 参考\nhttps://www.runoob.com/nodejs/nodejs-express-framework.html\n\n\n\nRefactor\n\n## 中间件原理\n\n\n## express 在 http 的基础上还做了什么\n\n### 对 req/res 对象的扩展\n","slug":"how-express","published":0,"updated":"2020-10-22T09:44:33.661Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhpu92x30009ak87kx75czve","content":"<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>先使用 expres-generator 初始化一个 express 项目，看看一个 express server 运行功能有哪些？</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── app.js           # 应用入口</span><br><span class=\"line\">├── bin</span><br><span class=\"line\">│   └── www          # server 启动入口</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── public           # 静态资源</span><br><span class=\"line\">│   ├── images</span><br><span class=\"line\">│   ├── javascripts</span><br><span class=\"line\">│   └── stylesheets</span><br><span class=\"line\">│       └── style.css</span><br><span class=\"line\">├── routes           # 控制器代码</span><br><span class=\"line\">│   ├── index.js</span><br><span class=\"line\">│   └── users.js</span><br><span class=\"line\">└── views            # 视图代码</span><br><span class=\"line\">    ├── error.jade</span><br><span class=\"line\">    ├── index.jade</span><br><span class=\"line\">    └── layout.jade</span><br></pre></td></tr></tbody></table></figure>\n<p>可以看出来这个项目里是一个缺少 M 层的 MVC 架构。从 server 启动入口开始</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"built_in\">require</span>(<span class=\"string\">'../app'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> server = http.createServer(app);</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(port);</span><br><span class=\"line\">server.on(<span class=\"string\">'error'</span>, onError);</span><br><span class=\"line\">server.on(<span class=\"string\">'listening'</span>, onListening);</span><br></pre></td></tr></tbody></table></figure>\n<p>核心代码调用就是这几行，使用 node 的 http 模块创建了一个 http server。app 是应用入口，我们可以从 http.createServer 的函数签名 <code>function createServer(requestListener?: RequestListener): Server;</code> 看出来 app 是一个 <code>RequestListener</code>, 具体的类型定义是 <code>type RequestListener = (req: IncomingMessage, res: ServerResponse) => void;</code>。根据 nodejs 官方文档对 http.createServer 的解释</p>\n<p><img src=\"https://img10.360buyimg.com/jdphoto/jfs/t1/116330/38/20073/31068/5f866d4bE0497f679/350b79b24f257a89.png\" alt=\"alt\"></p>\n<p>RequestListener 会被作为 server 的 request 事件的回调函数，接收的参数分别是 <code>http.IncomingMessage</code> 和 <code>http.ServerResponse</code>，翻译成白话就是每一个 http 请求过来都会被 app 所处理。</p>\n<p>我们知道了 app 是一个函数类型，具体在 app.js 里执行了怎样的逻辑我们继续看。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = express();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// view engine setup</span></span><br><span class=\"line\">app.set(<span class=\"string\">'views'</span>, path.join(__dirname, <span class=\"string\">'views'</span>));</span><br><span class=\"line\">app.set(<span class=\"string\">'view engine'</span>, <span class=\"string\">'jade'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(logger(<span class=\"string\">'dev'</span>));</span><br><span class=\"line\">app.use(express.json());</span><br><span class=\"line\">app.use(express.urlencoded({ <span class=\"attr\">extended</span>: <span class=\"literal\">false</span> }));</span><br><span class=\"line\">app.use(cookieParser());</span><br><span class=\"line\">app.use(express.static(path.join(__dirname, <span class=\"string\">'public'</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"string\">'/'</span>, indexRouter);</span><br><span class=\"line\">app.use(<span class=\"string\">'/users'</span>, usersRouter);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// catch 404 and forward to error handler</span></span><br><span class=\"line\">app.use(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>{</span><br><span class=\"line\">  next(createError(<span class=\"number\">404</span>));</span><br><span class=\"line\">});</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// error handler</span></span><br><span class=\"line\">app.use(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, req, res, next</span>) </span>{</span><br><span class=\"line\">  <span class=\"comment\">// set locals, only providing error in development</span></span><br><span class=\"line\">  res.locals.message = err.message;</span><br><span class=\"line\">  res.locals.error = req.app.get(<span class=\"string\">'env'</span>) === <span class=\"string\">'development'</span> ? err : {};</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// render the error page</span></span><br><span class=\"line\">  res.status(err.status || <span class=\"number\">500</span>);</span><br><span class=\"line\">  res.render(<span class=\"string\">'error'</span>);</span><br><span class=\"line\">});</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = app;</span><br></pre></td></tr></tbody></table></figure>\n<p>app 是 express 函数的返回值，执行完后用 app 函数上挂载的一些方法进行了一系列配置，包括配置模板引擎，配置视图文件地址，配置 cookie 解析，配置路由等等那可以猜想 express 是一个闭包，返回了 RequestListener, 而且在 RequestListener 上挂载了很多方法和属性。具体是不是这样的就可以进入到 express 的源码部分了。我们知道 express 作为一个 web 框架，核心特性是可以设置中间件来响应 HTTP 请求、定义了路由表用于执行不同的 HTTP 请求动作、可以通过向模板传递参数来动态渲染 HTML 页面。那我们就带着疑问看看 express 具体是怎么实现这些功能的。</p>\n<h2 id=\"入口\"><a href=\"#入口\" class=\"headerlink\" title=\"入口\"></a>入口</h2><figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mixin = <span class=\"built_in\">require</span>(<span class=\"string\">'merge-descriptors'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> proto = <span class=\"built_in\">require</span>(<span class=\"string\">'./application'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> req = <span class=\"built_in\">require</span>(<span class=\"string\">'./request'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> res = <span class=\"built_in\">require</span>(<span class=\"string\">'./response'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">exports = <span class=\"built_in\">module</span>.exports = createApplication;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Create an express application.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @return {Function}</span></span><br><span class=\"line\"><span class=\"comment\"> * @api public</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createApplication</span>(<span class=\"params\"></span>) </span>{</span><br><span class=\"line\">  <span class=\"keyword\">var</span> app = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>{</span><br><span class=\"line\">    app.handle(req, res, next);</span><br><span class=\"line\">  };</span><br><span class=\"line\"></span><br><span class=\"line\">  mixin(app, EventEmitter.prototype, <span class=\"literal\">false</span>);</span><br><span class=\"line\">  mixin(app, proto, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// expose the prototype that will get set on requests</span></span><br><span class=\"line\">  app.request = <span class=\"built_in\">Object</span>.create(req, {</span><br><span class=\"line\">    app: { <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>, <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span>, <span class=\"attr\">writable</span>: <span class=\"literal\">true</span>, <span class=\"attr\">value</span>: app }</span><br><span class=\"line\">  })</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// expose the prototype that will get set on responses</span></span><br><span class=\"line\">  app.response = <span class=\"built_in\">Object</span>.create(res, {</span><br><span class=\"line\">    app: { <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>, <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span>, <span class=\"attr\">writable</span>: <span class=\"literal\">true</span>, <span class=\"attr\">value</span>: app }</span><br><span class=\"line\">  })</span><br><span class=\"line\"></span><br><span class=\"line\">  app.init();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> app;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>express 模块默认导出的是 <code>createApplication</code> 方法。逐行来分析 <code>createApplication</code> 方法，第一行先声明了 <code>app</code> 方法，最后被作为返回值返回。那么 app 方法就是上文提到的传递给 <code>http.createServer</code> 的 <code>RequestListener</code>。当请求进入，<code>app</code> 方法被执行，实际执行的是 <code>app.handle</code> 方法，<code>handle</code> 方法的声明在后面会看到。</p>\n<p>在上节中我们看到 <code>app</code> 这个函数上挂载了 <code>use</code>、<code>set</code> 方法和刚刚看到的 <code>handle</code> 方法，那应该就是和 <code>mixin</code> 这两行相关，这两行分别混入了 node 的 <code>EventEmitter</code> 和 express 的核心实现 <code>proto</code>。即使不看 <code>mixin</code> 的实现，我们也能猜测出 <code>mixin</code> 方法是把原型对象的方法挂载在 app 函数上。我们找到提供 <code>mixin</code> 方法的 <code>merge-descriptors</code> 模块的源码来看看。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = merge</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Merge the property descriptors of `src` into `dest`</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @param {object} dest Object to add descriptors to</span></span><br><span class=\"line\"><span class=\"comment\"> * @param {object} src Object to clone descriptors from</span></span><br><span class=\"line\"><span class=\"comment\"> * @param {boolean} [redefine=true] Redefine `dest` properties with `src` properties</span></span><br><span class=\"line\"><span class=\"comment\"> * @returns {object} Reference to dest</span></span><br><span class=\"line\"><span class=\"comment\"> * @public</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">merge</span>(<span class=\"params\">dest, src, redefine</span>) </span>{</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.getOwnPropertyNames(src).forEach(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">forEachOwnPropertyName</span>(<span class=\"params\">name</span>) </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!redefine && hasOwnProperty.call(dest, name)) {</span><br><span class=\"line\">      <span class=\"comment\">// Skip desriptor</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Copy descriptor</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> descriptor = <span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(src, name)</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(dest, name, descriptor)</span><br><span class=\"line\">  })</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> dest</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>可以看到 mixin（merge）方法就是将 src 的属性通过 getOwnPropertyDescriptor 和 defineProperty 实现拷贝到 dest。回到 express 中就是将EventEmitter.prototype 和 <code>application.js</code> 模块的所有方法拷贝到 app 函数。</p>\n<h2 id=\"Router\"><a href=\"#Router\" class=\"headerlink\" title=\"Router\"></a>Router</h2><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.runoob.com/nodejs/nodejs-express-framework.html\" target=\"_blank\" rel=\"noopener\">https://www.runoob.com/nodejs/nodejs-express-framework.html</a></p>\n<p>Refactor</p>\n<h2 id=\"中间件原理\"><a href=\"#中间件原理\" class=\"headerlink\" title=\"中间件原理\"></a>中间件原理</h2><h2 id=\"express-在-http-的基础上还做了什么\"><a href=\"#express-在-http-的基础上还做了什么\" class=\"headerlink\" title=\"express 在 http 的基础上还做了什么\"></a>express 在 http 的基础上还做了什么</h2><h3 id=\"对-req-res-对象的扩展\"><a href=\"#对-req-res-对象的扩展\" class=\"headerlink\" title=\"对 req/res 对象的扩展\"></a>对 req/res 对象的扩展</h3><script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>先使用 expres-generator 初始化一个 express 项目，看看一个 express server 运行功能有哪些？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── app.js           # 应用入口</span><br><span class=\"line\">├── bin</span><br><span class=\"line\">│   └── www          # server 启动入口</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── public           # 静态资源</span><br><span class=\"line\">│   ├── images</span><br><span class=\"line\">│   ├── javascripts</span><br><span class=\"line\">│   └── stylesheets</span><br><span class=\"line\">│       └── style.css</span><br><span class=\"line\">├── routes           # 控制器代码</span><br><span class=\"line\">│   ├── index.js</span><br><span class=\"line\">│   └── users.js</span><br><span class=\"line\">└── views            # 视图代码</span><br><span class=\"line\">    ├── error.jade</span><br><span class=\"line\">    ├── index.jade</span><br><span class=\"line\">    └── layout.jade</span><br></pre></td></tr></table></figure>\n<p>可以看出来这个项目里是一个缺少 M 层的 MVC 架构。从 server 启动入口开始</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"built_in\">require</span>(<span class=\"string\">'../app'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> server = http.createServer(app);</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(port);</span><br><span class=\"line\">server.on(<span class=\"string\">'error'</span>, onError);</span><br><span class=\"line\">server.on(<span class=\"string\">'listening'</span>, onListening);</span><br></pre></td></tr></table></figure>\n<p>核心代码调用就是这几行，使用 node 的 http 模块创建了一个 http server。app 是应用入口，我们可以从 http.createServer 的函数签名 <code>function createServer(requestListener?: RequestListener): Server;</code> 看出来 app 是一个 <code>RequestListener</code>, 具体的类型定义是 <code>type RequestListener = (req: IncomingMessage, res: ServerResponse) =&gt; void;</code>。根据 nodejs 官方文档对 http.createServer 的解释</p>\n<p><img src=\"https://img10.360buyimg.com/jdphoto/jfs/t1/116330/38/20073/31068/5f866d4bE0497f679/350b79b24f257a89.png\" alt=\"alt\"></p>\n<p>RequestListener 会被作为 server 的 request 事件的回调函数，接收的参数分别是 <code>http.IncomingMessage</code> 和 <code>http.ServerResponse</code>，翻译成白话就是每一个 http 请求过来都会被 app 所处理。</p>\n<p>我们知道了 app 是一个函数类型，具体在 app.js 里执行了怎样的逻辑我们继续看。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = express();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// view engine setup</span></span><br><span class=\"line\">app.set(<span class=\"string\">'views'</span>, path.join(__dirname, <span class=\"string\">'views'</span>));</span><br><span class=\"line\">app.set(<span class=\"string\">'view engine'</span>, <span class=\"string\">'jade'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(logger(<span class=\"string\">'dev'</span>));</span><br><span class=\"line\">app.use(express.json());</span><br><span class=\"line\">app.use(express.urlencoded(&#123; <span class=\"attr\">extended</span>: <span class=\"literal\">false</span> &#125;));</span><br><span class=\"line\">app.use(cookieParser());</span><br><span class=\"line\">app.use(express.static(path.join(__dirname, <span class=\"string\">'public'</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"string\">'/'</span>, indexRouter);</span><br><span class=\"line\">app.use(<span class=\"string\">'/users'</span>, usersRouter);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// catch 404 and forward to error handler</span></span><br><span class=\"line\">app.use(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">  next(createError(<span class=\"number\">404</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// error handler</span></span><br><span class=\"line\">app.use(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, req, res, next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// set locals, only providing error in development</span></span><br><span class=\"line\">  res.locals.message = err.message;</span><br><span class=\"line\">  res.locals.error = req.app.get(<span class=\"string\">'env'</span>) === <span class=\"string\">'development'</span> ? err : &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// render the error page</span></span><br><span class=\"line\">  res.status(err.status || <span class=\"number\">500</span>);</span><br><span class=\"line\">  res.render(<span class=\"string\">'error'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = app;</span><br></pre></td></tr></table></figure>\n<p>app 是 express 函数的返回值，执行完后用 app 函数上挂载的一些方法进行了一系列配置，包括配置模板引擎，配置视图文件地址，配置 cookie 解析，配置路由等等那可以猜想 express 是一个闭包，返回了 RequestListener, 而且在 RequestListener 上挂载了很多方法和属性。具体是不是这样的就可以进入到 express 的源码部分了。我们知道 express 作为一个 web 框架，核心特性是可以设置中间件来响应 HTTP 请求、定义了路由表用于执行不同的 HTTP 请求动作、可以通过向模板传递参数来动态渲染 HTML 页面。那我们就带着疑问看看 express 具体是怎么实现这些功能的。</p>\n<h2 id=\"入口\"><a href=\"#入口\" class=\"headerlink\" title=\"入口\"></a>入口</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mixin = <span class=\"built_in\">require</span>(<span class=\"string\">'merge-descriptors'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> proto = <span class=\"built_in\">require</span>(<span class=\"string\">'./application'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> req = <span class=\"built_in\">require</span>(<span class=\"string\">'./request'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> res = <span class=\"built_in\">require</span>(<span class=\"string\">'./response'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">exports = <span class=\"built_in\">module</span>.exports = createApplication;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Create an express application.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;Function&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * @api public</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createApplication</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> app = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">    app.handle(req, res, next);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  mixin(app, EventEmitter.prototype, <span class=\"literal\">false</span>);</span><br><span class=\"line\">  mixin(app, proto, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// expose the prototype that will get set on requests</span></span><br><span class=\"line\">  app.request = <span class=\"built_in\">Object</span>.create(req, &#123;</span><br><span class=\"line\">    app: &#123; <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>, <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span>, <span class=\"attr\">writable</span>: <span class=\"literal\">true</span>, <span class=\"attr\">value</span>: app &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// expose the prototype that will get set on responses</span></span><br><span class=\"line\">  app.response = <span class=\"built_in\">Object</span>.create(res, &#123;</span><br><span class=\"line\">    app: &#123; <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>, <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span>, <span class=\"attr\">writable</span>: <span class=\"literal\">true</span>, <span class=\"attr\">value</span>: app &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  app.init();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> app;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>express 模块默认导出的是 <code>createApplication</code> 方法。逐行来分析 <code>createApplication</code> 方法，第一行先声明了 <code>app</code> 方法，最后被作为返回值返回。那么 app 方法就是上文提到的传递给 <code>http.createServer</code> 的 <code>RequestListener</code>。当请求进入，<code>app</code> 方法被执行，实际执行的是 <code>app.handle</code> 方法，<code>handle</code> 方法的声明在后面会看到。</p>\n<p>在上节中我们看到 <code>app</code> 这个函数上挂载了 <code>use</code>、<code>set</code> 方法和刚刚看到的 <code>handle</code> 方法，那应该就是和 <code>mixin</code> 这两行相关，这两行分别混入了 node 的 <code>EventEmitter</code> 和 express 的核心实现 <code>proto</code>。即使不看 <code>mixin</code> 的实现，我们也能猜测出 <code>mixin</code> 方法是把原型对象的方法挂载在 app 函数上。我们找到提供 <code>mixin</code> 方法的 <code>merge-descriptors</code> 模块的源码来看看。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = merge</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Merge the property descriptors of `src` into `dest`</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;object&#125; dest Object to add descriptors to</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;object&#125; src Object to clone descriptors from</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;boolean&#125; [redefine=true] Redefine `dest` properties with `src` properties</span></span><br><span class=\"line\"><span class=\"comment\"> * @returns &#123;object&#125; Reference to dest</span></span><br><span class=\"line\"><span class=\"comment\"> * @public</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">merge</span>(<span class=\"params\">dest, src, redefine</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.getOwnPropertyNames(src).forEach(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">forEachOwnPropertyName</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!redefine &amp;&amp; hasOwnProperty.call(dest, name)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Skip desriptor</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Copy descriptor</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> descriptor = <span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(src, name)</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(dest, name, descriptor)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> dest</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到 mixin（merge）方法就是将 src 的属性通过 getOwnPropertyDescriptor 和 defineProperty 实现拷贝到 dest。回到 express 中就是将EventEmitter.prototype 和 <code>application.js</code> 模块的所有方法拷贝到 app 函数。</p>\n<h2 id=\"Router\"><a href=\"#Router\" class=\"headerlink\" title=\"Router\"></a>Router</h2><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.runoob.com/nodejs/nodejs-express-framework.html\" target=\"_blank\" rel=\"noopener\">https://www.runoob.com/nodejs/nodejs-express-framework.html</a></p>\n<p>Refactor</p>\n<h2 id=\"中间件原理\"><a href=\"#中间件原理\" class=\"headerlink\" title=\"中间件原理\"></a>中间件原理</h2><h2 id=\"express-在-http-的基础上还做了什么\"><a href=\"#express-在-http-的基础上还做了什么\" class=\"headerlink\" title=\"express 在 http 的基础上还做了什么\"></a>express 在 http 的基础上还做了什么</h2><h3 id=\"对-req-res-对象的扩展\"><a href=\"#对-req-res-对象的扩展\" class=\"headerlink\" title=\"对 req/res 对象的扩展\"></a>对 req/res 对象的扩展</h3>"},{"title":"小程序工程化","_content":"\n\n\n\nwebpack 的模型就是给定一个 js 入口，webpack 进行依赖分析，对每个不同的模块（文件）使用配置的 loader 进行处理（具体怎么处理？输入什么，返回什么，返回到哪里），webpack 是使用 tapable 驱动的核心-插件式架构。可以在webpack的各个处理流程添加插件。\n\n为了使 webpack 能够处理小程序项目。首先需要解析 app.json ，将配置的页面 page.js 和页面相应的 page.css/sass, page.json, page.wxml（因为这些不是引入到 js 里的）都 require 到一个入口文件。然后为 css/scss 使用 loader 进行处理，为 json/js 使用 loader, 使用 wxml-loader 。在 emit 时所有内容输出到 dist 目录。通过接入 webpack，就意味着接入了整个 webpack 的生态。比如说可以做 js/css 的tree-shaking (怎么做?)\n\nwxa build 执行链路\n- 初始化 Context：挂载公共api、处理配置、初始化钩子、挂载插件\n- 依次执行钩子\n\n## Tapable","source":"_drafts/mp-webpack.md","raw":"---\ntitle: 小程序工程化\ntags:\n---\n\n\n\n\nwebpack 的模型就是给定一个 js 入口，webpack 进行依赖分析，对每个不同的模块（文件）使用配置的 loader 进行处理（具体怎么处理？输入什么，返回什么，返回到哪里），webpack 是使用 tapable 驱动的核心-插件式架构。可以在webpack的各个处理流程添加插件。\n\n为了使 webpack 能够处理小程序项目。首先需要解析 app.json ，将配置的页面 page.js 和页面相应的 page.css/sass, page.json, page.wxml（因为这些不是引入到 js 里的）都 require 到一个入口文件。然后为 css/scss 使用 loader 进行处理，为 json/js 使用 loader, 使用 wxml-loader 。在 emit 时所有内容输出到 dist 目录。通过接入 webpack，就意味着接入了整个 webpack 的生态。比如说可以做 js/css 的tree-shaking (怎么做?)\n\nwxa build 执行链路\n- 初始化 Context：挂载公共api、处理配置、初始化钩子、挂载插件\n- 依次执行钩子\n\n## Tapable","slug":"mp-webpack","published":0,"date":"2020-07-31T08:50:31.501Z","updated":"2020-08-05T02:26:45.242Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhpu92x8000aak87pzt41y3p","content":"<p>webpack 的模型就是给定一个 js 入口，webpack 进行依赖分析，对每个不同的模块（文件）使用配置的 loader 进行处理（具体怎么处理？输入什么，返回什么，返回到哪里），webpack 是使用 tapable 驱动的核心-插件式架构。可以在webpack的各个处理流程添加插件。</p>\n<p>为了使 webpack 能够处理小程序项目。首先需要解析 app.json ，将配置的页面 page.js 和页面相应的 page.css/sass, page.json, page.wxml（因为这些不是引入到 js 里的）都 require 到一个入口文件。然后为 css/scss 使用 loader 进行处理，为 json/js 使用 loader, 使用 wxml-loader 。在 emit 时所有内容输出到 dist 目录。通过接入 webpack，就意味着接入了整个 webpack 的生态。比如说可以做 js/css 的tree-shaking (怎么做?)</p>\n<p>wxa build 执行链路</p>\n<ul>\n<li>初始化 Context：挂载公共api、处理配置、初始化钩子、挂载插件</li>\n<li>依次执行钩子</li>\n</ul>\n<h2 id=\"Tapable\"><a href=\"#Tapable\" class=\"headerlink\" title=\"Tapable\"></a>Tapable</h2><script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"excerpt":"","more":"<p>webpack 的模型就是给定一个 js 入口，webpack 进行依赖分析，对每个不同的模块（文件）使用配置的 loader 进行处理（具体怎么处理？输入什么，返回什么，返回到哪里），webpack 是使用 tapable 驱动的核心-插件式架构。可以在webpack的各个处理流程添加插件。</p>\n<p>为了使 webpack 能够处理小程序项目。首先需要解析 app.json ，将配置的页面 page.js 和页面相应的 page.css/sass, page.json, page.wxml（因为这些不是引入到 js 里的）都 require 到一个入口文件。然后为 css/scss 使用 loader 进行处理，为 json/js 使用 loader, 使用 wxml-loader 。在 emit 时所有内容输出到 dist 目录。通过接入 webpack，就意味着接入了整个 webpack 的生态。比如说可以做 js/css 的tree-shaking (怎么做?)</p>\n<p>wxa build 执行链路</p>\n<ul>\n<li>初始化 Context：挂载公共api、处理配置、初始化钩子、挂载插件</li>\n<li>依次执行钩子</li>\n</ul>\n<h2 id=\"Tapable\"><a href=\"#Tapable\" class=\"headerlink\" title=\"Tapable\"></a>Tapable</h2>"},{"title":"rollup+ts+react+babel","date":"2019-02-14T03:23:25.000Z","_content":"","source":"_drafts/rollup-ts-react-babel.md","raw":"---\ntitle: rollup+ts+react+babel\ndate: 2019-02-14 11:23:25\ntags:\n---\n","slug":"rollup-ts-react-babel","published":0,"updated":"2019-07-19T01:53:42.605Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhpu92xc000bak875s3ffkpc","content":"<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"excerpt":"","more":""},{"title":"test-react-component-with-jest-and-enzyme","date":"2019-03-14T06:35:52.000Z","_content":"","source":"_drafts/test-react-component-with-jest-and-enzyme.md","raw":"---\ntitle: test-react-component-with-jest-and-enzyme\ndate: 2019-03-14 14:35:52\ntags:\n---\n","slug":"test-react-component-with-jest-and-enzyme","published":0,"updated":"2019-07-19T01:53:42.606Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhpu92xd000cak876249lnz0","content":"<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"excerpt":"","more":""},{"title":"typescript-in-action","date":"2019-07-24T13:34:48.000Z","_content":"\n## 对象\ndelete Object.xxx vs Record<x,x> vs new Map<x,x>;\n\n## 返回值 和 可入修饰符","source":"_drafts/typescript-in-action.md","raw":"---\ntitle: typescript-in-action\ndate: 2019-07-24 21:34:48\ntags:\n---\n\n## 对象\ndelete Object.xxx vs Record<x,x> vs new Map<x,x>;\n\n## 返回值 和 可入修饰符","slug":"typescript-in-action","published":0,"updated":"2019-10-09T09:48:06.369Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhpu92xe000dak87kiykg9bd","content":"<h2 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h2><p>delete Object.xxx vs Record<x,x> vs new Map<x,x>;</p>\n<h2 id=\"返回值-和-可入修饰符\"><a href=\"#返回值-和-可入修饰符\" class=\"headerlink\" title=\"返回值 和 可入修饰符\"></a>返回值 和 可入修饰符</h2><script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h2><p>delete Object.xxx vs Record&lt;x,x&gt; vs new Map&lt;x,x&gt;;</p>\n<h2 id=\"返回值-和-可入修饰符\"><a href=\"#返回值-和-可入修饰符\" class=\"headerlink\" title=\"返回值 和 可入修饰符\"></a>返回值 和 可入修饰符</h2>"},{"title":"inherit","date":"2020-10-16T09:06:22.000Z","_content":"\n\n在阅读 express 源码的过程中（req,res 的扩展）被一个 JS 继承的知识点给阻碍了，平时都是使用 es6 extends 关键字，对 JS es5 的面向对象有所生疏了，所以先抛下源码重新复习下 JS es5 实现继承的各个知识点。\n\n现在基本是组合构造函数模式和原型模式\n\n## 构造函数\n\n构造函数创建对象的执行过程\n\n1. 创建一个新对象\n2. 将构造函数的作用域赋给这个新对象\n3. 执行构造函数\n4. 如果有Object类型的返回值，则返回这个返回值，否则就返回创建的新对象\n\n假设有构造函数 F。创建出来的对象的 `__proto__` 属性指向\n\n## Object.create()\n创建一个对象并返回。这个对象的原型是传入的第一个参数。第二个参数用于对该对象执行 Object.defineProperties()\n\n## setPrototypeof\n\n\n## instanceOf","source":"_drafts/oop.md","raw":"---\ntitle: inherit\ndate: 2020-10-16 17:06:22\ntags:\n---\n\n\n在阅读 express 源码的过程中（req,res 的扩展）被一个 JS 继承的知识点给阻碍了，平时都是使用 es6 extends 关键字，对 JS es5 的面向对象有所生疏了，所以先抛下源码重新复习下 JS es5 实现继承的各个知识点。\n\n现在基本是组合构造函数模式和原型模式\n\n## 构造函数\n\n构造函数创建对象的执行过程\n\n1. 创建一个新对象\n2. 将构造函数的作用域赋给这个新对象\n3. 执行构造函数\n4. 如果有Object类型的返回值，则返回这个返回值，否则就返回创建的新对象\n\n假设有构造函数 F。创建出来的对象的 `__proto__` 属性指向\n\n## Object.create()\n创建一个对象并返回。这个对象的原型是传入的第一个参数。第二个参数用于对该对象执行 Object.defineProperties()\n\n## setPrototypeof\n\n\n## instanceOf","slug":"oop","published":0,"updated":"2020-11-10T09:26:28.263Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhpu92xf000eak87jwcwh9lr","content":"<p>在阅读 express 源码的过程中（req,res 的扩展）被一个 JS 继承的知识点给阻碍了，平时都是使用 es6 extends 关键字，对 JS es5 的面向对象有所生疏了，所以先抛下源码重新复习下 JS es5 实现继承的各个知识点。</p>\n<p>现在基本是组合构造函数模式和原型模式</p>\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><p>构造函数创建对象的执行过程</p>\n<ol>\n<li>创建一个新对象</li>\n<li>将构造函数的作用域赋给这个新对象</li>\n<li>执行构造函数</li>\n<li>如果有Object类型的返回值，则返回这个返回值，否则就返回创建的新对象</li>\n</ol>\n<p>假设有构造函数 F。创建出来的对象的 <code>__proto__</code> 属性指向</p>\n<h2 id=\"Object-create\"><a href=\"#Object-create\" class=\"headerlink\" title=\"Object.create()\"></a>Object.create()</h2><p>创建一个对象并返回。这个对象的原型是传入的第一个参数。第二个参数用于对该对象执行 Object.defineProperties()</p>\n<h2 id=\"setPrototypeof\"><a href=\"#setPrototypeof\" class=\"headerlink\" title=\"setPrototypeof\"></a>setPrototypeof</h2><h2 id=\"instanceOf\"><a href=\"#instanceOf\" class=\"headerlink\" title=\"instanceOf\"></a>instanceOf</h2><script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"excerpt":"","more":"<p>在阅读 express 源码的过程中（req,res 的扩展）被一个 JS 继承的知识点给阻碍了，平时都是使用 es6 extends 关键字，对 JS es5 的面向对象有所生疏了，所以先抛下源码重新复习下 JS es5 实现继承的各个知识点。</p>\n<p>现在基本是组合构造函数模式和原型模式</p>\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><p>构造函数创建对象的执行过程</p>\n<ol>\n<li>创建一个新对象</li>\n<li>将构造函数的作用域赋给这个新对象</li>\n<li>执行构造函数</li>\n<li>如果有Object类型的返回值，则返回这个返回值，否则就返回创建的新对象</li>\n</ol>\n<p>假设有构造函数 F。创建出来的对象的 <code>__proto__</code> 属性指向</p>\n<h2 id=\"Object-create\"><a href=\"#Object-create\" class=\"headerlink\" title=\"Object.create()\"></a>Object.create()</h2><p>创建一个对象并返回。这个对象的原型是传入的第一个参数。第二个参数用于对该对象执行 Object.defineProperties()</p>\n<h2 id=\"setPrototypeof\"><a href=\"#setPrototypeof\" class=\"headerlink\" title=\"setPrototypeof\"></a>setPrototypeof</h2><h2 id=\"instanceOf\"><a href=\"#instanceOf\" class=\"headerlink\" title=\"instanceOf\"></a>instanceOf</h2>"},{"title":"Webpack 配置工程师之路 - （一）搭建Vue组件库脚手架","_content":"\n> 也许 Gulp 更合适\n\n回顾 26 个 commit\n\n## 设想\n预想的工作方式从 npm scripts 开始\n\n- 本地开发和调试\n\n```sh\nyarn dev \n```\n\n打包编译组件库\n```sh\nyarn component\n```\n\n发布到私服\n```sh\nyarn release\n```\n\n本地调试文档\n\n```sh\nyarn docs:dev\n```\n\n打包文档网站\n```sh\nyarn docs:build\n```\n\n发布文档网站\n```sh\nyarn docs:deploy\n```\n\n如何用 Webpack 来搭建这样一套时尚的 workflow。\n\n## 搭建\n\n先来看下最后的目录结构\n\n```\n├── README.md\n├── dist # 文档生产环境输出目录\n├── docs # 文档源码\n├── lib # 组件输出目录\n│   ├── button # 按需加载 js 组件\n│   ├── checkbox\n│   ├── ...\n│   ├── index # 全部组件 js\n│   └── theme-ca\n│        ├── button # 对应按需加载的组件 css\n│        ├── checkbox\n│        ├── ...\n│        └── index # 全部组件 css\n├── scripts # 构建脚本\n├── src # 组件源码\n│   ├── assets # icon 等\n│   ├── common # 公共 js\n│   ├── components # 组件源码\n│   ├── directives # 指令\n│   ├── index.js\n│   └── stylesheets # 样式源码\n├── package.json\n└── test # 测试目录，Todo\n```\n\n\n### yarn dev\n\n基于 webpack 4.x 和 babel 7\n\n在开发环境，首先明确明确我们的输入输出是什么。\n\n我是在开发一个基于 Vue 的组件库，所以编写的源代码是 Vue 组件。输入就是 Vue 组件。输出就是一个 playground 用于调试我们开发的组件。\n\nWebpack 的几个基本概念是 entry, output, loader, plugin。\n\n\n使用 webpack-dev-server 启动一个服务用于调试和预览组件。\n关于样式。在这个环境下除了组件自身的样式不应该有其余的样式来干扰我们开发组件的样式。然而在实际运用中，这个组件的自身样式也应该足够的健壮，不会轻易被外部的样式覆盖，但也要保证可定制化，能够在需要客制化样式的时候覆盖组件的自身样式。\n\n\n\n\n## 样式系统重构\n\n## 踩坑\n\n\n\n## Todo\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_drafts/webpack-series-one.md","raw":"---\ntitle: Webpack 配置工程师之路 - （一）搭建Vue组件库脚手架\n---\n\n> 也许 Gulp 更合适\n\n回顾 26 个 commit\n\n## 设想\n预想的工作方式从 npm scripts 开始\n\n- 本地开发和调试\n\n```sh\nyarn dev \n```\n\n打包编译组件库\n```sh\nyarn component\n```\n\n发布到私服\n```sh\nyarn release\n```\n\n本地调试文档\n\n```sh\nyarn docs:dev\n```\n\n打包文档网站\n```sh\nyarn docs:build\n```\n\n发布文档网站\n```sh\nyarn docs:deploy\n```\n\n如何用 Webpack 来搭建这样一套时尚的 workflow。\n\n## 搭建\n\n先来看下最后的目录结构\n\n```\n├── README.md\n├── dist # 文档生产环境输出目录\n├── docs # 文档源码\n├── lib # 组件输出目录\n│   ├── button # 按需加载 js 组件\n│   ├── checkbox\n│   ├── ...\n│   ├── index # 全部组件 js\n│   └── theme-ca\n│        ├── button # 对应按需加载的组件 css\n│        ├── checkbox\n│        ├── ...\n│        └── index # 全部组件 css\n├── scripts # 构建脚本\n├── src # 组件源码\n│   ├── assets # icon 等\n│   ├── common # 公共 js\n│   ├── components # 组件源码\n│   ├── directives # 指令\n│   ├── index.js\n│   └── stylesheets # 样式源码\n├── package.json\n└── test # 测试目录，Todo\n```\n\n\n### yarn dev\n\n基于 webpack 4.x 和 babel 7\n\n在开发环境，首先明确明确我们的输入输出是什么。\n\n我是在开发一个基于 Vue 的组件库，所以编写的源代码是 Vue 组件。输入就是 Vue 组件。输出就是一个 playground 用于调试我们开发的组件。\n\nWebpack 的几个基本概念是 entry, output, loader, plugin。\n\n\n使用 webpack-dev-server 启动一个服务用于调试和预览组件。\n关于样式。在这个环境下除了组件自身的样式不应该有其余的样式来干扰我们开发组件的样式。然而在实际运用中，这个组件的自身样式也应该足够的健壮，不会轻易被外部的样式覆盖，但也要保证可定制化，能够在需要客制化样式的时候覆盖组件的自身样式。\n\n\n\n\n## 样式系统重构\n\n## 踩坑\n\n\n\n## Todo\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"webpack-series-one","published":0,"date":"2019-07-19T01:53:42.606Z","updated":"2019-07-19T01:53:42.606Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhpu92xg000fak87bha4rkfk","content":"<blockquote>\n<p>也许 Gulp 更合适</p>\n</blockquote>\n<p>回顾 26 个 commit</p>\n<h2 id=\"设想\"><a href=\"#设想\" class=\"headerlink\" title=\"设想\"></a>设想</h2><p>预想的工作方式从 npm scripts 开始</p>\n<ul>\n<li>本地开发和调试</li>\n</ul>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn dev</span><br></pre></td></tr></tbody></table></figure>\n<p>打包编译组件库<br></p><figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn component</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>发布到私服<br></p><figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn release</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>本地调试文档</p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn docs:dev</span><br></pre></td></tr></tbody></table></figure>\n<p>打包文档网站<br></p><figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn docs:build</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>发布文档网站<br></p><figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn docs:deploy</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>如何用 Webpack 来搭建这样一套时尚的 workflow。</p>\n<h2 id=\"搭建\"><a href=\"#搭建\" class=\"headerlink\" title=\"搭建\"></a>搭建</h2><p>先来看下最后的目录结构</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── README.md</span><br><span class=\"line\">├── dist # 文档生产环境输出目录</span><br><span class=\"line\">├── docs # 文档源码</span><br><span class=\"line\">├── lib # 组件输出目录</span><br><span class=\"line\">│   ├── button # 按需加载 js 组件</span><br><span class=\"line\">│   ├── checkbox</span><br><span class=\"line\">│   ├── ...</span><br><span class=\"line\">│   ├── index # 全部组件 js</span><br><span class=\"line\">│   └── theme-ca</span><br><span class=\"line\">│        ├── button # 对应按需加载的组件 css</span><br><span class=\"line\">│        ├── checkbox</span><br><span class=\"line\">│        ├── ...</span><br><span class=\"line\">│        └── index # 全部组件 css</span><br><span class=\"line\">├── scripts # 构建脚本</span><br><span class=\"line\">├── src # 组件源码</span><br><span class=\"line\">│   ├── assets # icon 等</span><br><span class=\"line\">│   ├── common # 公共 js</span><br><span class=\"line\">│   ├── components # 组件源码</span><br><span class=\"line\">│   ├── directives # 指令</span><br><span class=\"line\">│   ├── index.js</span><br><span class=\"line\">│   └── stylesheets # 样式源码</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">└── test # 测试目录，Todo</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"yarn-dev\"><a href=\"#yarn-dev\" class=\"headerlink\" title=\"yarn dev\"></a>yarn dev</h3><p>基于 webpack 4.x 和 babel 7</p>\n<p>在开发环境，首先明确明确我们的输入输出是什么。</p>\n<p>我是在开发一个基于 Vue 的组件库，所以编写的源代码是 Vue 组件。输入就是 Vue 组件。输出就是一个 playground 用于调试我们开发的组件。</p>\n<p>Webpack 的几个基本概念是 entry, output, loader, plugin。</p>\n<p>使用 webpack-dev-server 启动一个服务用于调试和预览组件。<br>关于样式。在这个环境下除了组件自身的样式不应该有其余的样式来干扰我们开发组件的样式。然而在实际运用中，这个组件的自身样式也应该足够的健壮，不会轻易被外部的样式覆盖，但也要保证可定制化，能够在需要客制化样式的时候覆盖组件的自身样式。</p>\n<h2 id=\"样式系统重构\"><a href=\"#样式系统重构\" class=\"headerlink\" title=\"样式系统重构\"></a>样式系统重构</h2><h2 id=\"踩坑\"><a href=\"#踩坑\" class=\"headerlink\" title=\"踩坑\"></a>踩坑</h2><h2 id=\"Todo\"><a href=\"#Todo\" class=\"headerlink\" title=\"Todo\"></a>Todo</h2><script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>也许 Gulp 更合适</p>\n</blockquote>\n<p>回顾 26 个 commit</p>\n<h2 id=\"设想\"><a href=\"#设想\" class=\"headerlink\" title=\"设想\"></a>设想</h2><p>预想的工作方式从 npm scripts 开始</p>\n<ul>\n<li>本地开发和调试</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn dev</span><br></pre></td></tr></table></figure>\n<p>打包编译组件库<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn component</span><br></pre></td></tr></table></figure></p>\n<p>发布到私服<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn release</span><br></pre></td></tr></table></figure></p>\n<p>本地调试文档</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn docs:dev</span><br></pre></td></tr></table></figure>\n<p>打包文档网站<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn docs:build</span><br></pre></td></tr></table></figure></p>\n<p>发布文档网站<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn docs:deploy</span><br></pre></td></tr></table></figure></p>\n<p>如何用 Webpack 来搭建这样一套时尚的 workflow。</p>\n<h2 id=\"搭建\"><a href=\"#搭建\" class=\"headerlink\" title=\"搭建\"></a>搭建</h2><p>先来看下最后的目录结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── README.md</span><br><span class=\"line\">├── dist # 文档生产环境输出目录</span><br><span class=\"line\">├── docs # 文档源码</span><br><span class=\"line\">├── lib # 组件输出目录</span><br><span class=\"line\">│   ├── button # 按需加载 js 组件</span><br><span class=\"line\">│   ├── checkbox</span><br><span class=\"line\">│   ├── ...</span><br><span class=\"line\">│   ├── index # 全部组件 js</span><br><span class=\"line\">│   └── theme-ca</span><br><span class=\"line\">│        ├── button # 对应按需加载的组件 css</span><br><span class=\"line\">│        ├── checkbox</span><br><span class=\"line\">│        ├── ...</span><br><span class=\"line\">│        └── index # 全部组件 css</span><br><span class=\"line\">├── scripts # 构建脚本</span><br><span class=\"line\">├── src # 组件源码</span><br><span class=\"line\">│   ├── assets # icon 等</span><br><span class=\"line\">│   ├── common # 公共 js</span><br><span class=\"line\">│   ├── components # 组件源码</span><br><span class=\"line\">│   ├── directives # 指令</span><br><span class=\"line\">│   ├── index.js</span><br><span class=\"line\">│   └── stylesheets # 样式源码</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">└── test # 测试目录，Todo</span><br></pre></td></tr></table></figure>\n<h3 id=\"yarn-dev\"><a href=\"#yarn-dev\" class=\"headerlink\" title=\"yarn dev\"></a>yarn dev</h3><p>基于 webpack 4.x 和 babel 7</p>\n<p>在开发环境，首先明确明确我们的输入输出是什么。</p>\n<p>我是在开发一个基于 Vue 的组件库，所以编写的源代码是 Vue 组件。输入就是 Vue 组件。输出就是一个 playground 用于调试我们开发的组件。</p>\n<p>Webpack 的几个基本概念是 entry, output, loader, plugin。</p>\n<p>使用 webpack-dev-server 启动一个服务用于调试和预览组件。<br>关于样式。在这个环境下除了组件自身的样式不应该有其余的样式来干扰我们开发组件的样式。然而在实际运用中，这个组件的自身样式也应该足够的健壮，不会轻易被外部的样式覆盖，但也要保证可定制化，能够在需要客制化样式的时候覆盖组件的自身样式。</p>\n<h2 id=\"样式系统重构\"><a href=\"#样式系统重构\" class=\"headerlink\" title=\"样式系统重构\"></a>样式系统重构</h2><h2 id=\"踩坑\"><a href=\"#踩坑\" class=\"headerlink\" title=\"踩坑\"></a>踩坑</h2><h2 id=\"Todo\"><a href=\"#Todo\" class=\"headerlink\" title=\"Todo\"></a>Todo</h2>"},{"title":"Electron 实践笔记","subtitle":"Electron是由Github开发，用HTML，CSS和JavaScript来构建跨平台桌面应用程序的一个开源库。","date":"2019-09-24T03:44:36.000Z","_content":"\n社交魔方平台是京东的 SNS 活动搭建平台，其内置了很多模板，每一个模板都有一个模板 JSON 用于生成表单，运营同学、商家配置了这个表单后就可以生成活动页面了。\n模板 JSON 是标准的结构化数据，包含名称、类型、控件类型、校验器、默认值等等字段。以往都是采用手写 JSON 的方式，这是非常低效的，而且容易出错。针对其结构化数据的特点可以用 GUI 的方式去编辑，我们基于 [Electron](http://electronjs.org) 参考 [Github Desktop 客户端](https://github.com/desktop/desktop) 的架构编写了一个 [编辑器](http://git.jd.com/zhouquan31_repos/cubic)，通过填写表单的方式生成 JSON。所以在这里记录下这个 Electron 编辑器开发过程中可以记录的点和从 Github Desktop 客户端代码中值得学习的点。\n\n## 一、关于 Electron\n> Electron是由Github开发，用HTML，CSS和JavaScript来构建跨平台桌面应用程序的一个开源库。 Electron通过将Chromium和Node.js合并到同一个运行时环境中，并将其打包为Mac，Windows和Linux系统下的应用来实现这一目的。\n\n上面是来自 Electron 官方的介绍。基于 Electron 平台，我们可以使用熟悉的前端技术栈来开发桌面应用。Electron 运行 package.json 的 main 脚本的进程被称为主进程（以下简称main）。 在主进程中运行的脚本通过创建 web 页面来展示用户界面（以下简称 renderer）。 一个 Electron 应用总是有且只有一个主进程。main 用于创建应用，创建浏览器窗口，它就是一个彻底的 Node 进程，获取不到 DOM, BOM 这些接口。在 main 创建的浏览器窗口中运行的就是 renderer 进程，它既可以获取 DOM, BOM 这些接口，也可以使用 Node 的 API。两类进程之间可以通过 Electron 提供的 IPC 接口通信。\n\n\n## 二、开发环境搭建\n\n我们了解到 Electron 分为两类进程，main 和 renderer。所以搭建开发环境时不能像普通的前端应用一样一个 webpack 配置搞定。并且我们想要实现\n\n1. 一键启动开发环境\n2. 一键打包\n3. 一键发布\n\n那么就需要两个 webpack 配置文件。\n\n一个用于开发环境 -- `webpack.dev.ts`。\n\n```ts\n// webpack.dev.ts\nconst mainConfig = merge({}, base.mainConfig, config, {\n  watch: true\n})\n\nconst rendererConfig = merge({}, base.rendererConfig, config, {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader'],\n      },\n      {\n        test: /\\.styl$/,\n        use: ['style-loader', 'css-loader', 'stylus-loader'],\n      }\n    ]\n  },\n  devServer: {\n    contentBase: path.join(__dirname, base.outputDir),\n    port: 8000,\n    hot: true,\n    inline: true,\n    historyApiFallback: true,\n    writeToDisk: true\n  },\n})\n\nmodule.exports = [rendererConfig, mainConfig]\n```\n\n另一个用于生产环境 -- `webpack.prod.ts`。\n\n```ts\nconst config: webpack.Configuration = {\n  mode: 'production',\n  devtool: 'source-map',\n}\n\nconst mainConfig = merge({}, base.mainConfig, config)\n\nconst rendererConfig = merge({}, base.rendererConfig, config, {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [MiniCssExtractPlugin.loader, 'css-loader'],\n      },\n      {\n        test: /\\.styl$/,\n        use: [MiniCssExtractPlugin.loader, 'css-loader', 'stylus-loader'],\n      }\n    ]\n  },\n  plugins: [\n    new MiniCssExtractPlugin({ filename: 'renderer.css' }),\n    new BundleAnalyzerPlugin({\n      analyzerMode: 'static',\n      openAnalyzer: false,\n      reportFilename: 'renderer.report.html',\n    }),\n  ],\n})\n\nmodule.exports = [mainConfig, rendererConfig]\n```\n\n这里参考了 Desktop 使用 Typescript 编写 webpack 配置文件。配合 interface 可以实现 webpack 配置文件的编辑器自动补全。具体使用方法可参考 webpack 文档 https://webpack.js.org/configuration/configuration-languages/#typescript\n\n每一个配置文件导出一个数组，分别是 main, renderer 的配置对象。\n\n使用 webpack-dev-server 启动能实现 renderer 的热更新，main 则是使用 webpack 的 watch 模式。\n\n```json\n{\n  \"compile:dev\": \"webpack-dev-server --config scripts/webpack.dev.ts\"\n}\n```\n\n使用 [nodemon](https://nodemon.io) 监听 main 编译后的产物，nodemon 监听到改动则重新运行 `electron .` 重启应用,这样间接实现了 main 的 livereload。\n\n> Nodemon is a utility that will monitor for any changes in your source and automatically restart your server.\n\n```json\n{\n  \"app\": \"electron .\",\n  \"app:watch\": \"nodemon --watch 'dest/main.js' --exec npm run app\",\n}\n```\n\n这样就实现了一键启动开发环境，且能够监听代码变化，重新启动应用。\n\n> Tips: 开源社区有更好的 [electron-webpack](https://github.com/electron-userland/electron-webpack), HMR for both renderer and main processes\n\n生产环境则使用 webpack 顺序编译 main 和 renderer。编译完成后使用 [electron-builder](https://www.electron.build) 打包。这样就实现了一键打包。\n\n由于工具链的缺失实现不了一键发布，就只能打包后手动发布了（后面详细说明）。\n\n下面就是完整的 scripts。\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"run-p -c compile:dev typecheck:watch app:watch\",\n    \"dist\": \"npm run compile:prod && electron-builder build --win --mac\",\n    \"compile:dev\": \"webpack-dev-server --config scripts/webpack.dev.ts\",\n    \"compile:prod\": \"npm run clean && webpack --config scripts/webpack.prod.ts\",\n    \"app\": \"electron .\",\n    \"app:watch\": \"nodemon --watch 'dest/main.js' --exec npm run app\",\n    \"clean\": \"rimraf dest dist\",\n    \"typecheck\": \"tsc --noEmit\",\n    \"typecheck:watch\": \"tsc --noEmit --watch\",\n    \"lint\": \"eslint src --ext .ts,.js --fix\",\n    \"release:patch\": \"standard-version --release-as patch && git push --follow-tags origin master && npm run dist\",\n    \"release:minor\": \"standard-version --release-as minor && git push --follow-tags origin master && npm run dist\",\n    \"release:major\": \"standard-version --release-as major && git push --follow-tags origin master && npm run dist\",\n    \"repush\": \"git push --follow-tags origin master && npm run dist\"\n  },\n}\n```\n\n## 三、目录结构\n\n### 1. 项目目录结构\n\n```sh\nsrc\n├── lib\n│   ├── cube\n│   ├── databases\n│   ├── enviroment\n│   ├── files\n│   ├── local-storage\n│   ├── log\n│   ├── shell\n│   ├── stores\n│   ├── update\n│   ├── validator\n│   └── watcher\n├── main\n│   ├── app-window.ts\n│   ├── event-bus.ts\n│   ├── index.ts\n│   ├── keyboard\n│   └── menu\n├── models\n│   ├── popup.ts\n│   └── project.ts\n└── renderer\n    ├── App.tsx\n    ├── assets\n    ├── components\n    ├── index.html\n    ├── index.tsx\n    ├── pages\n    └── types\n```\n\n在目录结构上模仿了 Desktop。main 目录存放 main 进程相关代码，包括应用入口，窗口创建，菜单，快捷键等等；而 renderer 目录则是整个 UI 渲染层的代码。lib 目录则是一些和 UI 无关也和 main 无强相关的业务逻辑代码。models 则存放一些领域模型。\n\n### 2. CSS 规范\n\n在这个 React 中项目中没有使用 css-modules 这类方案。而是使用 BEM 这类能形成命名空间的规范来实现模块化，这样做的好处是能够比较好的对样式进行覆盖。\n\n在文件的组织方式上采用一个独立的 React 组件搭配一个独立的样式文件，这样在重构的时候，我们想要修改一个组件的样式只需要找到对应的样式文件进行修改即可，提高重构的效率。\n\n```\nstylesheets\n  ├── common.styl\n  ├── components\n  │   ├── editor.styl\n  │   ├── empty-guide.styl\n  │   ├── find-in-page.styl\n  │   ├── reindex.styl\n  │   ├── sidebar.styl\n  │   ├── source-viewer.styl\n  │   └── upload.styl\n  ├── index.styl\n  └── reset.styl\n```\n\n\n## 三、IPC 通信\n\n> 进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息。 \n\nElectron 的 main 进程和 renderer 进程的通信是通过 Electron 提供的 `ipcMain` 和 `ipcRenderer` 来实现的。\n\n### 1. main 端\n\n在 main 中向某一个窗口 renderer 发送消息可以使用 `window.webContents.send`。\n在 main 端监听 renderer 消息可以使用 `ipcMain.on`。\n\n```js\n// 在主进程中.\nconst { ipcMain } = require('electron')\nipcMain.on('asynchronous-message', (event, arg) => {\n  console.log(arg) // prints \"ping\"\n  event.reply('asynchronous-reply', 'pong')\n})\n\nipcMain.on('synchronous-message', (event, arg) => {\n  console.log(arg) // prints \"ping\"\n  event.returnValue = 'pong'\n})\n```\n\n### 2. renderer 端\n\n回复同步消息可以使用 `event.returnValue`。同步消息的返回值可以直接读取。\n回复异步消息可以使用 `event.reply`。那么在 renderer 就要监听回复的 channel 得到返回值。\n\n```ts\n//在渲染器进程 (网页) 中。\nconst { ipcRenderer } = require('electron')\nconsole.log(ipcRenderer.sendSync('synchronous-message', 'ping')) // prints \"pong\"\n\nipcRenderer.on('asynchronous-reply', (event, arg) => {\n  console.log(arg) // prints \"pong\"\n})\nipcRenderer.send('asynchronous-message', 'ping')\n```\n\n可以看到 renderer 可以使用 `ipcRenderer.send` 向主进程发送异步消息。用 `ipcRenderer.sendSync` 发送同步消息。\n\n## 四、数据持久化及状态管理\n\n### 1. 复杂数据持久化\n\n数据持久化可选的方案有很多，比如 [electron-store](https://github.com/sindresorhus/electron-store#readme)等基于 JSON 文件实现的存储方案。对于更复杂的应用场景还可以使用 [lowdb](https://github.com/typicode/lowdb)，[nedb](https://github.com/louischatriot/nedb) ，`sqlite`等。\n\n最初我使用的是 `electron-store`, 并且一直有一个执念是对磁盘的读写只能在 main 进程进行，renderer 进程只负责渲染界面。所以在最初设计的是在 renderer 进程渲染数据或者更新数据的时候都需要通过 IPC 到 main 进程来完成最终的磁盘读写。除去读写正常的情况，还要考虑读写磁盘的异常，这样导致数据流异常的绕。而且还需要自己维护 ID 的生成。借鉴了 Desktop 的代码后，重构了数据持久化部分，也采用了 [Dexie](https://github.com/dfahlander/Dexie.js)，它是对浏览器标准数据库 indexedDB 的一个封装。从它的 Readme 可以看到它主要解决了indexedDB 的三个问题：\n\n1. 不明确的异常处理\n2. 查询很烂\n3. 代码复杂\n\n\n```ts\nimport Dexie from 'dexie';\n\nexport interface IDatabaseProject {\n  id?: number;\n  name: string;\n  filePath: string;\n}\n\nexport class ProjectsDatabase extends Dexie {\n  public projects: Dexie.Table<IDatabaseProject, number>;\n  constructor() {\n    super('ProjectsDatabase');\n\n    this.version(1).stores({\n      projects: '++id,&name,&filePath',\n    });\n\n    this.projects = this.table('projects');\n  }\n}\n```\n\n继承 Dexie 来实现我们自己的数据库类，在构造函数中声明数据库的版本，表的 schema 等等。具体可以参考 [Dexie 官方文档](https://dexie.org/docs/)。\n\n\n### 2. 简单数据持久化\n\n一些 UI 状态的标志位存储（比如某个弹窗是否显示过），我们一般会把这种标志位存储到 `localStorage` 中。\n在查看 Desktop 的源码过程中，发现他们对 `number`, `boolean` 类型的数据的 get, set 进行了简单的封装。使用起来非常方便，这里贴一下对于 `boolean` 型数据的处理。\n\n```typescript\nexport function getBoolean(key: string): boolean | undefined\nexport function getBoolean(key: string, defaultValue: boolean): boolean\nexport function getBoolean(\n  key: string,\n  defaultValue?: boolean\n): boolean | undefined {\n  const value = localStorage.getItem(key)\n  if (value === null) {\n    return defaultValue\n  }\n\n  if (value === '1' || value === 'true') {\n    return true\n  }\n\n  if (value === '0' || value === 'false') {\n    return false\n  }\n\n  return defaultValue\n}\n\nexport function setBoolean(key: string, value: boolean) {\n  localStorage.setItem(key, value ? '1' : '0')\n}\n```\n\n[源码详见](https://github.com/desktop/desktop/blob/development/app/src/lib/local-storage.ts)\n\n\n\n## 五、功能实现\n\n### 1. 磁盘/编辑器版本实时同步\n\n一般情况下，在编辑器中我们编辑的内容其实是编辑器读取磁盘文件到内存中的副本。所以说如果磁盘的文件发生了改动，比如 Git 切换分支造成文件变动，抑或是删除了磁盘文件，重命名等等都会造成内存版本和磁盘版本的不一致，即磁盘版本领先于内存版本，这个时候就可能产生冲突。解决这个问题很简单，可以使用 fs.watch/watchFile 监听当前编辑的文件，一旦发生变化，就重新读取磁盘版本，更新内存版本来实现同步。但是 fs.watch 这个 API 在工程上不是可以开箱即用的，有许多兼容问题和一些 bug。比如说\n\nNode.js fs.watch:\n\n- Doesn't report filenames on MacOS.\n- Doesn't report events at all when using editors like Sublime on MacOS.\n- Often reports events twice.\n- Emits most changes as rename.\n- Does not provide an easy way to recursively watch file trees.\n\nNode.js fs.watchFile:\n\n- Almost as bad at event handling.\n- Also does not provide any recursive watching.\n- Results in high CPU utilization.\n\n上面列举的点来自 [chokidar](https://github.com/paulmillr/chokidar)，它是一个 Node 模块，提供了开箱可用的监听文件变化的能力。只需要监听 `add`, `unlink`, `change` 等事件读取最新版本的文本到编辑器就可以实现磁盘/编辑器版本的同步了。\n\n\n### 2. Context-Menu\n\nDesktop 的 `contextmenu` (右键菜单)的实现基于原生 IPC 的，比较绕。\n\n首先我们需要知道的是 `Menu` 类是 `main process only` 的。\n\n在需要 `contextmenu` 的 `JSX.Element` 上绑定 `onContextMenu` 事件。构造对象数组 `Array<MenuItem>`, 并且为每个 MenuItem 对象绑定触发事件，再通过 IPC 将对象传递至 main 进程，值得一提的是这个时候将 MenuItem 数组赋值给了一个全局对象，暂存起来。在 main 进程构造出真正的 MenuItem 实例，绑定 MenuItem 的点击事件，触发 MenuItem 点击事件的时候记录 MenuItem 的 序列号 index，再将 index 通过 event.sender.send 将 index 传递到 renderer 进程。renderer 进程拿到 index 之后根据之前保存的全局对象取出单个 MenuItem， 执行绑定的事件。\n\n```\nonContextMenu => showContextualMenu (暂存MenuItems，ipcRenderer.send) => icpMain => menu.popup() => MenuItem.onClick(index) => event.sernder.send(index) => MenuItem.action()\n```\n\n所以在我的应用中使用了 remote 对象屏蔽上述复杂的 IPC 通信。在 renderer 进程完成 Menu 的构造展示和事件的绑定触发。\n\n```ts\nimport { remote } from 'electron';\nconst { MenuItem, dialog, getCurrentWindow, Menu } = remote;\n\nconst onContextMenu = (project: Project) => {\n  const menu = new Menu();\n\n  const menus = [\n    new MenuItem({\n      label: '在终端中打开',\n      visible: __DARWIN__,\n      click() {\n        const accessor = new FileAccessor(project.filePath);\n        accessor.openInTerminal();\n      },\n    }),\n    new MenuItem({\n      label: '在 vscode 中打开',\n      click() {\n        const accessor = new FileAccessor(project.filePath);\n        accessor.openInVscode();\n      },\n    }),\n  ];\n\n  menus.forEach(menu.append);\n  menu.popup({ window: getCurrentWindow() });\n};\n```\n\n## 六、日志\n\n完善的日志不论是开发环境还是生产环境都是非常重要的，大致记录 UI 状态迁移背后的数据变动，流程的分支走向，能很好的辅助开发。\n\n参考 Desktop，他们的日志基于日志库：[winston](https://github.com/winstonjs/winston#readme)。\n\n在 main 进程和 renderer 进程都提供了全局 log 对象，接口都是一致的。分别是 `debug`, `info`, `warn`, `error`。在 renderer 进程，简单的封装了 `window.console` 对象上的 `debug`, `info`, `warn`, `error` 方法，日志打印到浏览器控制台的时候也通过 IPC 传递到 main 进程，由 main 进程统一管理。 \n\nmain 进程接收了来自 renderer 进程的日志信息和 main 进程自身的日志信息。设置了两个 `transports`。`winston.transports.Console` 和 `winston.transports.DailyRotateFile` 分别用于将日志信息打印在终端控制台和存储在磁盘文件。DailyRotateFile 以天为单位，设置了最多存储 14 天的上限。\n\n在 main 进程和 renderer 进程启动时分别引入日志安装模块。因为 log 方法都是暴露在全局，因此只需要在进程启动时引入一次即可。同时在 TS 环境中还需要添加 log 方法的类型声明。\n\n\n## 七、打包，发布及更新\n\n开源世界已经有非常完善的打包和发布的工具 -- [electron-builder](https://www.electron.build)。它集多平台打包，签名，自动更新，发布到Github等平台等等功能于一身。\n\n鉴于这个工具只能在内网使用，不能发布到 Github 而且也没有没有苹果开发者工具无法进行签名，只能利用 `electron-builder` 在本机打包，发布的话只能使用手动打包上传了，用户也只能手动下载安装包覆盖安装，不能像 VSCODE 这样实现自动更新。\n\n既然不能自动更新，那么新版本下发后，如何通知到用户去下载新版本安装包更新呢？\n从用户这一端来看，在应用每次启动的时候可以做一次请求，查询是否有版本更新，或者是在应用菜单栏提供入口，让用户手动触发更新查询。查询到服务端的最新版本后，使用 [sermver](https://www.npmjs.com/package/semver) 比较本机版本是否低于服务器版本，如果是就下发通知给用户，提示用户去下载更新。\n\n在有限的条件下怎么实现这个功能呢？\n\n实现这个功能必需的三个元素：服务端标识着最新版本的可读文件；托管各个版本安装包的云空间；应用代码中的更新逻辑。\n\n服务端标识着最新版本的可读文件：每次打包时都会更新 `package.json`，所以我们直接把 `package.json` 上传到某个不带鉴权的 CDN 就可以，更新的时候就请求这个文件。\n\n托管各个版本安装包的云空间：这个可以使用云盘，云盘可以生成分享链接，把这个链接手动拷贝到 Gitlab 该版本的 tag 的 Notes 中。\n\n应用代码中的更新逻辑：\n\n```ts\nimport got from 'got';\nimport semver from 'semver';\nimport { app, remote, BrowserWindow } from 'electron';\n\nconst realApp = app || remote.app;\nconst currentVersion = realApp.getVersion();\n\nexport async function checkForUpdates(window: BrowserWindow, silent: boolean = false) {\n  const url = `http://yourcdn/package.json?t=${Date.now()}`;\n  try {\n    const response = await got(url);\n    const pkg = JSON.parse(response.body);\n    log.debug('检查更新，云端版本：', pkg.version);\n    log.debug('当前版本', currentVersion);\n    if (semver.lt(currentVersion, pkg.version)) {\n      window.webContents.send('update-available', pkg.version);\n    } else {\n      window.webContents.send('update-not-available', silent);\n    }\n  } catch (error) {\n    window.webContents.send('update-error', silent);\n  }\n}\n\n```\n\n分别在应用主进程启动、用户点击应用菜单`检查更新`时调用这个方法，从而通知 UI 进程下发通知。我们期望应用主进程启动时的更新是在失败或者无更新时是静默的，不用打扰用户，所以在 IPC 管道可以提供一个 `silent` 参数。检测到更新后就可以通知用户，用户点击更新后就可以跳转到最新版本的 Gitlab tags ，引导用户下载最新版本进行手动安装。\n\n\n## 八、其他\n\n### 1. devtools\n\n开发 Electron 应用中 renderer 端也是使用 Chrome devtools 来调试的。对于 React, Mobx 这类框的 devtools 扩展也可以通过 `electron-devtools-installer` 来安装。应用窗口创建之后调用`electron-devtools-installer` 进行 `mobx`、`react` 等扩展的安装。\n\n```ts\nconst { default: installExtension, MOBX_DEVTOOLS, REACT_DEVELOPER_TOOLS } = require('electron-devtools-installer');\nconst extensions = [REACT_DEVELOPER_TOOLS, MOBX_DEVTOOLS];\nfor (const extension of extensions) {\n  try {\n    installExtension(extension);\n  } catch (e) {\n    // log.error(e);\n  }\n}\n```\n\n## 2. 保持窗口大小\n\n对于桌面应用，一个常见的需求就是关闭后重新打开，需要恢复到上次打开时的窗口大小，位置。实现这个比较简单，监听窗口的 resize 事件，把窗口信息记录到当前用户的应用数据文件夹, 即 `app.getPath(appData)`。下次启动应用创建窗口时读取这个文件设置窗口信息即可。开源社区已经有对这个功能封装好的库：[electron-window-state](https://github.com/mawie81/electron-window-state#readme)\n\n\n```js\nconst windowStateKeeper = require('electron-window-state');\nlet win;\n\napp.on('ready', function () {\n  let mainWindowState = windowStateKeeper({\n    defaultWidth: 1000,\n    defaultHeight: 800\n  });\n\n  win = new BrowserWindow({\n    'x': mainWindowState.x,\n    'y': mainWindowState.y,\n    'width': mainWindowState.width,\n    'height': mainWindowState.height\n  });\n\n  mainWindowState.manage(win);\n});\n```\n\n只需要提供缺省窗口大小，剩余的事情 `electron-window-state` 都帮我们搞定了。\n\n","source":"_posts/electron-in-action.md","raw":"---\ntitle: Electron 实践笔记\nsubtitle: Electron是由Github开发，用HTML，CSS和JavaScript来构建跨平台桌面应用程序的一个开源库。 \ndate: 2019-09-24 11:44:36\n---\n\n社交魔方平台是京东的 SNS 活动搭建平台，其内置了很多模板，每一个模板都有一个模板 JSON 用于生成表单，运营同学、商家配置了这个表单后就可以生成活动页面了。\n模板 JSON 是标准的结构化数据，包含名称、类型、控件类型、校验器、默认值等等字段。以往都是采用手写 JSON 的方式，这是非常低效的，而且容易出错。针对其结构化数据的特点可以用 GUI 的方式去编辑，我们基于 [Electron](http://electronjs.org) 参考 [Github Desktop 客户端](https://github.com/desktop/desktop) 的架构编写了一个 [编辑器](http://git.jd.com/zhouquan31_repos/cubic)，通过填写表单的方式生成 JSON。所以在这里记录下这个 Electron 编辑器开发过程中可以记录的点和从 Github Desktop 客户端代码中值得学习的点。\n\n## 一、关于 Electron\n> Electron是由Github开发，用HTML，CSS和JavaScript来构建跨平台桌面应用程序的一个开源库。 Electron通过将Chromium和Node.js合并到同一个运行时环境中，并将其打包为Mac，Windows和Linux系统下的应用来实现这一目的。\n\n上面是来自 Electron 官方的介绍。基于 Electron 平台，我们可以使用熟悉的前端技术栈来开发桌面应用。Electron 运行 package.json 的 main 脚本的进程被称为主进程（以下简称main）。 在主进程中运行的脚本通过创建 web 页面来展示用户界面（以下简称 renderer）。 一个 Electron 应用总是有且只有一个主进程。main 用于创建应用，创建浏览器窗口，它就是一个彻底的 Node 进程，获取不到 DOM, BOM 这些接口。在 main 创建的浏览器窗口中运行的就是 renderer 进程，它既可以获取 DOM, BOM 这些接口，也可以使用 Node 的 API。两类进程之间可以通过 Electron 提供的 IPC 接口通信。\n\n\n## 二、开发环境搭建\n\n我们了解到 Electron 分为两类进程，main 和 renderer。所以搭建开发环境时不能像普通的前端应用一样一个 webpack 配置搞定。并且我们想要实现\n\n1. 一键启动开发环境\n2. 一键打包\n3. 一键发布\n\n那么就需要两个 webpack 配置文件。\n\n一个用于开发环境 -- `webpack.dev.ts`。\n\n```ts\n// webpack.dev.ts\nconst mainConfig = merge({}, base.mainConfig, config, {\n  watch: true\n})\n\nconst rendererConfig = merge({}, base.rendererConfig, config, {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader'],\n      },\n      {\n        test: /\\.styl$/,\n        use: ['style-loader', 'css-loader', 'stylus-loader'],\n      }\n    ]\n  },\n  devServer: {\n    contentBase: path.join(__dirname, base.outputDir),\n    port: 8000,\n    hot: true,\n    inline: true,\n    historyApiFallback: true,\n    writeToDisk: true\n  },\n})\n\nmodule.exports = [rendererConfig, mainConfig]\n```\n\n另一个用于生产环境 -- `webpack.prod.ts`。\n\n```ts\nconst config: webpack.Configuration = {\n  mode: 'production',\n  devtool: 'source-map',\n}\n\nconst mainConfig = merge({}, base.mainConfig, config)\n\nconst rendererConfig = merge({}, base.rendererConfig, config, {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [MiniCssExtractPlugin.loader, 'css-loader'],\n      },\n      {\n        test: /\\.styl$/,\n        use: [MiniCssExtractPlugin.loader, 'css-loader', 'stylus-loader'],\n      }\n    ]\n  },\n  plugins: [\n    new MiniCssExtractPlugin({ filename: 'renderer.css' }),\n    new BundleAnalyzerPlugin({\n      analyzerMode: 'static',\n      openAnalyzer: false,\n      reportFilename: 'renderer.report.html',\n    }),\n  ],\n})\n\nmodule.exports = [mainConfig, rendererConfig]\n```\n\n这里参考了 Desktop 使用 Typescript 编写 webpack 配置文件。配合 interface 可以实现 webpack 配置文件的编辑器自动补全。具体使用方法可参考 webpack 文档 https://webpack.js.org/configuration/configuration-languages/#typescript\n\n每一个配置文件导出一个数组，分别是 main, renderer 的配置对象。\n\n使用 webpack-dev-server 启动能实现 renderer 的热更新，main 则是使用 webpack 的 watch 模式。\n\n```json\n{\n  \"compile:dev\": \"webpack-dev-server --config scripts/webpack.dev.ts\"\n}\n```\n\n使用 [nodemon](https://nodemon.io) 监听 main 编译后的产物，nodemon 监听到改动则重新运行 `electron .` 重启应用,这样间接实现了 main 的 livereload。\n\n> Nodemon is a utility that will monitor for any changes in your source and automatically restart your server.\n\n```json\n{\n  \"app\": \"electron .\",\n  \"app:watch\": \"nodemon --watch 'dest/main.js' --exec npm run app\",\n}\n```\n\n这样就实现了一键启动开发环境，且能够监听代码变化，重新启动应用。\n\n> Tips: 开源社区有更好的 [electron-webpack](https://github.com/electron-userland/electron-webpack), HMR for both renderer and main processes\n\n生产环境则使用 webpack 顺序编译 main 和 renderer。编译完成后使用 [electron-builder](https://www.electron.build) 打包。这样就实现了一键打包。\n\n由于工具链的缺失实现不了一键发布，就只能打包后手动发布了（后面详细说明）。\n\n下面就是完整的 scripts。\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"run-p -c compile:dev typecheck:watch app:watch\",\n    \"dist\": \"npm run compile:prod && electron-builder build --win --mac\",\n    \"compile:dev\": \"webpack-dev-server --config scripts/webpack.dev.ts\",\n    \"compile:prod\": \"npm run clean && webpack --config scripts/webpack.prod.ts\",\n    \"app\": \"electron .\",\n    \"app:watch\": \"nodemon --watch 'dest/main.js' --exec npm run app\",\n    \"clean\": \"rimraf dest dist\",\n    \"typecheck\": \"tsc --noEmit\",\n    \"typecheck:watch\": \"tsc --noEmit --watch\",\n    \"lint\": \"eslint src --ext .ts,.js --fix\",\n    \"release:patch\": \"standard-version --release-as patch && git push --follow-tags origin master && npm run dist\",\n    \"release:minor\": \"standard-version --release-as minor && git push --follow-tags origin master && npm run dist\",\n    \"release:major\": \"standard-version --release-as major && git push --follow-tags origin master && npm run dist\",\n    \"repush\": \"git push --follow-tags origin master && npm run dist\"\n  },\n}\n```\n\n## 三、目录结构\n\n### 1. 项目目录结构\n\n```sh\nsrc\n├── lib\n│   ├── cube\n│   ├── databases\n│   ├── enviroment\n│   ├── files\n│   ├── local-storage\n│   ├── log\n│   ├── shell\n│   ├── stores\n│   ├── update\n│   ├── validator\n│   └── watcher\n├── main\n│   ├── app-window.ts\n│   ├── event-bus.ts\n│   ├── index.ts\n│   ├── keyboard\n│   └── menu\n├── models\n│   ├── popup.ts\n│   └── project.ts\n└── renderer\n    ├── App.tsx\n    ├── assets\n    ├── components\n    ├── index.html\n    ├── index.tsx\n    ├── pages\n    └── types\n```\n\n在目录结构上模仿了 Desktop。main 目录存放 main 进程相关代码，包括应用入口，窗口创建，菜单，快捷键等等；而 renderer 目录则是整个 UI 渲染层的代码。lib 目录则是一些和 UI 无关也和 main 无强相关的业务逻辑代码。models 则存放一些领域模型。\n\n### 2. CSS 规范\n\n在这个 React 中项目中没有使用 css-modules 这类方案。而是使用 BEM 这类能形成命名空间的规范来实现模块化，这样做的好处是能够比较好的对样式进行覆盖。\n\n在文件的组织方式上采用一个独立的 React 组件搭配一个独立的样式文件，这样在重构的时候，我们想要修改一个组件的样式只需要找到对应的样式文件进行修改即可，提高重构的效率。\n\n```\nstylesheets\n  ├── common.styl\n  ├── components\n  │   ├── editor.styl\n  │   ├── empty-guide.styl\n  │   ├── find-in-page.styl\n  │   ├── reindex.styl\n  │   ├── sidebar.styl\n  │   ├── source-viewer.styl\n  │   └── upload.styl\n  ├── index.styl\n  └── reset.styl\n```\n\n\n## 三、IPC 通信\n\n> 进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息。 \n\nElectron 的 main 进程和 renderer 进程的通信是通过 Electron 提供的 `ipcMain` 和 `ipcRenderer` 来实现的。\n\n### 1. main 端\n\n在 main 中向某一个窗口 renderer 发送消息可以使用 `window.webContents.send`。\n在 main 端监听 renderer 消息可以使用 `ipcMain.on`。\n\n```js\n// 在主进程中.\nconst { ipcMain } = require('electron')\nipcMain.on('asynchronous-message', (event, arg) => {\n  console.log(arg) // prints \"ping\"\n  event.reply('asynchronous-reply', 'pong')\n})\n\nipcMain.on('synchronous-message', (event, arg) => {\n  console.log(arg) // prints \"ping\"\n  event.returnValue = 'pong'\n})\n```\n\n### 2. renderer 端\n\n回复同步消息可以使用 `event.returnValue`。同步消息的返回值可以直接读取。\n回复异步消息可以使用 `event.reply`。那么在 renderer 就要监听回复的 channel 得到返回值。\n\n```ts\n//在渲染器进程 (网页) 中。\nconst { ipcRenderer } = require('electron')\nconsole.log(ipcRenderer.sendSync('synchronous-message', 'ping')) // prints \"pong\"\n\nipcRenderer.on('asynchronous-reply', (event, arg) => {\n  console.log(arg) // prints \"pong\"\n})\nipcRenderer.send('asynchronous-message', 'ping')\n```\n\n可以看到 renderer 可以使用 `ipcRenderer.send` 向主进程发送异步消息。用 `ipcRenderer.sendSync` 发送同步消息。\n\n## 四、数据持久化及状态管理\n\n### 1. 复杂数据持久化\n\n数据持久化可选的方案有很多，比如 [electron-store](https://github.com/sindresorhus/electron-store#readme)等基于 JSON 文件实现的存储方案。对于更复杂的应用场景还可以使用 [lowdb](https://github.com/typicode/lowdb)，[nedb](https://github.com/louischatriot/nedb) ，`sqlite`等。\n\n最初我使用的是 `electron-store`, 并且一直有一个执念是对磁盘的读写只能在 main 进程进行，renderer 进程只负责渲染界面。所以在最初设计的是在 renderer 进程渲染数据或者更新数据的时候都需要通过 IPC 到 main 进程来完成最终的磁盘读写。除去读写正常的情况，还要考虑读写磁盘的异常，这样导致数据流异常的绕。而且还需要自己维护 ID 的生成。借鉴了 Desktop 的代码后，重构了数据持久化部分，也采用了 [Dexie](https://github.com/dfahlander/Dexie.js)，它是对浏览器标准数据库 indexedDB 的一个封装。从它的 Readme 可以看到它主要解决了indexedDB 的三个问题：\n\n1. 不明确的异常处理\n2. 查询很烂\n3. 代码复杂\n\n\n```ts\nimport Dexie from 'dexie';\n\nexport interface IDatabaseProject {\n  id?: number;\n  name: string;\n  filePath: string;\n}\n\nexport class ProjectsDatabase extends Dexie {\n  public projects: Dexie.Table<IDatabaseProject, number>;\n  constructor() {\n    super('ProjectsDatabase');\n\n    this.version(1).stores({\n      projects: '++id,&name,&filePath',\n    });\n\n    this.projects = this.table('projects');\n  }\n}\n```\n\n继承 Dexie 来实现我们自己的数据库类，在构造函数中声明数据库的版本，表的 schema 等等。具体可以参考 [Dexie 官方文档](https://dexie.org/docs/)。\n\n\n### 2. 简单数据持久化\n\n一些 UI 状态的标志位存储（比如某个弹窗是否显示过），我们一般会把这种标志位存储到 `localStorage` 中。\n在查看 Desktop 的源码过程中，发现他们对 `number`, `boolean` 类型的数据的 get, set 进行了简单的封装。使用起来非常方便，这里贴一下对于 `boolean` 型数据的处理。\n\n```typescript\nexport function getBoolean(key: string): boolean | undefined\nexport function getBoolean(key: string, defaultValue: boolean): boolean\nexport function getBoolean(\n  key: string,\n  defaultValue?: boolean\n): boolean | undefined {\n  const value = localStorage.getItem(key)\n  if (value === null) {\n    return defaultValue\n  }\n\n  if (value === '1' || value === 'true') {\n    return true\n  }\n\n  if (value === '0' || value === 'false') {\n    return false\n  }\n\n  return defaultValue\n}\n\nexport function setBoolean(key: string, value: boolean) {\n  localStorage.setItem(key, value ? '1' : '0')\n}\n```\n\n[源码详见](https://github.com/desktop/desktop/blob/development/app/src/lib/local-storage.ts)\n\n\n\n## 五、功能实现\n\n### 1. 磁盘/编辑器版本实时同步\n\n一般情况下，在编辑器中我们编辑的内容其实是编辑器读取磁盘文件到内存中的副本。所以说如果磁盘的文件发生了改动，比如 Git 切换分支造成文件变动，抑或是删除了磁盘文件，重命名等等都会造成内存版本和磁盘版本的不一致，即磁盘版本领先于内存版本，这个时候就可能产生冲突。解决这个问题很简单，可以使用 fs.watch/watchFile 监听当前编辑的文件，一旦发生变化，就重新读取磁盘版本，更新内存版本来实现同步。但是 fs.watch 这个 API 在工程上不是可以开箱即用的，有许多兼容问题和一些 bug。比如说\n\nNode.js fs.watch:\n\n- Doesn't report filenames on MacOS.\n- Doesn't report events at all when using editors like Sublime on MacOS.\n- Often reports events twice.\n- Emits most changes as rename.\n- Does not provide an easy way to recursively watch file trees.\n\nNode.js fs.watchFile:\n\n- Almost as bad at event handling.\n- Also does not provide any recursive watching.\n- Results in high CPU utilization.\n\n上面列举的点来自 [chokidar](https://github.com/paulmillr/chokidar)，它是一个 Node 模块，提供了开箱可用的监听文件变化的能力。只需要监听 `add`, `unlink`, `change` 等事件读取最新版本的文本到编辑器就可以实现磁盘/编辑器版本的同步了。\n\n\n### 2. Context-Menu\n\nDesktop 的 `contextmenu` (右键菜单)的实现基于原生 IPC 的，比较绕。\n\n首先我们需要知道的是 `Menu` 类是 `main process only` 的。\n\n在需要 `contextmenu` 的 `JSX.Element` 上绑定 `onContextMenu` 事件。构造对象数组 `Array<MenuItem>`, 并且为每个 MenuItem 对象绑定触发事件，再通过 IPC 将对象传递至 main 进程，值得一提的是这个时候将 MenuItem 数组赋值给了一个全局对象，暂存起来。在 main 进程构造出真正的 MenuItem 实例，绑定 MenuItem 的点击事件，触发 MenuItem 点击事件的时候记录 MenuItem 的 序列号 index，再将 index 通过 event.sender.send 将 index 传递到 renderer 进程。renderer 进程拿到 index 之后根据之前保存的全局对象取出单个 MenuItem， 执行绑定的事件。\n\n```\nonContextMenu => showContextualMenu (暂存MenuItems，ipcRenderer.send) => icpMain => menu.popup() => MenuItem.onClick(index) => event.sernder.send(index) => MenuItem.action()\n```\n\n所以在我的应用中使用了 remote 对象屏蔽上述复杂的 IPC 通信。在 renderer 进程完成 Menu 的构造展示和事件的绑定触发。\n\n```ts\nimport { remote } from 'electron';\nconst { MenuItem, dialog, getCurrentWindow, Menu } = remote;\n\nconst onContextMenu = (project: Project) => {\n  const menu = new Menu();\n\n  const menus = [\n    new MenuItem({\n      label: '在终端中打开',\n      visible: __DARWIN__,\n      click() {\n        const accessor = new FileAccessor(project.filePath);\n        accessor.openInTerminal();\n      },\n    }),\n    new MenuItem({\n      label: '在 vscode 中打开',\n      click() {\n        const accessor = new FileAccessor(project.filePath);\n        accessor.openInVscode();\n      },\n    }),\n  ];\n\n  menus.forEach(menu.append);\n  menu.popup({ window: getCurrentWindow() });\n};\n```\n\n## 六、日志\n\n完善的日志不论是开发环境还是生产环境都是非常重要的，大致记录 UI 状态迁移背后的数据变动，流程的分支走向，能很好的辅助开发。\n\n参考 Desktop，他们的日志基于日志库：[winston](https://github.com/winstonjs/winston#readme)。\n\n在 main 进程和 renderer 进程都提供了全局 log 对象，接口都是一致的。分别是 `debug`, `info`, `warn`, `error`。在 renderer 进程，简单的封装了 `window.console` 对象上的 `debug`, `info`, `warn`, `error` 方法，日志打印到浏览器控制台的时候也通过 IPC 传递到 main 进程，由 main 进程统一管理。 \n\nmain 进程接收了来自 renderer 进程的日志信息和 main 进程自身的日志信息。设置了两个 `transports`。`winston.transports.Console` 和 `winston.transports.DailyRotateFile` 分别用于将日志信息打印在终端控制台和存储在磁盘文件。DailyRotateFile 以天为单位，设置了最多存储 14 天的上限。\n\n在 main 进程和 renderer 进程启动时分别引入日志安装模块。因为 log 方法都是暴露在全局，因此只需要在进程启动时引入一次即可。同时在 TS 环境中还需要添加 log 方法的类型声明。\n\n\n## 七、打包，发布及更新\n\n开源世界已经有非常完善的打包和发布的工具 -- [electron-builder](https://www.electron.build)。它集多平台打包，签名，自动更新，发布到Github等平台等等功能于一身。\n\n鉴于这个工具只能在内网使用，不能发布到 Github 而且也没有没有苹果开发者工具无法进行签名，只能利用 `electron-builder` 在本机打包，发布的话只能使用手动打包上传了，用户也只能手动下载安装包覆盖安装，不能像 VSCODE 这样实现自动更新。\n\n既然不能自动更新，那么新版本下发后，如何通知到用户去下载新版本安装包更新呢？\n从用户这一端来看，在应用每次启动的时候可以做一次请求，查询是否有版本更新，或者是在应用菜单栏提供入口，让用户手动触发更新查询。查询到服务端的最新版本后，使用 [sermver](https://www.npmjs.com/package/semver) 比较本机版本是否低于服务器版本，如果是就下发通知给用户，提示用户去下载更新。\n\n在有限的条件下怎么实现这个功能呢？\n\n实现这个功能必需的三个元素：服务端标识着最新版本的可读文件；托管各个版本安装包的云空间；应用代码中的更新逻辑。\n\n服务端标识着最新版本的可读文件：每次打包时都会更新 `package.json`，所以我们直接把 `package.json` 上传到某个不带鉴权的 CDN 就可以，更新的时候就请求这个文件。\n\n托管各个版本安装包的云空间：这个可以使用云盘，云盘可以生成分享链接，把这个链接手动拷贝到 Gitlab 该版本的 tag 的 Notes 中。\n\n应用代码中的更新逻辑：\n\n```ts\nimport got from 'got';\nimport semver from 'semver';\nimport { app, remote, BrowserWindow } from 'electron';\n\nconst realApp = app || remote.app;\nconst currentVersion = realApp.getVersion();\n\nexport async function checkForUpdates(window: BrowserWindow, silent: boolean = false) {\n  const url = `http://yourcdn/package.json?t=${Date.now()}`;\n  try {\n    const response = await got(url);\n    const pkg = JSON.parse(response.body);\n    log.debug('检查更新，云端版本：', pkg.version);\n    log.debug('当前版本', currentVersion);\n    if (semver.lt(currentVersion, pkg.version)) {\n      window.webContents.send('update-available', pkg.version);\n    } else {\n      window.webContents.send('update-not-available', silent);\n    }\n  } catch (error) {\n    window.webContents.send('update-error', silent);\n  }\n}\n\n```\n\n分别在应用主进程启动、用户点击应用菜单`检查更新`时调用这个方法，从而通知 UI 进程下发通知。我们期望应用主进程启动时的更新是在失败或者无更新时是静默的，不用打扰用户，所以在 IPC 管道可以提供一个 `silent` 参数。检测到更新后就可以通知用户，用户点击更新后就可以跳转到最新版本的 Gitlab tags ，引导用户下载最新版本进行手动安装。\n\n\n## 八、其他\n\n### 1. devtools\n\n开发 Electron 应用中 renderer 端也是使用 Chrome devtools 来调试的。对于 React, Mobx 这类框的 devtools 扩展也可以通过 `electron-devtools-installer` 来安装。应用窗口创建之后调用`electron-devtools-installer` 进行 `mobx`、`react` 等扩展的安装。\n\n```ts\nconst { default: installExtension, MOBX_DEVTOOLS, REACT_DEVELOPER_TOOLS } = require('electron-devtools-installer');\nconst extensions = [REACT_DEVELOPER_TOOLS, MOBX_DEVTOOLS];\nfor (const extension of extensions) {\n  try {\n    installExtension(extension);\n  } catch (e) {\n    // log.error(e);\n  }\n}\n```\n\n## 2. 保持窗口大小\n\n对于桌面应用，一个常见的需求就是关闭后重新打开，需要恢复到上次打开时的窗口大小，位置。实现这个比较简单，监听窗口的 resize 事件，把窗口信息记录到当前用户的应用数据文件夹, 即 `app.getPath(appData)`。下次启动应用创建窗口时读取这个文件设置窗口信息即可。开源社区已经有对这个功能封装好的库：[electron-window-state](https://github.com/mawie81/electron-window-state#readme)\n\n\n```js\nconst windowStateKeeper = require('electron-window-state');\nlet win;\n\napp.on('ready', function () {\n  let mainWindowState = windowStateKeeper({\n    defaultWidth: 1000,\n    defaultHeight: 800\n  });\n\n  win = new BrowserWindow({\n    'x': mainWindowState.x,\n    'y': mainWindowState.y,\n    'width': mainWindowState.width,\n    'height': mainWindowState.height\n  });\n\n  mainWindowState.manage(win);\n});\n```\n\n只需要提供缺省窗口大小，剩余的事情 `electron-window-state` 都帮我们搞定了。\n\n","slug":"electron-in-action","published":1,"updated":"2019-10-09T09:51:23.441Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhpu92xi000gak87a4athq6j","content":"<p>社交魔方平台是京东的 SNS 活动搭建平台，其内置了很多模板，每一个模板都有一个模板 JSON 用于生成表单，运营同学、商家配置了这个表单后就可以生成活动页面了。<br>模板 JSON 是标准的结构化数据，包含名称、类型、控件类型、校验器、默认值等等字段。以往都是采用手写 JSON 的方式，这是非常低效的，而且容易出错。针对其结构化数据的特点可以用 GUI 的方式去编辑，我们基于 <a href=\"http://electronjs.org\" target=\"_blank\" rel=\"noopener\">Electron</a> 参考 <a href=\"https://github.com/desktop/desktop\" target=\"_blank\" rel=\"noopener\">Github Desktop 客户端</a> 的架构编写了一个 <a href=\"http://git.jd.com/zhouquan31_repos/cubic\" target=\"_blank\" rel=\"noopener\">编辑器</a>，通过填写表单的方式生成 JSON。所以在这里记录下这个 Electron 编辑器开发过程中可以记录的点和从 Github Desktop 客户端代码中值得学习的点。</p>\n<h2 id=\"一、关于-Electron\"><a href=\"#一、关于-Electron\" class=\"headerlink\" title=\"一、关于 Electron\"></a>一、关于 Electron</h2><blockquote>\n<p>Electron是由Github开发，用HTML，CSS和JavaScript来构建跨平台桌面应用程序的一个开源库。 Electron通过将Chromium和Node.js合并到同一个运行时环境中，并将其打包为Mac，Windows和Linux系统下的应用来实现这一目的。</p>\n</blockquote>\n<p>上面是来自 Electron 官方的介绍。基于 Electron 平台，我们可以使用熟悉的前端技术栈来开发桌面应用。Electron 运行 package.json 的 main 脚本的进程被称为主进程（以下简称main）。 在主进程中运行的脚本通过创建 web 页面来展示用户界面（以下简称 renderer）。 一个 Electron 应用总是有且只有一个主进程。main 用于创建应用，创建浏览器窗口，它就是一个彻底的 Node 进程，获取不到 DOM, BOM 这些接口。在 main 创建的浏览器窗口中运行的就是 renderer 进程，它既可以获取 DOM, BOM 这些接口，也可以使用 Node 的 API。两类进程之间可以通过 Electron 提供的 IPC 接口通信。</p>\n<h2 id=\"二、开发环境搭建\"><a href=\"#二、开发环境搭建\" class=\"headerlink\" title=\"二、开发环境搭建\"></a>二、开发环境搭建</h2><p>我们了解到 Electron 分为两类进程，main 和 renderer。所以搭建开发环境时不能像普通的前端应用一样一个 webpack 配置搞定。并且我们想要实现</p>\n<ol>\n<li>一键启动开发环境</li>\n<li>一键打包</li>\n<li>一键发布</li>\n</ol>\n<p>那么就需要两个 webpack 配置文件。</p>\n<p>一个用于开发环境 – <code>webpack.dev.ts</code>。</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.dev.ts</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> mainConfig = merge({}, base.mainConfig, config, {</span><br><span class=\"line\">  watch: <span class=\"literal\">true</span></span><br><span class=\"line\">})</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> rendererConfig = merge({}, base.rendererConfig, config, {</span><br><span class=\"line\">  <span class=\"keyword\">module</span>: {</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      {</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">        use: [<span class=\"string\">'style-loader'</span>, <span class=\"string\">'css-loader'</span>],</span><br><span class=\"line\">      },</span><br><span class=\"line\">      {</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.styl$/</span>,</span><br><span class=\"line\">        use: [<span class=\"string\">'style-loader'</span>, <span class=\"string\">'css-loader'</span>, <span class=\"string\">'stylus-loader'</span>],</span><br><span class=\"line\">      }</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  },</span><br><span class=\"line\">  devServer: {</span><br><span class=\"line\">    contentBase: path.join(__dirname, base.outputDir),</span><br><span class=\"line\">    port: <span class=\"number\">8000</span>,</span><br><span class=\"line\">    hot: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    inline: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    historyApiFallback: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    writeToDisk: <span class=\"literal\">true</span></span><br><span class=\"line\">  },</span><br><span class=\"line\">})</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = [rendererConfig, mainConfig]</span><br></pre></td></tr></tbody></table></figure>\n<p>另一个用于生产环境 – <code>webpack.prod.ts</code>。</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> config: webpack.Configuration = {</span><br><span class=\"line\">  mode: <span class=\"string\">'production'</span>,</span><br><span class=\"line\">  devtool: <span class=\"string\">'source-map'</span>,</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> mainConfig = merge({}, base.mainConfig, config)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> rendererConfig = merge({}, base.rendererConfig, config, {</span><br><span class=\"line\">  <span class=\"keyword\">module</span>: {</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      {</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">        use: [MiniCssExtractPlugin.loader, <span class=\"string\">'css-loader'</span>],</span><br><span class=\"line\">      },</span><br><span class=\"line\">      {</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.styl$/</span>,</span><br><span class=\"line\">        use: [MiniCssExtractPlugin.loader, <span class=\"string\">'css-loader'</span>, <span class=\"string\">'stylus-loader'</span>],</span><br><span class=\"line\">      }</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  },</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> MiniCssExtractPlugin({ filename: <span class=\"string\">'renderer.css'</span> }),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> BundleAnalyzerPlugin({</span><br><span class=\"line\">      analyzerMode: <span class=\"string\">'static'</span>,</span><br><span class=\"line\">      openAnalyzer: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      reportFilename: <span class=\"string\">'renderer.report.html'</span>,</span><br><span class=\"line\">    }),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">})</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = [mainConfig, rendererConfig]</span><br></pre></td></tr></tbody></table></figure>\n<p>这里参考了 Desktop 使用 Typescript 编写 webpack 配置文件。配合 interface 可以实现 webpack 配置文件的编辑器自动补全。具体使用方法可参考 webpack 文档 <a href=\"https://webpack.js.org/configuration/configuration-languages/#typescript\" target=\"_blank\" rel=\"noopener\">https://webpack.js.org/configuration/configuration-languages/#typescript</a></p>\n<p>每一个配置文件导出一个数组，分别是 main, renderer 的配置对象。</p>\n<p>使用 webpack-dev-server 启动能实现 renderer 的热更新，main 则是使用 webpack 的 watch 模式。</p>\n<figure class=\"highlight json\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">{</span><br><span class=\"line\">  <span class=\"attr\">\"compile:dev\"</span>: <span class=\"string\">\"webpack-dev-server --config scripts/webpack.dev.ts\"</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>使用 <a href=\"https://nodemon.io\" target=\"_blank\" rel=\"noopener\">nodemon</a> 监听 main 编译后的产物，nodemon 监听到改动则重新运行 <code>electron .</code> 重启应用,这样间接实现了 main 的 livereload。</p>\n<blockquote>\n<p>Nodemon is a utility that will monitor for any changes in your source and automatically restart your server.</p>\n</blockquote>\n<figure class=\"highlight json\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">{</span><br><span class=\"line\">  <span class=\"attr\">\"app\"</span>: <span class=\"string\">\"electron .\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"app:watch\"</span>: <span class=\"string\">\"nodemon --watch 'dest/main.js' --exec npm run app\"</span>,</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>这样就实现了一键启动开发环境，且能够监听代码变化，重新启动应用。</p>\n<blockquote>\n<p>Tips: 开源社区有更好的 <a href=\"https://github.com/electron-userland/electron-webpack\" target=\"_blank\" rel=\"noopener\">electron-webpack</a>, HMR for both renderer and main processes</p>\n</blockquote>\n<p>生产环境则使用 webpack 顺序编译 main 和 renderer。编译完成后使用 <a href=\"https://www.electron.build\" target=\"_blank\" rel=\"noopener\">electron-builder</a> 打包。这样就实现了一键打包。</p>\n<p>由于工具链的缺失实现不了一键发布，就只能打包后手动发布了（后面详细说明）。</p>\n<p>下面就是完整的 scripts。</p>\n<figure class=\"highlight json\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">{</span><br><span class=\"line\">  <span class=\"attr\">\"scripts\"</span>: {</span><br><span class=\"line\">    <span class=\"attr\">\"start\"</span>: <span class=\"string\">\"run-p -c compile:dev typecheck:watch app:watch\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"dist\"</span>: <span class=\"string\">\"npm run compile:prod && electron-builder build --win --mac\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"compile:dev\"</span>: <span class=\"string\">\"webpack-dev-server --config scripts/webpack.dev.ts\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"compile:prod\"</span>: <span class=\"string\">\"npm run clean && webpack --config scripts/webpack.prod.ts\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"app\"</span>: <span class=\"string\">\"electron .\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"app:watch\"</span>: <span class=\"string\">\"nodemon --watch 'dest/main.js' --exec npm run app\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"clean\"</span>: <span class=\"string\">\"rimraf dest dist\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"typecheck\"</span>: <span class=\"string\">\"tsc --noEmit\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"typecheck:watch\"</span>: <span class=\"string\">\"tsc --noEmit --watch\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"lint\"</span>: <span class=\"string\">\"eslint src --ext .ts,.js --fix\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"release:patch\"</span>: <span class=\"string\">\"standard-version --release-as patch && git push --follow-tags origin master && npm run dist\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"release:minor\"</span>: <span class=\"string\">\"standard-version --release-as minor && git push --follow-tags origin master && npm run dist\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"release:major\"</span>: <span class=\"string\">\"standard-version --release-as major && git push --follow-tags origin master && npm run dist\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"repush\"</span>: <span class=\"string\">\"git push --follow-tags origin master && npm run dist\"</span></span><br><span class=\"line\">  },</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h2 id=\"三、目录结构\"><a href=\"#三、目录结构\" class=\"headerlink\" title=\"三、目录结构\"></a>三、目录结构</h2><h3 id=\"1-项目目录结构\"><a href=\"#1-项目目录结构\" class=\"headerlink\" title=\"1. 项目目录结构\"></a>1. 项目目录结构</h3><figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">src</span><br><span class=\"line\">├── lib</span><br><span class=\"line\">│   ├── cube</span><br><span class=\"line\">│   ├── databases</span><br><span class=\"line\">│   ├── enviroment</span><br><span class=\"line\">│   ├── files</span><br><span class=\"line\">│   ├── <span class=\"built_in\">local</span>-storage</span><br><span class=\"line\">│   ├── <span class=\"built_in\">log</span></span><br><span class=\"line\">│   ├── shell</span><br><span class=\"line\">│   ├── stores</span><br><span class=\"line\">│   ├── update</span><br><span class=\"line\">│   ├── validator</span><br><span class=\"line\">│   └── watcher</span><br><span class=\"line\">├── main</span><br><span class=\"line\">│   ├── app-window.ts</span><br><span class=\"line\">│   ├── event-bus.ts</span><br><span class=\"line\">│   ├── index.ts</span><br><span class=\"line\">│   ├── keyboard</span><br><span class=\"line\">│   └── menu</span><br><span class=\"line\">├── models</span><br><span class=\"line\">│   ├── popup.ts</span><br><span class=\"line\">│   └── project.ts</span><br><span class=\"line\">└── renderer</span><br><span class=\"line\">    ├── App.tsx</span><br><span class=\"line\">    ├── assets</span><br><span class=\"line\">    ├── components</span><br><span class=\"line\">    ├── index.html</span><br><span class=\"line\">    ├── index.tsx</span><br><span class=\"line\">    ├── pages</span><br><span class=\"line\">    └── types</span><br></pre></td></tr></tbody></table></figure>\n<p>在目录结构上模仿了 Desktop。main 目录存放 main 进程相关代码，包括应用入口，窗口创建，菜单，快捷键等等；而 renderer 目录则是整个 UI 渲染层的代码。lib 目录则是一些和 UI 无关也和 main 无强相关的业务逻辑代码。models 则存放一些领域模型。</p>\n<h3 id=\"2-CSS-规范\"><a href=\"#2-CSS-规范\" class=\"headerlink\" title=\"2. CSS 规范\"></a>2. CSS 规范</h3><p>在这个 React 中项目中没有使用 css-modules 这类方案。而是使用 BEM 这类能形成命名空间的规范来实现模块化，这样做的好处是能够比较好的对样式进行覆盖。</p>\n<p>在文件的组织方式上采用一个独立的 React 组件搭配一个独立的样式文件，这样在重构的时候，我们想要修改一个组件的样式只需要找到对应的样式文件进行修改即可，提高重构的效率。</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stylesheets</span><br><span class=\"line\">  ├── common.styl</span><br><span class=\"line\">  ├── components</span><br><span class=\"line\">  │   ├── editor.styl</span><br><span class=\"line\">  │   ├── empty-guide.styl</span><br><span class=\"line\">  │   ├── find-in-page.styl</span><br><span class=\"line\">  │   ├── reindex.styl</span><br><span class=\"line\">  │   ├── sidebar.styl</span><br><span class=\"line\">  │   ├── source-viewer.styl</span><br><span class=\"line\">  │   └── upload.styl</span><br><span class=\"line\">  ├── index.styl</span><br><span class=\"line\">  └── reset.styl</span><br></pre></td></tr></tbody></table></figure>\n<h2 id=\"三、IPC-通信\"><a href=\"#三、IPC-通信\" class=\"headerlink\" title=\"三、IPC 通信\"></a>三、IPC 通信</h2><blockquote>\n<p>进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息。 </p>\n</blockquote>\n<p>Electron 的 main 进程和 renderer 进程的通信是通过 Electron 提供的 <code>ipcMain</code> 和 <code>ipcRenderer</code> 来实现的。</p>\n<h3 id=\"1-main-端\"><a href=\"#1-main-端\" class=\"headerlink\" title=\"1. main 端\"></a>1. main 端</h3><p>在 main 中向某一个窗口 renderer 发送消息可以使用 <code>window.webContents.send</code>。<br>在 main 端监听 renderer 消息可以使用 <code>ipcMain.on</code>。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在主进程中.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> { ipcMain } = <span class=\"built_in\">require</span>(<span class=\"string\">'electron'</span>)</span><br><span class=\"line\">ipcMain.on(<span class=\"string\">'asynchronous-message'</span>, (event, arg) => {</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arg) <span class=\"comment\">// prints \"ping\"</span></span><br><span class=\"line\">  event.reply(<span class=\"string\">'asynchronous-reply'</span>, <span class=\"string\">'pong'</span>)</span><br><span class=\"line\">})</span><br><span class=\"line\"></span><br><span class=\"line\">ipcMain.on(<span class=\"string\">'synchronous-message'</span>, (event, arg) => {</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arg) <span class=\"comment\">// prints \"ping\"</span></span><br><span class=\"line\">  event.returnValue = <span class=\"string\">'pong'</span></span><br><span class=\"line\">})</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"2-renderer-端\"><a href=\"#2-renderer-端\" class=\"headerlink\" title=\"2. renderer 端\"></a>2. renderer 端</h3><p>回复同步消息可以使用 <code>event.returnValue</code>。同步消息的返回值可以直接读取。<br>回复异步消息可以使用 <code>event.reply</code>。那么在 renderer 就要监听回复的 channel 得到返回值。</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在渲染器进程 (网页) 中。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> { ipcRenderer } = <span class=\"built_in\">require</span>(<span class=\"string\">'electron'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(ipcRenderer.sendSync(<span class=\"string\">'synchronous-message'</span>, <span class=\"string\">'ping'</span>)) <span class=\"comment\">// prints \"pong\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">ipcRenderer.on(<span class=\"string\">'asynchronous-reply'</span>, <span class=\"function\">(<span class=\"params\">event, arg</span>) =></span> {</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arg) <span class=\"comment\">// prints \"pong\"</span></span><br><span class=\"line\">})</span><br><span class=\"line\">ipcRenderer.send(<span class=\"string\">'asynchronous-message'</span>, <span class=\"string\">'ping'</span>)</span><br></pre></td></tr></tbody></table></figure>\n<p>可以看到 renderer 可以使用 <code>ipcRenderer.send</code> 向主进程发送异步消息。用 <code>ipcRenderer.sendSync</code> 发送同步消息。</p>\n<h2 id=\"四、数据持久化及状态管理\"><a href=\"#四、数据持久化及状态管理\" class=\"headerlink\" title=\"四、数据持久化及状态管理\"></a>四、数据持久化及状态管理</h2><h3 id=\"1-复杂数据持久化\"><a href=\"#1-复杂数据持久化\" class=\"headerlink\" title=\"1. 复杂数据持久化\"></a>1. 复杂数据持久化</h3><p>数据持久化可选的方案有很多，比如 <a href=\"https://github.com/sindresorhus/electron-store#readme\" target=\"_blank\" rel=\"noopener\">electron-store</a>等基于 JSON 文件实现的存储方案。对于更复杂的应用场景还可以使用 <a href=\"https://github.com/typicode/lowdb\" target=\"_blank\" rel=\"noopener\">lowdb</a>，<a href=\"https://github.com/louischatriot/nedb\" target=\"_blank\" rel=\"noopener\">nedb</a> ，<code>sqlite</code>等。</p>\n<p>最初我使用的是 <code>electron-store</code>, 并且一直有一个执念是对磁盘的读写只能在 main 进程进行，renderer 进程只负责渲染界面。所以在最初设计的是在 renderer 进程渲染数据或者更新数据的时候都需要通过 IPC 到 main 进程来完成最终的磁盘读写。除去读写正常的情况，还要考虑读写磁盘的异常，这样导致数据流异常的绕。而且还需要自己维护 ID 的生成。借鉴了 Desktop 的代码后，重构了数据持久化部分，也采用了 <a href=\"https://github.com/dfahlander/Dexie.js\" target=\"_blank\" rel=\"noopener\">Dexie</a>，它是对浏览器标准数据库 indexedDB 的一个封装。从它的 Readme 可以看到它主要解决了indexedDB 的三个问题：</p>\n<ol>\n<li>不明确的异常处理</li>\n<li>查询很烂</li>\n<li>代码复杂</li>\n</ol>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Dexie <span class=\"keyword\">from</span> <span class=\"string\">'dexie'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> IDatabaseProject {</span><br><span class=\"line\">  id?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  filePath: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> ProjectsDatabase <span class=\"keyword\">extends</span> Dexie {</span><br><span class=\"line\">  <span class=\"keyword\">public</span> projects: Dexie.Table<IDatabaseProject, <span class=\"built_in\">number</span>>;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(<span class=\"string\">'ProjectsDatabase'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.version(<span class=\"number\">1</span>).stores({</span><br><span class=\"line\">      projects: <span class=\"string\">'++id,&name,&filePath'</span>,</span><br><span class=\"line\">    });</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.projects = <span class=\"keyword\">this</span>.table(<span class=\"string\">'projects'</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>继承 Dexie 来实现我们自己的数据库类，在构造函数中声明数据库的版本，表的 schema 等等。具体可以参考 <a href=\"https://dexie.org/docs/\" target=\"_blank\" rel=\"noopener\">Dexie 官方文档</a>。</p>\n<h3 id=\"2-简单数据持久化\"><a href=\"#2-简单数据持久化\" class=\"headerlink\" title=\"2. 简单数据持久化\"></a>2. 简单数据持久化</h3><p>一些 UI 状态的标志位存储（比如某个弹窗是否显示过），我们一般会把这种标志位存储到 <code>localStorage</code> 中。<br>在查看 Desktop 的源码过程中，发现他们对 <code>number</code>, <code>boolean</code> 类型的数据的 get, set 进行了简单的封装。使用起来非常方便，这里贴一下对于 <code>boolean</code> 型数据的处理。</p>\n<figure class=\"highlight typescript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getBoolean</span>(<span class=\"params\">key: <span class=\"built_in\">string</span></span>): <span class=\"title\">boolean</span> | <span class=\"title\">undefined</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getBoolean</span>(<span class=\"params\">key: <span class=\"built_in\">string</span>, defaultValue: <span class=\"built_in\">boolean</span></span>): <span class=\"title\">boolean</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\"><span class=\"title\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getBoolean</span>(<span class=\"params\"></span></span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\"><span class=\"function\"><span class=\"params\">  key: <span class=\"built_in\">string</span>,</span></span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\"><span class=\"function\"><span class=\"params\">  defaultValue?: <span class=\"built_in\">boolean</span></span></span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">boolean</span> | <span class=\"title\">undefined</span> </span>{</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\">  <span class=\"title\">const</span> <span class=\"title\">value</span> = <span class=\"title\">localStorage</span>.<span class=\"title\">getItem</span>(<span class=\"params\">key</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\">  <span class=\"title\">if</span> (<span class=\"params\">value === <span class=\"literal\">null</span></span>) </span>{</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">return</span> <span class=\"title\">defaultValue</span></span></span><br><span class=\"line\"><span class=\"function\">  }</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"title\">if</span> (<span class=\"params\">value === '1' || value === '<span class=\"literal\">true</span>'</span>) </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (value === <span class=\"string\">'0'</span> || value === <span class=\"string\">'false'</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> defaultValue</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setBoolean</span>(<span class=\"params\">key: <span class=\"built_in\">string</span>, value: <span class=\"built_in\">boolean</span></span>) </span>{</span><br><span class=\"line\">  localStorage.setItem(key, value ? <span class=\"string\">'1'</span> : <span class=\"string\">'0'</span>)</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p><a href=\"https://github.com/desktop/desktop/blob/development/app/src/lib/local-storage.ts\" target=\"_blank\" rel=\"noopener\">源码详见</a></p>\n<h2 id=\"五、功能实现\"><a href=\"#五、功能实现\" class=\"headerlink\" title=\"五、功能实现\"></a>五、功能实现</h2><h3 id=\"1-磁盘-编辑器版本实时同步\"><a href=\"#1-磁盘-编辑器版本实时同步\" class=\"headerlink\" title=\"1. 磁盘/编辑器版本实时同步\"></a>1. 磁盘/编辑器版本实时同步</h3><p>一般情况下，在编辑器中我们编辑的内容其实是编辑器读取磁盘文件到内存中的副本。所以说如果磁盘的文件发生了改动，比如 Git 切换分支造成文件变动，抑或是删除了磁盘文件，重命名等等都会造成内存版本和磁盘版本的不一致，即磁盘版本领先于内存版本，这个时候就可能产生冲突。解决这个问题很简单，可以使用 fs.watch/watchFile 监听当前编辑的文件，一旦发生变化，就重新读取磁盘版本，更新内存版本来实现同步。但是 fs.watch 这个 API 在工程上不是可以开箱即用的，有许多兼容问题和一些 bug。比如说</p>\n<p>Node.js fs.watch:</p>\n<ul>\n<li>Doesn’t report filenames on MacOS.</li>\n<li>Doesn’t report events at all when using editors like Sublime on MacOS.</li>\n<li>Often reports events twice.</li>\n<li>Emits most changes as rename.</li>\n<li>Does not provide an easy way to recursively watch file trees.</li>\n</ul>\n<p>Node.js fs.watchFile:</p>\n<ul>\n<li>Almost as bad at event handling.</li>\n<li>Also does not provide any recursive watching.</li>\n<li>Results in high CPU utilization.</li>\n</ul>\n<p>上面列举的点来自 <a href=\"https://github.com/paulmillr/chokidar\" target=\"_blank\" rel=\"noopener\">chokidar</a>，它是一个 Node 模块，提供了开箱可用的监听文件变化的能力。只需要监听 <code>add</code>, <code>unlink</code>, <code>change</code> 等事件读取最新版本的文本到编辑器就可以实现磁盘/编辑器版本的同步了。</p>\n<h3 id=\"2-Context-Menu\"><a href=\"#2-Context-Menu\" class=\"headerlink\" title=\"2. Context-Menu\"></a>2. Context-Menu</h3><p>Desktop 的 <code>contextmenu</code> (右键菜单)的实现基于原生 IPC 的，比较绕。</p>\n<p>首先我们需要知道的是 <code>Menu</code> 类是 <code>main process only</code> 的。</p>\n<p>在需要 <code>contextmenu</code> 的 <code>JSX.Element</code> 上绑定 <code>onContextMenu</code> 事件。构造对象数组 <code>Array<MenuItem></code>, 并且为每个 MenuItem 对象绑定触发事件，再通过 IPC 将对象传递至 main 进程，值得一提的是这个时候将 MenuItem 数组赋值给了一个全局对象，暂存起来。在 main 进程构造出真正的 MenuItem 实例，绑定 MenuItem 的点击事件，触发 MenuItem 点击事件的时候记录 MenuItem 的 序列号 index，再将 index 通过 event.sender.send 将 index 传递到 renderer 进程。renderer 进程拿到 index 之后根据之前保存的全局对象取出单个 MenuItem， 执行绑定的事件。</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onContextMenu => showContextualMenu (暂存MenuItems，ipcRenderer.send) => icpMain => menu.popup() => MenuItem.onClick(index) => event.sernder.send(index) => MenuItem.action()</span><br></pre></td></tr></tbody></table></figure>\n<p>所以在我的应用中使用了 remote 对象屏蔽上述复杂的 IPC 通信。在 renderer 进程完成 Menu 的构造展示和事件的绑定触发。</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { remote } <span class=\"keyword\">from</span> <span class=\"string\">'electron'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> { MenuItem, dialog, getCurrentWindow, Menu } = remote;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> onContextMenu = <span class=\"function\">(<span class=\"params\">project: Project</span>) =></span> {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> menu = <span class=\"keyword\">new</span> Menu();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> menus = [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> MenuItem({</span><br><span class=\"line\">      label: <span class=\"string\">'在终端中打开'</span>,</span><br><span class=\"line\">      visible: __DARWIN__,</span><br><span class=\"line\">      click() {</span><br><span class=\"line\">        <span class=\"keyword\">const</span> accessor = <span class=\"keyword\">new</span> FileAccessor(project.filePath);</span><br><span class=\"line\">        accessor.openInTerminal();</span><br><span class=\"line\">      },</span><br><span class=\"line\">    }),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> MenuItem({</span><br><span class=\"line\">      label: <span class=\"string\">'在 vscode 中打开'</span>,</span><br><span class=\"line\">      click() {</span><br><span class=\"line\">        <span class=\"keyword\">const</span> accessor = <span class=\"keyword\">new</span> FileAccessor(project.filePath);</span><br><span class=\"line\">        accessor.openInVscode();</span><br><span class=\"line\">      },</span><br><span class=\"line\">    }),</span><br><span class=\"line\">  ];</span><br><span class=\"line\"></span><br><span class=\"line\">  menus.forEach(menu.append);</span><br><span class=\"line\">  menu.popup({ <span class=\"built_in\">window</span>: getCurrentWindow() });</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n<h2 id=\"六、日志\"><a href=\"#六、日志\" class=\"headerlink\" title=\"六、日志\"></a>六、日志</h2><p>完善的日志不论是开发环境还是生产环境都是非常重要的，大致记录 UI 状态迁移背后的数据变动，流程的分支走向，能很好的辅助开发。</p>\n<p>参考 Desktop，他们的日志基于日志库：<a href=\"https://github.com/winstonjs/winston#readme\" target=\"_blank\" rel=\"noopener\">winston</a>。</p>\n<p>在 main 进程和 renderer 进程都提供了全局 log 对象，接口都是一致的。分别是 <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code>。在 renderer 进程，简单的封装了 <code>window.console</code> 对象上的 <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code> 方法，日志打印到浏览器控制台的时候也通过 IPC 传递到 main 进程，由 main 进程统一管理。 </p>\n<p>main 进程接收了来自 renderer 进程的日志信息和 main 进程自身的日志信息。设置了两个 <code>transports</code>。<code>winston.transports.Console</code> 和 <code>winston.transports.DailyRotateFile</code> 分别用于将日志信息打印在终端控制台和存储在磁盘文件。DailyRotateFile 以天为单位，设置了最多存储 14 天的上限。</p>\n<p>在 main 进程和 renderer 进程启动时分别引入日志安装模块。因为 log 方法都是暴露在全局，因此只需要在进程启动时引入一次即可。同时在 TS 环境中还需要添加 log 方法的类型声明。</p>\n<h2 id=\"七、打包，发布及更新\"><a href=\"#七、打包，发布及更新\" class=\"headerlink\" title=\"七、打包，发布及更新\"></a>七、打包，发布及更新</h2><p>开源世界已经有非常完善的打包和发布的工具 – <a href=\"https://www.electron.build\" target=\"_blank\" rel=\"noopener\">electron-builder</a>。它集多平台打包，签名，自动更新，发布到Github等平台等等功能于一身。</p>\n<p>鉴于这个工具只能在内网使用，不能发布到 Github 而且也没有没有苹果开发者工具无法进行签名，只能利用 <code>electron-builder</code> 在本机打包，发布的话只能使用手动打包上传了，用户也只能手动下载安装包覆盖安装，不能像 VSCODE 这样实现自动更新。</p>\n<p>既然不能自动更新，那么新版本下发后，如何通知到用户去下载新版本安装包更新呢？<br>从用户这一端来看，在应用每次启动的时候可以做一次请求，查询是否有版本更新，或者是在应用菜单栏提供入口，让用户手动触发更新查询。查询到服务端的最新版本后，使用 <a href=\"https://www.npmjs.com/package/semver\" target=\"_blank\" rel=\"noopener\">sermver</a> 比较本机版本是否低于服务器版本，如果是就下发通知给用户，提示用户去下载更新。</p>\n<p>在有限的条件下怎么实现这个功能呢？</p>\n<p>实现这个功能必需的三个元素：服务端标识着最新版本的可读文件；托管各个版本安装包的云空间；应用代码中的更新逻辑。</p>\n<p>服务端标识着最新版本的可读文件：每次打包时都会更新 <code>package.json</code>，所以我们直接把 <code>package.json</code> 上传到某个不带鉴权的 CDN 就可以，更新的时候就请求这个文件。</p>\n<p>托管各个版本安装包的云空间：这个可以使用云盘，云盘可以生成分享链接，把这个链接手动拷贝到 Gitlab 该版本的 tag 的 Notes 中。</p>\n<p>应用代码中的更新逻辑：</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> got <span class=\"keyword\">from</span> <span class=\"string\">'got'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> semver <span class=\"keyword\">from</span> <span class=\"string\">'semver'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> { app, remote, BrowserWindow } <span class=\"keyword\">from</span> <span class=\"string\">'electron'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> realApp = app || remote.app;</span><br><span class=\"line\"><span class=\"keyword\">const</span> currentVersion = realApp.getVersion();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkForUpdates</span>(<span class=\"params\"><span class=\"built_in\">window</span>: BrowserWindow, silent: <span class=\"built_in\">boolean</span> = <span class=\"literal\">false</span></span>) </span>{</span><br><span class=\"line\">  <span class=\"keyword\">const</span> url = <span class=\"string\">`http://yourcdn/package.json?t=<span class=\"subst\">${Date.now()}</span>`</span>;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> got(url);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> pkg = <span class=\"built_in\">JSON</span>.parse(response.body);</span><br><span class=\"line\">    log.debug(<span class=\"string\">'检查更新，云端版本：'</span>, pkg.version);</span><br><span class=\"line\">    log.debug(<span class=\"string\">'当前版本'</span>, currentVersion);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (semver.lt(currentVersion, pkg.version)) {</span><br><span class=\"line\">      <span class=\"built_in\">window</span>.webContents.send(<span class=\"string\">'update-available'</span>, pkg.version);</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">      <span class=\"built_in\">window</span>.webContents.send(<span class=\"string\">'update-not-available'</span>, silent);</span><br><span class=\"line\">    }</span><br><span class=\"line\">  } <span class=\"keyword\">catch</span> (error) {</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.webContents.send(<span class=\"string\">'update-error'</span>, silent);</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>分别在应用主进程启动、用户点击应用菜单<code>检查更新</code>时调用这个方法，从而通知 UI 进程下发通知。我们期望应用主进程启动时的更新是在失败或者无更新时是静默的，不用打扰用户，所以在 IPC 管道可以提供一个 <code>silent</code> 参数。检测到更新后就可以通知用户，用户点击更新后就可以跳转到最新版本的 Gitlab tags ，引导用户下载最新版本进行手动安装。</p>\n<h2 id=\"八、其他\"><a href=\"#八、其他\" class=\"headerlink\" title=\"八、其他\"></a>八、其他</h2><h3 id=\"1-devtools\"><a href=\"#1-devtools\" class=\"headerlink\" title=\"1. devtools\"></a>1. devtools</h3><p>开发 Electron 应用中 renderer 端也是使用 Chrome devtools 来调试的。对于 React, Mobx 这类框的 devtools 扩展也可以通过 <code>electron-devtools-installer</code> 来安装。应用窗口创建之后调用<code>electron-devtools-installer</code> 进行 <code>mobx</code>、<code>react</code> 等扩展的安装。</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> { <span class=\"keyword\">default</span>: installExtension, MOBX_DEVTOOLS, REACT_DEVELOPER_TOOLS } = <span class=\"built_in\">require</span>(<span class=\"string\">'electron-devtools-installer'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> extensions = [REACT_DEVELOPER_TOOLS, MOBX_DEVTOOLS];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> extension of extensions) {</span><br><span class=\"line\">  <span class=\"keyword\">try</span> {</span><br><span class=\"line\">    installExtension(extension);</span><br><span class=\"line\">  } <span class=\"keyword\">catch</span> (e) {</span><br><span class=\"line\">    <span class=\"comment\">// log.error(e);</span></span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h2 id=\"2-保持窗口大小\"><a href=\"#2-保持窗口大小\" class=\"headerlink\" title=\"2. 保持窗口大小\"></a>2. 保持窗口大小</h2><p>对于桌面应用，一个常见的需求就是关闭后重新打开，需要恢复到上次打开时的窗口大小，位置。实现这个比较简单，监听窗口的 resize 事件，把窗口信息记录到当前用户的应用数据文件夹, 即 <code>app.getPath(appData)</code>。下次启动应用创建窗口时读取这个文件设置窗口信息即可。开源社区已经有对这个功能封装好的库：<a href=\"https://github.com/mawie81/electron-window-state#readme\" target=\"_blank\" rel=\"noopener\">electron-window-state</a></p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> windowStateKeeper = <span class=\"built_in\">require</span>(<span class=\"string\">'electron-window-state'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> win;</span><br><span class=\"line\"></span><br><span class=\"line\">app.on(<span class=\"string\">'ready'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>{</span><br><span class=\"line\">  <span class=\"keyword\">let</span> mainWindowState = windowStateKeeper({</span><br><span class=\"line\">    defaultWidth: <span class=\"number\">1000</span>,</span><br><span class=\"line\">    defaultHeight: <span class=\"number\">800</span></span><br><span class=\"line\">  });</span><br><span class=\"line\"></span><br><span class=\"line\">  win = <span class=\"keyword\">new</span> BrowserWindow({</span><br><span class=\"line\">    <span class=\"string\">'x'</span>: mainWindowState.x,</span><br><span class=\"line\">    <span class=\"string\">'y'</span>: mainWindowState.y,</span><br><span class=\"line\">    <span class=\"string\">'width'</span>: mainWindowState.width,</span><br><span class=\"line\">    <span class=\"string\">'height'</span>: mainWindowState.height</span><br><span class=\"line\">  });</span><br><span class=\"line\"></span><br><span class=\"line\">  mainWindowState.manage(win);</span><br><span class=\"line\">});</span><br></pre></td></tr></tbody></table></figure>\n<p>只需要提供缺省窗口大小，剩余的事情 <code>electron-window-state</code> 都帮我们搞定了。</p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"excerpt":"","more":"<p>社交魔方平台是京东的 SNS 活动搭建平台，其内置了很多模板，每一个模板都有一个模板 JSON 用于生成表单，运营同学、商家配置了这个表单后就可以生成活动页面了。<br>模板 JSON 是标准的结构化数据，包含名称、类型、控件类型、校验器、默认值等等字段。以往都是采用手写 JSON 的方式，这是非常低效的，而且容易出错。针对其结构化数据的特点可以用 GUI 的方式去编辑，我们基于 <a href=\"http://electronjs.org\" target=\"_blank\" rel=\"noopener\">Electron</a> 参考 <a href=\"https://github.com/desktop/desktop\" target=\"_blank\" rel=\"noopener\">Github Desktop 客户端</a> 的架构编写了一个 <a href=\"http://git.jd.com/zhouquan31_repos/cubic\" target=\"_blank\" rel=\"noopener\">编辑器</a>，通过填写表单的方式生成 JSON。所以在这里记录下这个 Electron 编辑器开发过程中可以记录的点和从 Github Desktop 客户端代码中值得学习的点。</p>\n<h2 id=\"一、关于-Electron\"><a href=\"#一、关于-Electron\" class=\"headerlink\" title=\"一、关于 Electron\"></a>一、关于 Electron</h2><blockquote>\n<p>Electron是由Github开发，用HTML，CSS和JavaScript来构建跨平台桌面应用程序的一个开源库。 Electron通过将Chromium和Node.js合并到同一个运行时环境中，并将其打包为Mac，Windows和Linux系统下的应用来实现这一目的。</p>\n</blockquote>\n<p>上面是来自 Electron 官方的介绍。基于 Electron 平台，我们可以使用熟悉的前端技术栈来开发桌面应用。Electron 运行 package.json 的 main 脚本的进程被称为主进程（以下简称main）。 在主进程中运行的脚本通过创建 web 页面来展示用户界面（以下简称 renderer）。 一个 Electron 应用总是有且只有一个主进程。main 用于创建应用，创建浏览器窗口，它就是一个彻底的 Node 进程，获取不到 DOM, BOM 这些接口。在 main 创建的浏览器窗口中运行的就是 renderer 进程，它既可以获取 DOM, BOM 这些接口，也可以使用 Node 的 API。两类进程之间可以通过 Electron 提供的 IPC 接口通信。</p>\n<h2 id=\"二、开发环境搭建\"><a href=\"#二、开发环境搭建\" class=\"headerlink\" title=\"二、开发环境搭建\"></a>二、开发环境搭建</h2><p>我们了解到 Electron 分为两类进程，main 和 renderer。所以搭建开发环境时不能像普通的前端应用一样一个 webpack 配置搞定。并且我们想要实现</p>\n<ol>\n<li>一键启动开发环境</li>\n<li>一键打包</li>\n<li>一键发布</li>\n</ol>\n<p>那么就需要两个 webpack 配置文件。</p>\n<p>一个用于开发环境 – <code>webpack.dev.ts</code>。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.dev.ts</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> mainConfig = merge(&#123;&#125;, base.mainConfig, config, &#123;</span><br><span class=\"line\">  watch: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> rendererConfig = merge(&#123;&#125;, base.rendererConfig, config, &#123;</span><br><span class=\"line\">  <span class=\"keyword\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">        use: [<span class=\"string\">'style-loader'</span>, <span class=\"string\">'css-loader'</span>],</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.styl$/</span>,</span><br><span class=\"line\">        use: [<span class=\"string\">'style-loader'</span>, <span class=\"string\">'css-loader'</span>, <span class=\"string\">'stylus-loader'</span>],</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  devServer: &#123;</span><br><span class=\"line\">    contentBase: path.join(__dirname, base.outputDir),</span><br><span class=\"line\">    port: <span class=\"number\">8000</span>,</span><br><span class=\"line\">    hot: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    inline: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    historyApiFallback: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    writeToDisk: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = [rendererConfig, mainConfig]</span><br></pre></td></tr></table></figure>\n<p>另一个用于生产环境 – <code>webpack.prod.ts</code>。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> config: webpack.Configuration = &#123;</span><br><span class=\"line\">  mode: <span class=\"string\">'production'</span>,</span><br><span class=\"line\">  devtool: <span class=\"string\">'source-map'</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> mainConfig = merge(&#123;&#125;, base.mainConfig, config)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> rendererConfig = merge(&#123;&#125;, base.rendererConfig, config, &#123;</span><br><span class=\"line\">  <span class=\"keyword\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">        use: [MiniCssExtractPlugin.loader, <span class=\"string\">'css-loader'</span>],</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.styl$/</span>,</span><br><span class=\"line\">        use: [MiniCssExtractPlugin.loader, <span class=\"string\">'css-loader'</span>, <span class=\"string\">'stylus-loader'</span>],</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> MiniCssExtractPlugin(&#123; filename: <span class=\"string\">'renderer.css'</span> &#125;),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> BundleAnalyzerPlugin(&#123;</span><br><span class=\"line\">      analyzerMode: <span class=\"string\">'static'</span>,</span><br><span class=\"line\">      openAnalyzer: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      reportFilename: <span class=\"string\">'renderer.report.html'</span>,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = [mainConfig, rendererConfig]</span><br></pre></td></tr></table></figure>\n<p>这里参考了 Desktop 使用 Typescript 编写 webpack 配置文件。配合 interface 可以实现 webpack 配置文件的编辑器自动补全。具体使用方法可参考 webpack 文档 <a href=\"https://webpack.js.org/configuration/configuration-languages/#typescript\" target=\"_blank\" rel=\"noopener\">https://webpack.js.org/configuration/configuration-languages/#typescript</a></p>\n<p>每一个配置文件导出一个数组，分别是 main, renderer 的配置对象。</p>\n<p>使用 webpack-dev-server 启动能实现 renderer 的热更新，main 则是使用 webpack 的 watch 模式。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"compile:dev\"</span>: <span class=\"string\">\"webpack-dev-server --config scripts/webpack.dev.ts\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用 <a href=\"https://nodemon.io\" target=\"_blank\" rel=\"noopener\">nodemon</a> 监听 main 编译后的产物，nodemon 监听到改动则重新运行 <code>electron .</code> 重启应用,这样间接实现了 main 的 livereload。</p>\n<blockquote>\n<p>Nodemon is a utility that will monitor for any changes in your source and automatically restart your server.</p>\n</blockquote>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"app\"</span>: <span class=\"string\">\"electron .\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"app:watch\"</span>: <span class=\"string\">\"nodemon --watch 'dest/main.js' --exec npm run app\"</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就实现了一键启动开发环境，且能够监听代码变化，重新启动应用。</p>\n<blockquote>\n<p>Tips: 开源社区有更好的 <a href=\"https://github.com/electron-userland/electron-webpack\" target=\"_blank\" rel=\"noopener\">electron-webpack</a>, HMR for both renderer and main processes</p>\n</blockquote>\n<p>生产环境则使用 webpack 顺序编译 main 和 renderer。编译完成后使用 <a href=\"https://www.electron.build\" target=\"_blank\" rel=\"noopener\">electron-builder</a> 打包。这样就实现了一键打包。</p>\n<p>由于工具链的缺失实现不了一键发布，就只能打包后手动发布了（后面详细说明）。</p>\n<p>下面就是完整的 scripts。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"start\"</span>: <span class=\"string\">\"run-p -c compile:dev typecheck:watch app:watch\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"dist\"</span>: <span class=\"string\">\"npm run compile:prod &amp;&amp; electron-builder build --win --mac\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"compile:dev\"</span>: <span class=\"string\">\"webpack-dev-server --config scripts/webpack.dev.ts\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"compile:prod\"</span>: <span class=\"string\">\"npm run clean &amp;&amp; webpack --config scripts/webpack.prod.ts\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"app\"</span>: <span class=\"string\">\"electron .\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"app:watch\"</span>: <span class=\"string\">\"nodemon --watch 'dest/main.js' --exec npm run app\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"clean\"</span>: <span class=\"string\">\"rimraf dest dist\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"typecheck\"</span>: <span class=\"string\">\"tsc --noEmit\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"typecheck:watch\"</span>: <span class=\"string\">\"tsc --noEmit --watch\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"lint\"</span>: <span class=\"string\">\"eslint src --ext .ts,.js --fix\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"release:patch\"</span>: <span class=\"string\">\"standard-version --release-as patch &amp;&amp; git push --follow-tags origin master &amp;&amp; npm run dist\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"release:minor\"</span>: <span class=\"string\">\"standard-version --release-as minor &amp;&amp; git push --follow-tags origin master &amp;&amp; npm run dist\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"release:major\"</span>: <span class=\"string\">\"standard-version --release-as major &amp;&amp; git push --follow-tags origin master &amp;&amp; npm run dist\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"repush\"</span>: <span class=\"string\">\"git push --follow-tags origin master &amp;&amp; npm run dist\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"三、目录结构\"><a href=\"#三、目录结构\" class=\"headerlink\" title=\"三、目录结构\"></a>三、目录结构</h2><h3 id=\"1-项目目录结构\"><a href=\"#1-项目目录结构\" class=\"headerlink\" title=\"1. 项目目录结构\"></a>1. 项目目录结构</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">src</span><br><span class=\"line\">├── lib</span><br><span class=\"line\">│   ├── cube</span><br><span class=\"line\">│   ├── databases</span><br><span class=\"line\">│   ├── enviroment</span><br><span class=\"line\">│   ├── files</span><br><span class=\"line\">│   ├── <span class=\"built_in\">local</span>-storage</span><br><span class=\"line\">│   ├── <span class=\"built_in\">log</span></span><br><span class=\"line\">│   ├── shell</span><br><span class=\"line\">│   ├── stores</span><br><span class=\"line\">│   ├── update</span><br><span class=\"line\">│   ├── validator</span><br><span class=\"line\">│   └── watcher</span><br><span class=\"line\">├── main</span><br><span class=\"line\">│   ├── app-window.ts</span><br><span class=\"line\">│   ├── event-bus.ts</span><br><span class=\"line\">│   ├── index.ts</span><br><span class=\"line\">│   ├── keyboard</span><br><span class=\"line\">│   └── menu</span><br><span class=\"line\">├── models</span><br><span class=\"line\">│   ├── popup.ts</span><br><span class=\"line\">│   └── project.ts</span><br><span class=\"line\">└── renderer</span><br><span class=\"line\">    ├── App.tsx</span><br><span class=\"line\">    ├── assets</span><br><span class=\"line\">    ├── components</span><br><span class=\"line\">    ├── index.html</span><br><span class=\"line\">    ├── index.tsx</span><br><span class=\"line\">    ├── pages</span><br><span class=\"line\">    └── types</span><br></pre></td></tr></table></figure>\n<p>在目录结构上模仿了 Desktop。main 目录存放 main 进程相关代码，包括应用入口，窗口创建，菜单，快捷键等等；而 renderer 目录则是整个 UI 渲染层的代码。lib 目录则是一些和 UI 无关也和 main 无强相关的业务逻辑代码。models 则存放一些领域模型。</p>\n<h3 id=\"2-CSS-规范\"><a href=\"#2-CSS-规范\" class=\"headerlink\" title=\"2. CSS 规范\"></a>2. CSS 规范</h3><p>在这个 React 中项目中没有使用 css-modules 这类方案。而是使用 BEM 这类能形成命名空间的规范来实现模块化，这样做的好处是能够比较好的对样式进行覆盖。</p>\n<p>在文件的组织方式上采用一个独立的 React 组件搭配一个独立的样式文件，这样在重构的时候，我们想要修改一个组件的样式只需要找到对应的样式文件进行修改即可，提高重构的效率。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stylesheets</span><br><span class=\"line\">  ├── common.styl</span><br><span class=\"line\">  ├── components</span><br><span class=\"line\">  │   ├── editor.styl</span><br><span class=\"line\">  │   ├── empty-guide.styl</span><br><span class=\"line\">  │   ├── find-in-page.styl</span><br><span class=\"line\">  │   ├── reindex.styl</span><br><span class=\"line\">  │   ├── sidebar.styl</span><br><span class=\"line\">  │   ├── source-viewer.styl</span><br><span class=\"line\">  │   └── upload.styl</span><br><span class=\"line\">  ├── index.styl</span><br><span class=\"line\">  └── reset.styl</span><br></pre></td></tr></table></figure>\n<h2 id=\"三、IPC-通信\"><a href=\"#三、IPC-通信\" class=\"headerlink\" title=\"三、IPC 通信\"></a>三、IPC 通信</h2><blockquote>\n<p>进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息。 </p>\n</blockquote>\n<p>Electron 的 main 进程和 renderer 进程的通信是通过 Electron 提供的 <code>ipcMain</code> 和 <code>ipcRenderer</code> 来实现的。</p>\n<h3 id=\"1-main-端\"><a href=\"#1-main-端\" class=\"headerlink\" title=\"1. main 端\"></a>1. main 端</h3><p>在 main 中向某一个窗口 renderer 发送消息可以使用 <code>window.webContents.send</code>。<br>在 main 端监听 renderer 消息可以使用 <code>ipcMain.on</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在主进程中.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; ipcMain &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'electron'</span>)</span><br><span class=\"line\">ipcMain.on(<span class=\"string\">'asynchronous-message'</span>, (event, arg) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arg) <span class=\"comment\">// prints \"ping\"</span></span><br><span class=\"line\">  event.reply(<span class=\"string\">'asynchronous-reply'</span>, <span class=\"string\">'pong'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">ipcMain.on(<span class=\"string\">'synchronous-message'</span>, (event, arg) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arg) <span class=\"comment\">// prints \"ping\"</span></span><br><span class=\"line\">  event.returnValue = <span class=\"string\">'pong'</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-renderer-端\"><a href=\"#2-renderer-端\" class=\"headerlink\" title=\"2. renderer 端\"></a>2. renderer 端</h3><p>回复同步消息可以使用 <code>event.returnValue</code>。同步消息的返回值可以直接读取。<br>回复异步消息可以使用 <code>event.reply</code>。那么在 renderer 就要监听回复的 channel 得到返回值。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在渲染器进程 (网页) 中。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; ipcRenderer &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'electron'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(ipcRenderer.sendSync(<span class=\"string\">'synchronous-message'</span>, <span class=\"string\">'ping'</span>)) <span class=\"comment\">// prints \"pong\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">ipcRenderer.on(<span class=\"string\">'asynchronous-reply'</span>, <span class=\"function\">(<span class=\"params\">event, arg</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arg) <span class=\"comment\">// prints \"pong\"</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">ipcRenderer.send(<span class=\"string\">'asynchronous-message'</span>, <span class=\"string\">'ping'</span>)</span><br></pre></td></tr></table></figure>\n<p>可以看到 renderer 可以使用 <code>ipcRenderer.send</code> 向主进程发送异步消息。用 <code>ipcRenderer.sendSync</code> 发送同步消息。</p>\n<h2 id=\"四、数据持久化及状态管理\"><a href=\"#四、数据持久化及状态管理\" class=\"headerlink\" title=\"四、数据持久化及状态管理\"></a>四、数据持久化及状态管理</h2><h3 id=\"1-复杂数据持久化\"><a href=\"#1-复杂数据持久化\" class=\"headerlink\" title=\"1. 复杂数据持久化\"></a>1. 复杂数据持久化</h3><p>数据持久化可选的方案有很多，比如 <a href=\"https://github.com/sindresorhus/electron-store#readme\" target=\"_blank\" rel=\"noopener\">electron-store</a>等基于 JSON 文件实现的存储方案。对于更复杂的应用场景还可以使用 <a href=\"https://github.com/typicode/lowdb\" target=\"_blank\" rel=\"noopener\">lowdb</a>，<a href=\"https://github.com/louischatriot/nedb\" target=\"_blank\" rel=\"noopener\">nedb</a> ，<code>sqlite</code>等。</p>\n<p>最初我使用的是 <code>electron-store</code>, 并且一直有一个执念是对磁盘的读写只能在 main 进程进行，renderer 进程只负责渲染界面。所以在最初设计的是在 renderer 进程渲染数据或者更新数据的时候都需要通过 IPC 到 main 进程来完成最终的磁盘读写。除去读写正常的情况，还要考虑读写磁盘的异常，这样导致数据流异常的绕。而且还需要自己维护 ID 的生成。借鉴了 Desktop 的代码后，重构了数据持久化部分，也采用了 <a href=\"https://github.com/dfahlander/Dexie.js\" target=\"_blank\" rel=\"noopener\">Dexie</a>，它是对浏览器标准数据库 indexedDB 的一个封装。从它的 Readme 可以看到它主要解决了indexedDB 的三个问题：</p>\n<ol>\n<li>不明确的异常处理</li>\n<li>查询很烂</li>\n<li>代码复杂</li>\n</ol>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Dexie <span class=\"keyword\">from</span> <span class=\"string\">'dexie'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> IDatabaseProject &#123;</span><br><span class=\"line\">  id?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  filePath: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> ProjectsDatabase <span class=\"keyword\">extends</span> Dexie &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> projects: Dexie.Table&lt;IDatabaseProject, <span class=\"built_in\">number</span>&gt;;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(<span class=\"string\">'ProjectsDatabase'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.version(<span class=\"number\">1</span>).stores(&#123;</span><br><span class=\"line\">      projects: <span class=\"string\">'++id,&amp;name,&amp;filePath'</span>,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.projects = <span class=\"keyword\">this</span>.table(<span class=\"string\">'projects'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>继承 Dexie 来实现我们自己的数据库类，在构造函数中声明数据库的版本，表的 schema 等等。具体可以参考 <a href=\"https://dexie.org/docs/\" target=\"_blank\" rel=\"noopener\">Dexie 官方文档</a>。</p>\n<h3 id=\"2-简单数据持久化\"><a href=\"#2-简单数据持久化\" class=\"headerlink\" title=\"2. 简单数据持久化\"></a>2. 简单数据持久化</h3><p>一些 UI 状态的标志位存储（比如某个弹窗是否显示过），我们一般会把这种标志位存储到 <code>localStorage</code> 中。<br>在查看 Desktop 的源码过程中，发现他们对 <code>number</code>, <code>boolean</code> 类型的数据的 get, set 进行了简单的封装。使用起来非常方便，这里贴一下对于 <code>boolean</code> 型数据的处理。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getBoolean</span>(<span class=\"params\">key: <span class=\"built_in\">string</span></span>): <span class=\"title\">boolean</span> | <span class=\"title\">undefined</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getBoolean</span>(<span class=\"params\">key: <span class=\"built_in\">string</span>, defaultValue: <span class=\"built_in\">boolean</span></span>): <span class=\"title\">boolean</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\"><span class=\"title\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getBoolean</span>(<span class=\"params\"></span></span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\"><span class=\"function\"><span class=\"params\">  key: <span class=\"built_in\">string</span>,</span></span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\"><span class=\"function\"><span class=\"params\">  defaultValue?: <span class=\"built_in\">boolean</span></span></span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">boolean</span> | <span class=\"title\">undefined</span> </span>&#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\">  <span class=\"title\">const</span> <span class=\"title\">value</span> = <span class=\"title\">localStorage</span>.<span class=\"title\">getItem</span>(<span class=\"params\">key</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\">  <span class=\"title\">if</span> (<span class=\"params\">value === <span class=\"literal\">null</span></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">return</span> <span class=\"title\">defaultValue</span></span></span><br><span class=\"line\"><span class=\"function\">  &#125;</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"title\">if</span> (<span class=\"params\">value === '1' || value === '<span class=\"literal\">true</span>'</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (value === <span class=\"string\">'0'</span> || value === <span class=\"string\">'false'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> defaultValue</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setBoolean</span>(<span class=\"params\">key: <span class=\"built_in\">string</span>, value: <span class=\"built_in\">boolean</span></span>) </span>&#123;</span><br><span class=\"line\">  localStorage.setItem(key, value ? <span class=\"string\">'1'</span> : <span class=\"string\">'0'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/desktop/desktop/blob/development/app/src/lib/local-storage.ts\" target=\"_blank\" rel=\"noopener\">源码详见</a></p>\n<h2 id=\"五、功能实现\"><a href=\"#五、功能实现\" class=\"headerlink\" title=\"五、功能实现\"></a>五、功能实现</h2><h3 id=\"1-磁盘-编辑器版本实时同步\"><a href=\"#1-磁盘-编辑器版本实时同步\" class=\"headerlink\" title=\"1. 磁盘/编辑器版本实时同步\"></a>1. 磁盘/编辑器版本实时同步</h3><p>一般情况下，在编辑器中我们编辑的内容其实是编辑器读取磁盘文件到内存中的副本。所以说如果磁盘的文件发生了改动，比如 Git 切换分支造成文件变动，抑或是删除了磁盘文件，重命名等等都会造成内存版本和磁盘版本的不一致，即磁盘版本领先于内存版本，这个时候就可能产生冲突。解决这个问题很简单，可以使用 fs.watch/watchFile 监听当前编辑的文件，一旦发生变化，就重新读取磁盘版本，更新内存版本来实现同步。但是 fs.watch 这个 API 在工程上不是可以开箱即用的，有许多兼容问题和一些 bug。比如说</p>\n<p>Node.js fs.watch:</p>\n<ul>\n<li>Doesn’t report filenames on MacOS.</li>\n<li>Doesn’t report events at all when using editors like Sublime on MacOS.</li>\n<li>Often reports events twice.</li>\n<li>Emits most changes as rename.</li>\n<li>Does not provide an easy way to recursively watch file trees.</li>\n</ul>\n<p>Node.js fs.watchFile:</p>\n<ul>\n<li>Almost as bad at event handling.</li>\n<li>Also does not provide any recursive watching.</li>\n<li>Results in high CPU utilization.</li>\n</ul>\n<p>上面列举的点来自 <a href=\"https://github.com/paulmillr/chokidar\" target=\"_blank\" rel=\"noopener\">chokidar</a>，它是一个 Node 模块，提供了开箱可用的监听文件变化的能力。只需要监听 <code>add</code>, <code>unlink</code>, <code>change</code> 等事件读取最新版本的文本到编辑器就可以实现磁盘/编辑器版本的同步了。</p>\n<h3 id=\"2-Context-Menu\"><a href=\"#2-Context-Menu\" class=\"headerlink\" title=\"2. Context-Menu\"></a>2. Context-Menu</h3><p>Desktop 的 <code>contextmenu</code> (右键菜单)的实现基于原生 IPC 的，比较绕。</p>\n<p>首先我们需要知道的是 <code>Menu</code> 类是 <code>main process only</code> 的。</p>\n<p>在需要 <code>contextmenu</code> 的 <code>JSX.Element</code> 上绑定 <code>onContextMenu</code> 事件。构造对象数组 <code>Array&lt;MenuItem&gt;</code>, 并且为每个 MenuItem 对象绑定触发事件，再通过 IPC 将对象传递至 main 进程，值得一提的是这个时候将 MenuItem 数组赋值给了一个全局对象，暂存起来。在 main 进程构造出真正的 MenuItem 实例，绑定 MenuItem 的点击事件，触发 MenuItem 点击事件的时候记录 MenuItem 的 序列号 index，再将 index 通过 event.sender.send 将 index 传递到 renderer 进程。renderer 进程拿到 index 之后根据之前保存的全局对象取出单个 MenuItem， 执行绑定的事件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onContextMenu =&gt; showContextualMenu (暂存MenuItems，ipcRenderer.send) =&gt; icpMain =&gt; menu.popup() =&gt; MenuItem.onClick(index) =&gt; event.sernder.send(index) =&gt; MenuItem.action()</span><br></pre></td></tr></table></figure>\n<p>所以在我的应用中使用了 remote 对象屏蔽上述复杂的 IPC 通信。在 renderer 进程完成 Menu 的构造展示和事件的绑定触发。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; remote &#125; <span class=\"keyword\">from</span> <span class=\"string\">'electron'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; MenuItem, dialog, getCurrentWindow, Menu &#125; = remote;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> onContextMenu = <span class=\"function\">(<span class=\"params\">project: Project</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> menu = <span class=\"keyword\">new</span> Menu();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> menus = [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> MenuItem(&#123;</span><br><span class=\"line\">      label: <span class=\"string\">'在终端中打开'</span>,</span><br><span class=\"line\">      visible: __DARWIN__,</span><br><span class=\"line\">      click() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> accessor = <span class=\"keyword\">new</span> FileAccessor(project.filePath);</span><br><span class=\"line\">        accessor.openInTerminal();</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> MenuItem(&#123;</span><br><span class=\"line\">      label: <span class=\"string\">'在 vscode 中打开'</span>,</span><br><span class=\"line\">      click() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> accessor = <span class=\"keyword\">new</span> FileAccessor(project.filePath);</span><br><span class=\"line\">        accessor.openInVscode();</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ];</span><br><span class=\"line\"></span><br><span class=\"line\">  menus.forEach(menu.append);</span><br><span class=\"line\">  menu.popup(&#123; <span class=\"built_in\">window</span>: getCurrentWindow() &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"六、日志\"><a href=\"#六、日志\" class=\"headerlink\" title=\"六、日志\"></a>六、日志</h2><p>完善的日志不论是开发环境还是生产环境都是非常重要的，大致记录 UI 状态迁移背后的数据变动，流程的分支走向，能很好的辅助开发。</p>\n<p>参考 Desktop，他们的日志基于日志库：<a href=\"https://github.com/winstonjs/winston#readme\" target=\"_blank\" rel=\"noopener\">winston</a>。</p>\n<p>在 main 进程和 renderer 进程都提供了全局 log 对象，接口都是一致的。分别是 <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code>。在 renderer 进程，简单的封装了 <code>window.console</code> 对象上的 <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code> 方法，日志打印到浏览器控制台的时候也通过 IPC 传递到 main 进程，由 main 进程统一管理。 </p>\n<p>main 进程接收了来自 renderer 进程的日志信息和 main 进程自身的日志信息。设置了两个 <code>transports</code>。<code>winston.transports.Console</code> 和 <code>winston.transports.DailyRotateFile</code> 分别用于将日志信息打印在终端控制台和存储在磁盘文件。DailyRotateFile 以天为单位，设置了最多存储 14 天的上限。</p>\n<p>在 main 进程和 renderer 进程启动时分别引入日志安装模块。因为 log 方法都是暴露在全局，因此只需要在进程启动时引入一次即可。同时在 TS 环境中还需要添加 log 方法的类型声明。</p>\n<h2 id=\"七、打包，发布及更新\"><a href=\"#七、打包，发布及更新\" class=\"headerlink\" title=\"七、打包，发布及更新\"></a>七、打包，发布及更新</h2><p>开源世界已经有非常完善的打包和发布的工具 – <a href=\"https://www.electron.build\" target=\"_blank\" rel=\"noopener\">electron-builder</a>。它集多平台打包，签名，自动更新，发布到Github等平台等等功能于一身。</p>\n<p>鉴于这个工具只能在内网使用，不能发布到 Github 而且也没有没有苹果开发者工具无法进行签名，只能利用 <code>electron-builder</code> 在本机打包，发布的话只能使用手动打包上传了，用户也只能手动下载安装包覆盖安装，不能像 VSCODE 这样实现自动更新。</p>\n<p>既然不能自动更新，那么新版本下发后，如何通知到用户去下载新版本安装包更新呢？<br>从用户这一端来看，在应用每次启动的时候可以做一次请求，查询是否有版本更新，或者是在应用菜单栏提供入口，让用户手动触发更新查询。查询到服务端的最新版本后，使用 <a href=\"https://www.npmjs.com/package/semver\" target=\"_blank\" rel=\"noopener\">sermver</a> 比较本机版本是否低于服务器版本，如果是就下发通知给用户，提示用户去下载更新。</p>\n<p>在有限的条件下怎么实现这个功能呢？</p>\n<p>实现这个功能必需的三个元素：服务端标识着最新版本的可读文件；托管各个版本安装包的云空间；应用代码中的更新逻辑。</p>\n<p>服务端标识着最新版本的可读文件：每次打包时都会更新 <code>package.json</code>，所以我们直接把 <code>package.json</code> 上传到某个不带鉴权的 CDN 就可以，更新的时候就请求这个文件。</p>\n<p>托管各个版本安装包的云空间：这个可以使用云盘，云盘可以生成分享链接，把这个链接手动拷贝到 Gitlab 该版本的 tag 的 Notes 中。</p>\n<p>应用代码中的更新逻辑：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> got <span class=\"keyword\">from</span> <span class=\"string\">'got'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> semver <span class=\"keyword\">from</span> <span class=\"string\">'semver'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; app, remote, BrowserWindow &#125; <span class=\"keyword\">from</span> <span class=\"string\">'electron'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> realApp = app || remote.app;</span><br><span class=\"line\"><span class=\"keyword\">const</span> currentVersion = realApp.getVersion();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkForUpdates</span>(<span class=\"params\"><span class=\"built_in\">window</span>: BrowserWindow, silent: <span class=\"built_in\">boolean</span> = <span class=\"literal\">false</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> url = <span class=\"string\">`http://yourcdn/package.json?t=<span class=\"subst\">$&#123;Date.now()&#125;</span>`</span>;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> got(url);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> pkg = <span class=\"built_in\">JSON</span>.parse(response.body);</span><br><span class=\"line\">    log.debug(<span class=\"string\">'检查更新，云端版本：'</span>, pkg.version);</span><br><span class=\"line\">    log.debug(<span class=\"string\">'当前版本'</span>, currentVersion);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (semver.lt(currentVersion, pkg.version)) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">window</span>.webContents.send(<span class=\"string\">'update-available'</span>, pkg.version);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">window</span>.webContents.send(<span class=\"string\">'update-not-available'</span>, silent);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.webContents.send(<span class=\"string\">'update-error'</span>, silent);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分别在应用主进程启动、用户点击应用菜单<code>检查更新</code>时调用这个方法，从而通知 UI 进程下发通知。我们期望应用主进程启动时的更新是在失败或者无更新时是静默的，不用打扰用户，所以在 IPC 管道可以提供一个 <code>silent</code> 参数。检测到更新后就可以通知用户，用户点击更新后就可以跳转到最新版本的 Gitlab tags ，引导用户下载最新版本进行手动安装。</p>\n<h2 id=\"八、其他\"><a href=\"#八、其他\" class=\"headerlink\" title=\"八、其他\"></a>八、其他</h2><h3 id=\"1-devtools\"><a href=\"#1-devtools\" class=\"headerlink\" title=\"1. devtools\"></a>1. devtools</h3><p>开发 Electron 应用中 renderer 端也是使用 Chrome devtools 来调试的。对于 React, Mobx 这类框的 devtools 扩展也可以通过 <code>electron-devtools-installer</code> 来安装。应用窗口创建之后调用<code>electron-devtools-installer</code> 进行 <code>mobx</code>、<code>react</code> 等扩展的安装。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; <span class=\"keyword\">default</span>: installExtension, MOBX_DEVTOOLS, REACT_DEVELOPER_TOOLS &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'electron-devtools-installer'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> extensions = [REACT_DEVELOPER_TOOLS, MOBX_DEVTOOLS];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> extension of extensions) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    installExtension(extension);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// log.error(e);</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-保持窗口大小\"><a href=\"#2-保持窗口大小\" class=\"headerlink\" title=\"2. 保持窗口大小\"></a>2. 保持窗口大小</h2><p>对于桌面应用，一个常见的需求就是关闭后重新打开，需要恢复到上次打开时的窗口大小，位置。实现这个比较简单，监听窗口的 resize 事件，把窗口信息记录到当前用户的应用数据文件夹, 即 <code>app.getPath(appData)</code>。下次启动应用创建窗口时读取这个文件设置窗口信息即可。开源社区已经有对这个功能封装好的库：<a href=\"https://github.com/mawie81/electron-window-state#readme\" target=\"_blank\" rel=\"noopener\">electron-window-state</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> windowStateKeeper = <span class=\"built_in\">require</span>(<span class=\"string\">'electron-window-state'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> win;</span><br><span class=\"line\"></span><br><span class=\"line\">app.on(<span class=\"string\">'ready'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> mainWindowState = windowStateKeeper(&#123;</span><br><span class=\"line\">    defaultWidth: <span class=\"number\">1000</span>,</span><br><span class=\"line\">    defaultHeight: <span class=\"number\">800</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  win = <span class=\"keyword\">new</span> BrowserWindow(&#123;</span><br><span class=\"line\">    <span class=\"string\">'x'</span>: mainWindowState.x,</span><br><span class=\"line\">    <span class=\"string\">'y'</span>: mainWindowState.y,</span><br><span class=\"line\">    <span class=\"string\">'width'</span>: mainWindowState.width,</span><br><span class=\"line\">    <span class=\"string\">'height'</span>: mainWindowState.height</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  mainWindowState.manage(win);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>只需要提供缺省窗口大小，剩余的事情 <code>electron-window-state</code> 都帮我们搞定了。</p>\n"},{"title":"what-learned-from-kickstarter","date":"2019-11-20T07:14:34.000Z","_content":"\n## 更强大的枚举\n\n- 计算属性\n\n## 函数重载\n\n\n## MVVM better for testing\n\n\n## failable\n很多情况下返回的都是 Optional,(json decode, URL 构造，字典取值) 需要 unwrap Optional, 保证了代码的健壮，不会轻易 crash\n\n## lazy initializer\n可以使用 lazy 标识类属性，这个属性只有在被使用的时候才会被初始化。\n\n## guard\nif 的反操作。代码更利于阅读\n\n## 多参数名\n给函数内部，外部定义不同的函数参数名\n\n## MVVM\n\nmodel view viewmodel\n\nview -> bingding -> viewmodel\n\nreactiveswift\n\nsingal\nsingalproducer\n\npipe\n\nstartsWithValue\n\nui/network => singalproducer => startsWithValue\n\nhot stream   positive => singal\ncold stream  passive, only you ask for it  => singalproducer","source":"_drafts/what-learned-from-kickstarter.md","raw":"---\ntitle: what-learned-from-kickstarter\ndate: 2019-11-20 15:14:34\ntags:\n---\n\n## 更强大的枚举\n\n- 计算属性\n\n## 函数重载\n\n\n## MVVM better for testing\n\n\n## failable\n很多情况下返回的都是 Optional,(json decode, URL 构造，字典取值) 需要 unwrap Optional, 保证了代码的健壮，不会轻易 crash\n\n## lazy initializer\n可以使用 lazy 标识类属性，这个属性只有在被使用的时候才会被初始化。\n\n## guard\nif 的反操作。代码更利于阅读\n\n## 多参数名\n给函数内部，外部定义不同的函数参数名\n\n## MVVM\n\nmodel view viewmodel\n\nview -> bingding -> viewmodel\n\nreactiveswift\n\nsingal\nsingalproducer\n\npipe\n\nstartsWithValue\n\nui/network => singalproducer => startsWithValue\n\nhot stream   positive => singal\ncold stream  passive, only you ask for it  => singalproducer","slug":"what-learned-from-kickstarter","published":0,"updated":"2020-07-31T08:49:39.350Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhpu92xm000hak87cs1w5hpz","content":"<h2 id=\"更强大的枚举\"><a href=\"#更强大的枚举\" class=\"headerlink\" title=\"更强大的枚举\"></a>更强大的枚举</h2><ul>\n<li>计算属性</li>\n</ul>\n<h2 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h2><h2 id=\"MVVM-better-for-testing\"><a href=\"#MVVM-better-for-testing\" class=\"headerlink\" title=\"MVVM better for testing\"></a>MVVM better for testing</h2><h2 id=\"failable\"><a href=\"#failable\" class=\"headerlink\" title=\"failable\"></a>failable</h2><p>很多情况下返回的都是 Optional,(json decode, URL 构造，字典取值) 需要 unwrap Optional, 保证了代码的健壮，不会轻易 crash</p>\n<h2 id=\"lazy-initializer\"><a href=\"#lazy-initializer\" class=\"headerlink\" title=\"lazy initializer\"></a>lazy initializer</h2><p>可以使用 lazy 标识类属性，这个属性只有在被使用的时候才会被初始化。</p>\n<h2 id=\"guard\"><a href=\"#guard\" class=\"headerlink\" title=\"guard\"></a>guard</h2><p>if 的反操作。代码更利于阅读</p>\n<h2 id=\"多参数名\"><a href=\"#多参数名\" class=\"headerlink\" title=\"多参数名\"></a>多参数名</h2><p>给函数内部，外部定义不同的函数参数名</p>\n<h2 id=\"MVVM\"><a href=\"#MVVM\" class=\"headerlink\" title=\"MVVM\"></a>MVVM</h2><p>model view viewmodel</p>\n<p>view -> bingding -> viewmodel</p>\n<p>reactiveswift</p>\n<p>singal<br>singalproducer</p>\n<p>pipe</p>\n<p>startsWithValue</p>\n<p>ui/network => singalproducer => startsWithValue</p>\n<p>hot stream   positive => singal<br>cold stream  passive, only you ask for it  => singalproducer</p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"更强大的枚举\"><a href=\"#更强大的枚举\" class=\"headerlink\" title=\"更强大的枚举\"></a>更强大的枚举</h2><ul>\n<li>计算属性</li>\n</ul>\n<h2 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h2><h2 id=\"MVVM-better-for-testing\"><a href=\"#MVVM-better-for-testing\" class=\"headerlink\" title=\"MVVM better for testing\"></a>MVVM better for testing</h2><h2 id=\"failable\"><a href=\"#failable\" class=\"headerlink\" title=\"failable\"></a>failable</h2><p>很多情况下返回的都是 Optional,(json decode, URL 构造，字典取值) 需要 unwrap Optional, 保证了代码的健壮，不会轻易 crash</p>\n<h2 id=\"lazy-initializer\"><a href=\"#lazy-initializer\" class=\"headerlink\" title=\"lazy initializer\"></a>lazy initializer</h2><p>可以使用 lazy 标识类属性，这个属性只有在被使用的时候才会被初始化。</p>\n<h2 id=\"guard\"><a href=\"#guard\" class=\"headerlink\" title=\"guard\"></a>guard</h2><p>if 的反操作。代码更利于阅读</p>\n<h2 id=\"多参数名\"><a href=\"#多参数名\" class=\"headerlink\" title=\"多参数名\"></a>多参数名</h2><p>给函数内部，外部定义不同的函数参数名</p>\n<h2 id=\"MVVM\"><a href=\"#MVVM\" class=\"headerlink\" title=\"MVVM\"></a>MVVM</h2><p>model view viewmodel</p>\n<p>view -&gt; bingding -&gt; viewmodel</p>\n<p>reactiveswift</p>\n<p>singal<br>singalproducer</p>\n<p>pipe</p>\n<p>startsWithValue</p>\n<p>ui/network =&gt; singalproducer =&gt; startsWithValue</p>\n<p>hot stream   positive =&gt; singal<br>cold stream  passive, only you ask for it  =&gt; singalproducer</p>\n"},{"title":"webpack-dev-server 运行原理","date":"2020-09-18T09:17:03.000Z","_content":"\n\n\n现代 web 开发者们对于 webpack 想必已经很熟悉了。webpack-dev-server 几乎也是标配。但是 webpack-dev-server 背后的运行原理是怎样的呢？想了解 how 我们先看看 what。webpack 将我们的项目源代码进行编译打包成可分发上线的静态资源，在开发阶段我们想要预览页面效果的话就需要启动一个服务器伺服 webpack 编译出来的静态资源。webpack-dev-server 就是用来伺服这些静态资源，除此之外，它还默认提供了liveReload的功能，就是在一次 webpack 编译完成后浏览器端就能自动刷新页面读取最新的编译后资源。为了提升开发体验，它还提供了 hot 选项开启 hotReload，相对于 liveReload, hotReload 不刷新整个页面，只更新被更改过的模块。\n\n![alt](/images/flow.jpg)\n\n上图是我对 webpack-dev-server 的一个简单的整理。具体的实现原理是怎样的我们接着往下看。\n\n## 版本\n\n本文基于以下版本进行分析\n\n- [webpack-dev-server@3.11.0](https://github.com/webpack/webpack-dev-server/tree/v3.11.0)\n- [webpack@4.44.1](https://github.com/webpack/webpack/tree/v4.44.1)\n\n## 入口\n\n如果作为命令行启动，`webpack-dev-server/bin/webpack-dev-server.js` 就是整个命令行的入口。贴出来的代码进行了一些精简，忽略了一些非核心的分支处理，只关心webpack-dev-server的是核心逻辑。\n\n\n```js\n// webpack-dev-server/bin/webpack-dev-server.js\n\nfunction startDevServer(config, options) {\n\n  let compiler;\n\n  try {\n    // 2. 调用webpack函数返回的是 webpack compiler 实例\n    compiler = webpack(config);\n  } catch (err) {\n  }\n\n  try {\n    // 3. 实例化 webpack-dev-server\n    server = new Server(compiler, options, log);\n  } catch (err) {\n  }\n\n  if (options.socket) {\n  } else {\n    // 4. 调用 server 实例的 listen 方法\n    server.listen(options.port, options.host, (err) => {\n      if (err) {\n        throw err;\n      }\n    });\n  }\n}\n\n// 1. 对参数进行处理后启动\nprocessOptions(config, argv, (config, options) => {\n  startDevServer(config, options);\n});\n```\n\nwebpack-dev-server 作为命令行启动，首先是调用了 webpack-cli 模块下的两个文件，分别配置了命令行提示选项、和从命令行和配置文件收集了 webpack 的 config，这样保持和 webpack-cli 的行为一致，上面贴出来的代码省略了这些代码，有兴趣的可以自己翻阅源码。之后调用processOptions 对收集的参数进行一些默认处理后得到传给 webpack 的 config 和传给 wepack-dev-server 的options。然后传入这两个配置参数调用 startDevServer，startDevServer 这个函数主要是先调用 webpack 函数实例化了 compiler, 注意这里没有给 webpack 函数传入回调函数，根据 webpack 源码，不传入回调函数就不会直接运行 webpack 而是返回 webpack compiler 的实例，供调用方自行调用。拿到 webpack compiler 实例和先前的 webapck-dev-server 的 options 就去实例化 Server，这个 Server 类就是实现 webpack-dev-server 的核心逻辑。最后调用 Server 类的 listen 方法，就正式开启监听请求，listen 方法后面会再解析具体逻辑。这就是 webapck-dev-server 大致的启动过程，后面来看下 Server 类具体做了什么。\n\n\n\n## 核心框架\n\n```js\n// webpack-dev-server/lib/Server.js\n\nclass Server {\n  constructor(compiler, options = {}, _log) {\n    // 0. 校验参数是否符合 schema, 不符合会抛出错误\n    validateOptions(schema, options, 'webpack Dev Server');\n    this.compiler = compiler;\n    this.options = options;\n    // 1. 为一些选项提供默认参数\n    normalizeOptions(this.compiler, this.options);\n    // 2. 对 webpack compiler 进行一些修改  webpack-dev-server/lib/utils/updateCompiler.js\n    //    - 如果设置了 hot 选项，自动给 webpack 配置 HotModuleReplacementPlugin\n    //    - 注入一些客户端代码：webpack 的 websocket 客户端依赖 sockJS/websocket + websocket 客户端业务代码 + hot 模式下的 webpack/hot/dev-server\n    updateCompiler(this.compiler, this.options);\n    // 3. 添加一些 hooks 插件，这里主要关注 webpack compiler 的 done 钩子，即每次编译完成后的钩子 (编译完成触发 _sendStats 方法给客户端广播消息 )\n    this.setupHooks();\n    // 4. 实例化 express 服务器\n    this.setupApp();\n    // 5. 设置 webpack-dev-middleware，用于处理对静态资源的处理，后面解析\n    this.setupDevMiddleware();\n    // 6. 创建 HTTP 服务器\n    this.createServer();\n  }\n\n\n  setupApp() {\n    // Init express server\n    // eslint-disable-next-line new-cap\n    this.app = new express();\n  }\n\n  setupHooks() {\n    const addHooks = (compiler) => {\n      const { compile  } = compiler.hooks;\n      done.tap('webpack-dev-server', (stats) => {\n        this._sendStats(this.sockets, this.getStats(stats));\n        this._stats = stats;\n      });\n    };\n    addHooks(this.compiler);\n  }\n\n  setupDevMiddleware() {\n    // middleware for serving webpack bundle\n    this.middleware = webpackDevMiddleware(\n      this.compiler,\n      Object.assign({}, this.options, { logLevel: this.log.options.level })\n    );\n    this.app.use(this.middleware);\n  }\n\n\n  createServer() {\n    this.listeningApp = http.createServer(this.app);\n\n    this.listeningApp.on('error', (err) => {\n      this.log.error(err);\n    });\n  }\n\n\n  listen(port, hostname, fn) {\n    this.hostname = hostname;\n\n    return this.listeningApp.listen(port, hostname, (err) => {\n      this.createSocketServer();\n    });\n  }\n\n  createSocketServer() {\n    const SocketServerImplementation = this.socketServerImplementation;\n    this.socketServer = new SocketServerImplementation(this);\n\n    this.socketServer.onConnection((connection, headers) => {\n      // 连接后保存客户端连接\n      this.sockets.push(connection);\n\n      if (this.hot) {\n        // hot 选项先广播一个 hot 类型的消息\n        this.sockWrite([connection], 'hot');\n      }\n\n      this._sendStats([connection], this.getStats(this._stats), true);\n    });\n  }\n\n\n  // eslint-disable-next-line\n  sockWrite(sockets, type, data) {\n    sockets.forEach((socket) => {\n      this.socketServer.send(socket, JSON.stringify({ type, data }));\n    });\n  }\n\n\n  // send stats to a socket or multiple sockets\n  _sendStats(sockets, stats, force) {\n    this.sockWrite(sockets, 'hash', stats.hash);\n\n    if (stats.errors.length > 0) {\n      this.sockWrite(sockets, 'errors', stats.errors);\n    } else if (stats.warnings.length > 0) {\n      this.sockWrite(sockets, 'warnings', stats.warnings);\n    } else {\n      this.sockWrite(sockets, 'ok');\n    }\n  }\n}\n```\n\n这部分代码稍长，主逻辑都在构造函数里。在构造函数中进行参数校验，参数缺省值处理，注入客户端代码，绑定 webpack compiler 钩子，这里主要关注是 done 钩子，(在 webpack compiler 实例每次触发编译完成后就会进行 webscoket 广播 webpack 的编译信息)。实例化 express 服务器，添加 webpack-dev-middleware 中间件用于处理静态资源的请求，然后初始化 HTTP 服务器。我们在上面的 webpack-dev-server.js 中调用的 listen 方法就是开始监听配置的端口，监听回调里再初始化 websocket 的服务端。\n代码执行到这已经完成了服务器端所有的逻辑，但是 webpack 还没有启动编译，用户打开浏览器后请求设置的IP和端口又是怎么处理的呢。那这个部分暂时被我们略过了，这部分就是 webpack-dev-middleware 处理的内容了。\n\n\n## webapck-dev-middleware 初始化\n\nwebapck-dev-middleware 作为一个独立的模块，以下是它的目录结构\n\n```\n.\n├── README.md\n├── index.js\n├── lib\n│   ├── DevMiddlewareError.js\n│   ├── context.js\n│   ├── fs.js\n│   ├── middleware.js\n│   ├── reporter.js\n│   └── util.js\n└── package.json\n```\n\nwebapck-dev-middleware 初始化执行\n\n```js\n// webpack-dev-middleware/index.js\nmodule.exports = function wdm(compiler, opts) {\n  const options = Object.assign({}, defaults, opts);\n  // 1. 初始化 context\n  const context = createContext(compiler, options);\n\n  // start watching\n  if (!options.lazy) {\n    // 2. 启动 webpack 编译\n    context.watching = compiler.watch(options.watchOptions, (err) => {\n      if (err) {\n        context.log.error(err.stack || err);\n        if (err.details) {\n          context.log.error(err.details);\n        }\n      }\n    });\n  } else {\n    // lazy 模式是请求过来一次才webpack编译一次, 这里不关注\n  }\n  \n  // 3. 替换 webpack 默认的 outputFileSystem 为 memory-fs, 存取都在内存上操作\n  // fileSystem = new MemoryFileSystem();\n  // compiler.outputFileSystem = fileSystem;\n  setFs(context, compiler);\n\n  // 3. 执行 middleware 函数返回真正的 middleware\n  return middleware(context);\n};\n```\n\nwdm 函数返回结果是 express 标准的 middleware 用于处理浏览器静态资源的请求。执行过程中显示初始化了一个 context 对象，默认不是 lazy 模式的情况下，开启了 webpack 的 watch 模式开始启动编译。 然后将 compiler 的原来基于 fs 模块的 outputFileSystem 替换成 [memory-fs](https://www.npmjs.com/package/memory-fs)模块的实例。memory-fs 是实现了 node fs api 的基于内存的 fileSystem，这意味着 webpack 编译后的资源不会被输出到硬盘而是内存。最后将真正处理请求的 middleware 返回装载在 express 上。\n\n\n## webapck-dev-middleware 处理请求\n\n当用户在浏览器打开配置的IP和端口，如 https://localhost:8080，请求就会被 middleware 处理。middleware 从内存中读到请求的资源就返回给客户端。\n\n```js\n// webpack-dev-middleware/lib/middleware.js\nmodule.exports = function wrapper(context) {\n  return function middleware(req, res, next) {\n    // 1. 根据请求的 URL 地址，得到绝对路径的 webpack 输出的资源路径地址\n    let filename = getFilenameFromUrl(\n      context.options.publicPath,\n      context.compiler,\n      req.url\n    );\n\n    return new Promise((resolve) => {\n      handleRequest(context, filename, processRequest, req);\n      // eslint-disable-next-line consistent-return\n      function processRequest() {\n\n        // 2.从内存读取到资源内容\n        let content = context.fs.readFileSync(filename);\n\n        // 3. 返回给客户端\n        if (res.send) {\n          res.send(content);\n        } else {\n          res.end(content);\n        }\n        resolve();\n      }\n    });\n  };\n};\n```\n\n## webscoket 通信\n\n当我们编辑了源代码，触发 webpack 重新编译，编译完成后执行 done 钩子上的回调。具体可参考上面 Server.js 中 setupHooks 方法。_sendStats 方法会先广播一个类型为 hash 的消息，然后再根据编译信息广播 warnings/errors/ok 消息。这里我们只关注正常流程 ok 消息。\n\n\n我们已经很熟悉客户端接收到更新后都会对应用进行 Reload 来获取更好的开发体验。具体是 liveReload（刷新整个页面）还是 hotReload（更新改动过的模块）就取决于我们的 hot 选项。\n\n\n这些代码我们在上面就讲到过是在 webpack 编译的时候注入到 bundle.js 进去的。当用户打开页面预览时，这些代码就会自动执行。\n\n\n```js\n// webpack-dev-server/client/index.js\nvar onSocketMessage = {\n  hot: function hot() {\n    options.hot = true;\n    log.info('[WDS] Hot Module Replacement enabled.');\n  },\n  liveReload: function liveReload() {\n    options.liveReload = true;\n    log.info('[WDS] Live Reloading enabled.');\n  },\n  hash: function hash(_hash) {\n    status.currentHash = _hash;\n  },\n  ok: function ok() {\n    if (options.initial) {\n      return options.initial = false;\n    } // eslint-disable-line no-return-assign\n\n\n    reloadApp(options, status);\n  }\n};\nsocket(socketUrl, onSocketMessage);\n```\n\n\nclient/index.js 主要就是初始化了 webscoket 客户端，然后为不同的消息类型设置了相应的回调函数。\n\n在前面 Server.js 中我们看到如果 hot 选项为 true 时，当 websocket 客户端连接到服务端，服务端会先广播一个 hot 类型的消息，客户端接收到后会把 options 对象的 hot 设置为 true。\n服务端在每次编译后都会广播 hash 消息，客户端接收到后就会将这个webpack 编译产生的 hash 值暂存起来。编译成功如果没有 warning 也没有 error 就会广播 ok 消息，客户端接收到 ok 消息就会执行 ok 回调函数中的 reloadApp 刷新应用。\n\n\n## webscoket 消息处理\n\n```js\n// webpack-dev-server/client/utils/reloadApp.js\n\nfunction reloadApp(_ref, _ref2) {\n  var hotReload = _ref.hotReload,\n      hot = _ref.hot,\n      liveReload = _ref.liveReload,\n      currentHash = _ref2.currentHash;\n\n  if (hot) {\n    log.info('[WDS] App hot update...');\n\n    var hotEmitter = require('webpack/hot/emitter');\n\n    hotEmitter.emit('webpackHotUpdate', currentHash);\n  } \n  else if (liveReload) {\n      var rootWindow = self; // use parent window for reload (in case we're in an iframe with no valid src)\n\n      var intervalId = self.setInterval(function () {\n        if (rootWindow.location.protocol !== 'about:') {\n          // reload immediately if protocol is valid\n          applyReload(rootWindow, intervalId);\n        } else {\n          rootWindow = rootWindow.parent;\n\n          if (rootWindow.parent === rootWindow) {\n            // if parent equals current window we've reached the root which would continue forever, so trigger a reload anyways\n            applyReload(rootWindow, intervalId);\n          }\n        }\n      });\n    }\n\n  function applyReload(rootWindow, intervalId) {\n    clearInterval(intervalId);\n    log.info('[WDS] App updated. Reloading...');\n    rootWindow.location.reload();\n  }\n}\n\n```\n\n\n## Hot Module Replacement\n\n\n### 触发 hot check\n\n如果设置了 hot: true 客户端就会引入 webpack/hot/emitter，触发一个 webpackHotUpdate 事件，将 hash 值传递过去。这个 ` webpack/hot/emitter` 我们查阅 webpack 源码看到其实就是 node 的 events 模块。我们暂时不关注这个事件会触发什么回调后面再具体再看。如果没有设置 hot: true。那么就是使用 liveReload 模式，liveReload 就比较无脑，直接刷新整个页面。\n\n\n再回到上一个问题，到底是在哪里接收 webpackHotUpdate 事件并处理的呢？就是 webpack/hot/dev-server.js 中处理的。在这里会去检查是否可以更新，如果更新失败就会刷新整个页面来降级实现代码更新的功能。其实我们回过头来看看这样降级也是必须的，如果更新失败，源码更新了，而客户端的代码却没更新，这样显示是不合理的。\n\n\n```js\n\n\tvar lastHash;\n\tvar upToDate = function upToDate() {\n\t\treturn lastHash.indexOf(__webpack_hash__) >= 0;\n\t};\n\tvar log = require(\"./log\");\n    // 2. 检查更新\n\tvar check = function check() {\n    // 3. 具体的检查逻辑\n\t\tmodule.hot\n\t\t\t.check(true)\n\t\t\t.then(function(updatedModules) {\n        // 3.1 更新成功\n\t\t\t})\n\t\t\t.catch(function(err) {\n\t\t\t\tvar status = module.hot.status();\n        // 3.2 更新失败，降级为重新刷新整个应用\n\t\t\t\tif ([\"abort\", \"fail\"].indexOf(status) >= 0) {\n\t\t\t\t\tlog(\n\t\t\t\t\t\t\"warning\",\n\t\t\t\t\t\t\"[HMR] Cannot apply update. Need to do a full reload!\"\n\t\t\t\t\t);\n\t\t\t\t\twindow.location.reload();\n\t\t\t\t} else {\n\t\t\t\t\tlog(\"warning\", \"[HMR] Update failed: \" + log.formatError(err));\n\t\t\t\t}\n\t\t\t});\n\t};\n\tvar hotEmitter = require(\"./emitter\");\n  // 1. 注册事件回调\n\thotEmitter.on(\"webpackHotUpdate\", function(currentHash) {\n\t\tlastHash = currentHash;\n\t\tif (!upToDate() && module.hot.status() === \"idle\") {\n\t\t\tlog(\"info\", \"[HMR] Checking for updates on the server...\");\n\t\t\tcheck();\n\t\t}\n\t});\n\n```\n\n### 模块更新依赖判断 \n\nmodule.hot.check 方法位于 webpack/lib/HotModuleReplacement.runtime.js 中，是 webpack 内置的 HotModuleReplacementPlugin 注入在 webpack bootstrap runtime 中的。\n\n所以 check 方法主要做了什么呢，这里提前总结一下。在 webpack 使用了 HotModuleReplacementPlugin 编译时，每次增量编译就会多产出两个文件，形如`c390bbe0037a0dd079a6.hot-update.json`，`main.c390bbe0037a0dd079a6.hot-update.js`，分别是描述 chunk 更新的 manifest文件和更新过后的 chunk 文件。那么浏览器端调用 hotDownloadManifest 去下载模块更新的 manifest.json 文件，然后使用 hotDownloadUpdateChunk 使用 jsonp 的方式下载需要更新的 chunk。hotDownloadUpdateChunk 下载完成后调用 webpackHotUpdate 回调。回调内拿到更新的模块，然后从模块自身开始进行冒泡，如果发现**只要有一条**祖先路径没有 accept 这次改动就直接刷新页面实行降级强制更新, 如果有被 accept, 就会替换掉原来 webpack runtime 里 module 里旧的模块，然后再执行 accept 的 callback 进行更新。为什么要执行这样的判断呢？\n\n假设给定这样的依赖路径\n\n```\ncomponentA.js -> componentB.js -> app.js -> index.js\ncomponentA.js -> componentC.js -> app.js -> index.js\n```\n\naccept 指该 module 的祖先模块调用了 module.hot.accept 处理了该 module 更新过后的业务逻辑，一般都是 rerender。\n\n```js\n// index.js\nif(module.hot) {\n    module.hot.accept('./app', function() {\n        rerender()\n    })\n}\n```\n\n\n如果我们对 componentA.js 进行了更改，但是如果仅仅 componentB accept 了更改，componentC 却没 accept，那么这样是没有到达更新的目的的。所以在祖先路径回溯的时候，要保证每一条路径都被 accept。\n\n\n\n```js\nfunction hotCheck(apply) {\n  // 1. 拿这次编译后的 hash 请求服务器，拿到结构为 {c: {main: true} h: \"ac69ee760bb48d5db5f5\"} 的数据\n  return hotDownloadManifest(hotRequestTimeout).then(function(update) {\n    hotAvailableFilesMap = update.c;\n    hotUpdateNewHash = update.h;\n\n    // 2. 生成一个 defered promise，供上面提到的 promise 链消费\n    var promise = new Promise(function(resolve, reject) {\n      hotDeferred = {\n        resolve: resolve,\n        reject: reject\n      };\n    });\n\n    hotUpdate = {};\n    // 3. 这个方法里面调用的就是 hotDownloadUpdateChunk，就是发起一个 jsonp 请求更新过后的 chunk，jsonp的回调是 HMR runtime 里的 webpackHotUpdate\n    {\n      hotEnsureUpdateChunk(chunkId);\n    }\n\n    return promise;\n  });\n}\n```\n\nhotCheck 方法就是和服务器进行通信拿到更新过后的 chunk，下载好 chunk 后就开始执行 HMR runtime 里的 webpackHotUpdate 回调。\n\n```js\nwindow[\"webpackHotUpdate\"] = function webpackHotUpdateCallback(chunkId, moreModules) {\n\thotAddUpdateChunk(chunkId, moreModules);\n\tif (parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);\n} ;\n```\n\n\n经过一系列方法调用然后来到 hotApplyInternal 方法，这个方法把更新过后的模块 apply 到业务中，整个方法比较长，就不完整贴出来了。这里拿出核心的部分，\n\n```js\nfor (var id in hotUpdate) {\n    if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {\n        var result;\n        if (hotUpdate[id]) {\n            result = getAffectedStuff(moduleId);\n        } else {\n            result = {\n                type: \"disposed\",\n                moduleId: id\n            };\n        }\n        switch (result.type) {\n            case \"self-declined\":\n            case \"declined\":\n            case \"unaccepted\":\n                if (options.onUnaccepted) options.onUnaccepted(result);\n                if (!options.ignoreUnaccepted)\n                    abortError = new Error(\n                        \"Aborted because \" + moduleId + \" is not accepted\" + chainInfo\n                    );\n                break;\n            case \"accepted\":\n                if (options.onAccepted) options.onAccepted(result);\n                doApply = true;\n                break;\n            case \"disposed\":\n                break;\n            default:\n                throw new Error(\"Unexception type \" + result.type);\n        }\n    }\n}\n```\n\n把更新过的模块进行遍历，找到被该模块影响到的祖先模块，返回一个结果，如果结果标识为 unaccepted 就会被抛出错误，然后走到 webpack/hot/dev-server.js 里的 catch 进行页面级刷新。如果被 accept 的话就会执行后面的 apply 的逻辑。\n\n\n```js\nfunction getAffectedStuff(updateModuleId) {\n  var outdatedModules = [updateModuleId];\n  var outdatedDependencies = {};\n\n  var queue = outdatedModules.map(function(id) {\n    return {\n      chain: [id],\n      id: id\n    };\n  });\n  // 1. 遍历 queue\n  while (queue.length > 0) {\n    var queueItem = queue.pop();\n    var moduleId = queueItem.id;\n    var chain = queueItem.chain;\n    // 2. 找到改模块的旧版本\n    module = installedModules[moduleId];\n\n    // 3. 如果到根模块了，返回 unaccepted\n    if (module.hot._main) {\n      return {\n        type: \"unaccepted\",\n        chain: chain,\n        moduleId: moduleId\n      };\n    }\n    // 4. 遍历父模块\n    for (var i = 0; i < module.parents.length; i++) {\n      var parentId = module.parents[i];\n      var parent = installedModules[parentId];\n      \n      // 5. 如果父模块处理了模块变更的话就跳过，继续检查\n      if (parent.hot._acceptedDependencies[moduleId]) {\n        continue;\n      }\n      outdatedModules.push(parentId);\n      // 6. 没跳过的话推入队列，继续检查\n      queue.push({\n        chain: chain.concat([parentId]),\n        id: parentId\n      });\n    }\n  }\n\n  // 7.如果所有依赖路径都有被 accept 就返回 accepted\n  return {\n    type: \"accepted\",\n    moduleId: updateModuleId,\n    outdatedModules: outdatedModules,\n    outdatedDependencies: outdatedDependencies\n  };\n}\n```\n\n### module apply\n\n看过 webpack runtime 代码的应该知道 runtime 里声明了 installedModules 这个变量，里面缓存了所有被 __webpack_require__ 调用后加载过的模块，还有 modules 这个变量存储了所有模块，为了理解下面模块替换的部分可以先去看下 webpack runtime 代码的执行机制。如果模块有被 accept 的话，那么就会从 installedModules 里删掉旧的模块，把模块从父子依赖中删除，然后把 modules 里面的模块替换成新的模块。\n\n```js\n// remove module from cache\ndelete installedModules[moduleId];\n\n\n// insert new code\nfor (moduleId in appliedUpdate) {\n    if (Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {\n        modules[moduleId] = appliedUpdate[moduleId];\n    }\n}\n```\n\n这样仅仅完成了模块的替换，还没有执行过新模块代码，也就是没被 __webpack_require__ 调用过。新模块代码的执行是在 accept 函数的的 callback 里被 webpack 自动插入代码执行的。\n\n```js\nif(module.hot) {\n    module.hot.accept('./App', function() {\n        console.log('accepted')\n    })\n}\n```\n\n会被 webpack 改造为\n\n```js\nif(true) {\n    module.hot.accept(\"./src/App.js\", function(__WEBPACK_OUTDATED_DEPENDENCIES__) { \n      _App__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./src/App.js\");\n      (function() {\n        console.log('accepted')\n      })(__WEBPACK_OUTDATED_DEPENDENCIES__); \n    }.bind(this))\n}\n```\n\n所以新模块的代码是在 accept 方法回调执行之前被执行的。引入了新代码后就可以执行我们的业务代码，这些业务代码一般都和框架相关，框架去处理模块的热更新逻辑。比如 react-hot-loader, vue-loader 。\n\n## 总结\n\n最后总结一下，webpack-dev-server 可以作为命令行工具使用，核心模块依赖是 webpack 和 webpack-dev-middleware。webapck-dev-server 负责启动一个 express 服务器监听客户端请求；实例化 webpack compiler；启动负责推送 webpack 编译信息的 webscoket 服务器；负责向 bundle.js 注入和服务端通信用的 webscoket 客户端代码和处理逻辑。webapck-dev-middleware 把 webpack compiler 的 outputFileSystem 改为 in-memory fileSystem；启动 webpack watch 编译；处理浏览器发出的静态资源的请求，把 webpack 输出到内存的文件响应给浏览器。\n\n每次 webpack 编译完成后向客户端广播 ok 消息，客户端收到信息后根据是否开启 hot 模式使用 liveReload 页面级刷新模式或者 hotReload 模块热替换。hotReload 存在失败的情况，失败的情况下会降级使用页面级刷新。\n\n开启 hot 模式，即启用 HMR 插件。hot 模式会向服务器请求更新过后的模块，然后对模块的父模块进行回溯，对依赖路径进行判断，如果每条依赖路径都配置了模块更新后所需的业务处理回到函数则是 accepted 状态，否则就降级刷新页面。判断 accepted 状态后对旧的缓存模块和父子依赖模块进行替换和删除，然后执行 accept 方法的回调函数，执行新模块代码，引入新模块，执行业务处理代码。\n\n想要更加熟悉完整的运行流程还是需要自己打开浏览器，断点调试。","source":"_posts/how-wepback-dev-server-run.md","raw":"---\ntitle: webpack-dev-server 运行原理\ndate: 2020-09-18 17:17:03\ntags:\n---\n\n\n\n现代 web 开发者们对于 webpack 想必已经很熟悉了。webpack-dev-server 几乎也是标配。但是 webpack-dev-server 背后的运行原理是怎样的呢？想了解 how 我们先看看 what。webpack 将我们的项目源代码进行编译打包成可分发上线的静态资源，在开发阶段我们想要预览页面效果的话就需要启动一个服务器伺服 webpack 编译出来的静态资源。webpack-dev-server 就是用来伺服这些静态资源，除此之外，它还默认提供了liveReload的功能，就是在一次 webpack 编译完成后浏览器端就能自动刷新页面读取最新的编译后资源。为了提升开发体验，它还提供了 hot 选项开启 hotReload，相对于 liveReload, hotReload 不刷新整个页面，只更新被更改过的模块。\n\n![alt](/images/flow.jpg)\n\n上图是我对 webpack-dev-server 的一个简单的整理。具体的实现原理是怎样的我们接着往下看。\n\n## 版本\n\n本文基于以下版本进行分析\n\n- [webpack-dev-server@3.11.0](https://github.com/webpack/webpack-dev-server/tree/v3.11.0)\n- [webpack@4.44.1](https://github.com/webpack/webpack/tree/v4.44.1)\n\n## 入口\n\n如果作为命令行启动，`webpack-dev-server/bin/webpack-dev-server.js` 就是整个命令行的入口。贴出来的代码进行了一些精简，忽略了一些非核心的分支处理，只关心webpack-dev-server的是核心逻辑。\n\n\n```js\n// webpack-dev-server/bin/webpack-dev-server.js\n\nfunction startDevServer(config, options) {\n\n  let compiler;\n\n  try {\n    // 2. 调用webpack函数返回的是 webpack compiler 实例\n    compiler = webpack(config);\n  } catch (err) {\n  }\n\n  try {\n    // 3. 实例化 webpack-dev-server\n    server = new Server(compiler, options, log);\n  } catch (err) {\n  }\n\n  if (options.socket) {\n  } else {\n    // 4. 调用 server 实例的 listen 方法\n    server.listen(options.port, options.host, (err) => {\n      if (err) {\n        throw err;\n      }\n    });\n  }\n}\n\n// 1. 对参数进行处理后启动\nprocessOptions(config, argv, (config, options) => {\n  startDevServer(config, options);\n});\n```\n\nwebpack-dev-server 作为命令行启动，首先是调用了 webpack-cli 模块下的两个文件，分别配置了命令行提示选项、和从命令行和配置文件收集了 webpack 的 config，这样保持和 webpack-cli 的行为一致，上面贴出来的代码省略了这些代码，有兴趣的可以自己翻阅源码。之后调用processOptions 对收集的参数进行一些默认处理后得到传给 webpack 的 config 和传给 wepack-dev-server 的options。然后传入这两个配置参数调用 startDevServer，startDevServer 这个函数主要是先调用 webpack 函数实例化了 compiler, 注意这里没有给 webpack 函数传入回调函数，根据 webpack 源码，不传入回调函数就不会直接运行 webpack 而是返回 webpack compiler 的实例，供调用方自行调用。拿到 webpack compiler 实例和先前的 webapck-dev-server 的 options 就去实例化 Server，这个 Server 类就是实现 webpack-dev-server 的核心逻辑。最后调用 Server 类的 listen 方法，就正式开启监听请求，listen 方法后面会再解析具体逻辑。这就是 webapck-dev-server 大致的启动过程，后面来看下 Server 类具体做了什么。\n\n\n\n## 核心框架\n\n```js\n// webpack-dev-server/lib/Server.js\n\nclass Server {\n  constructor(compiler, options = {}, _log) {\n    // 0. 校验参数是否符合 schema, 不符合会抛出错误\n    validateOptions(schema, options, 'webpack Dev Server');\n    this.compiler = compiler;\n    this.options = options;\n    // 1. 为一些选项提供默认参数\n    normalizeOptions(this.compiler, this.options);\n    // 2. 对 webpack compiler 进行一些修改  webpack-dev-server/lib/utils/updateCompiler.js\n    //    - 如果设置了 hot 选项，自动给 webpack 配置 HotModuleReplacementPlugin\n    //    - 注入一些客户端代码：webpack 的 websocket 客户端依赖 sockJS/websocket + websocket 客户端业务代码 + hot 模式下的 webpack/hot/dev-server\n    updateCompiler(this.compiler, this.options);\n    // 3. 添加一些 hooks 插件，这里主要关注 webpack compiler 的 done 钩子，即每次编译完成后的钩子 (编译完成触发 _sendStats 方法给客户端广播消息 )\n    this.setupHooks();\n    // 4. 实例化 express 服务器\n    this.setupApp();\n    // 5. 设置 webpack-dev-middleware，用于处理对静态资源的处理，后面解析\n    this.setupDevMiddleware();\n    // 6. 创建 HTTP 服务器\n    this.createServer();\n  }\n\n\n  setupApp() {\n    // Init express server\n    // eslint-disable-next-line new-cap\n    this.app = new express();\n  }\n\n  setupHooks() {\n    const addHooks = (compiler) => {\n      const { compile  } = compiler.hooks;\n      done.tap('webpack-dev-server', (stats) => {\n        this._sendStats(this.sockets, this.getStats(stats));\n        this._stats = stats;\n      });\n    };\n    addHooks(this.compiler);\n  }\n\n  setupDevMiddleware() {\n    // middleware for serving webpack bundle\n    this.middleware = webpackDevMiddleware(\n      this.compiler,\n      Object.assign({}, this.options, { logLevel: this.log.options.level })\n    );\n    this.app.use(this.middleware);\n  }\n\n\n  createServer() {\n    this.listeningApp = http.createServer(this.app);\n\n    this.listeningApp.on('error', (err) => {\n      this.log.error(err);\n    });\n  }\n\n\n  listen(port, hostname, fn) {\n    this.hostname = hostname;\n\n    return this.listeningApp.listen(port, hostname, (err) => {\n      this.createSocketServer();\n    });\n  }\n\n  createSocketServer() {\n    const SocketServerImplementation = this.socketServerImplementation;\n    this.socketServer = new SocketServerImplementation(this);\n\n    this.socketServer.onConnection((connection, headers) => {\n      // 连接后保存客户端连接\n      this.sockets.push(connection);\n\n      if (this.hot) {\n        // hot 选项先广播一个 hot 类型的消息\n        this.sockWrite([connection], 'hot');\n      }\n\n      this._sendStats([connection], this.getStats(this._stats), true);\n    });\n  }\n\n\n  // eslint-disable-next-line\n  sockWrite(sockets, type, data) {\n    sockets.forEach((socket) => {\n      this.socketServer.send(socket, JSON.stringify({ type, data }));\n    });\n  }\n\n\n  // send stats to a socket or multiple sockets\n  _sendStats(sockets, stats, force) {\n    this.sockWrite(sockets, 'hash', stats.hash);\n\n    if (stats.errors.length > 0) {\n      this.sockWrite(sockets, 'errors', stats.errors);\n    } else if (stats.warnings.length > 0) {\n      this.sockWrite(sockets, 'warnings', stats.warnings);\n    } else {\n      this.sockWrite(sockets, 'ok');\n    }\n  }\n}\n```\n\n这部分代码稍长，主逻辑都在构造函数里。在构造函数中进行参数校验，参数缺省值处理，注入客户端代码，绑定 webpack compiler 钩子，这里主要关注是 done 钩子，(在 webpack compiler 实例每次触发编译完成后就会进行 webscoket 广播 webpack 的编译信息)。实例化 express 服务器，添加 webpack-dev-middleware 中间件用于处理静态资源的请求，然后初始化 HTTP 服务器。我们在上面的 webpack-dev-server.js 中调用的 listen 方法就是开始监听配置的端口，监听回调里再初始化 websocket 的服务端。\n代码执行到这已经完成了服务器端所有的逻辑，但是 webpack 还没有启动编译，用户打开浏览器后请求设置的IP和端口又是怎么处理的呢。那这个部分暂时被我们略过了，这部分就是 webpack-dev-middleware 处理的内容了。\n\n\n## webapck-dev-middleware 初始化\n\nwebapck-dev-middleware 作为一个独立的模块，以下是它的目录结构\n\n```\n.\n├── README.md\n├── index.js\n├── lib\n│   ├── DevMiddlewareError.js\n│   ├── context.js\n│   ├── fs.js\n│   ├── middleware.js\n│   ├── reporter.js\n│   └── util.js\n└── package.json\n```\n\nwebapck-dev-middleware 初始化执行\n\n```js\n// webpack-dev-middleware/index.js\nmodule.exports = function wdm(compiler, opts) {\n  const options = Object.assign({}, defaults, opts);\n  // 1. 初始化 context\n  const context = createContext(compiler, options);\n\n  // start watching\n  if (!options.lazy) {\n    // 2. 启动 webpack 编译\n    context.watching = compiler.watch(options.watchOptions, (err) => {\n      if (err) {\n        context.log.error(err.stack || err);\n        if (err.details) {\n          context.log.error(err.details);\n        }\n      }\n    });\n  } else {\n    // lazy 模式是请求过来一次才webpack编译一次, 这里不关注\n  }\n  \n  // 3. 替换 webpack 默认的 outputFileSystem 为 memory-fs, 存取都在内存上操作\n  // fileSystem = new MemoryFileSystem();\n  // compiler.outputFileSystem = fileSystem;\n  setFs(context, compiler);\n\n  // 3. 执行 middleware 函数返回真正的 middleware\n  return middleware(context);\n};\n```\n\nwdm 函数返回结果是 express 标准的 middleware 用于处理浏览器静态资源的请求。执行过程中显示初始化了一个 context 对象，默认不是 lazy 模式的情况下，开启了 webpack 的 watch 模式开始启动编译。 然后将 compiler 的原来基于 fs 模块的 outputFileSystem 替换成 [memory-fs](https://www.npmjs.com/package/memory-fs)模块的实例。memory-fs 是实现了 node fs api 的基于内存的 fileSystem，这意味着 webpack 编译后的资源不会被输出到硬盘而是内存。最后将真正处理请求的 middleware 返回装载在 express 上。\n\n\n## webapck-dev-middleware 处理请求\n\n当用户在浏览器打开配置的IP和端口，如 https://localhost:8080，请求就会被 middleware 处理。middleware 从内存中读到请求的资源就返回给客户端。\n\n```js\n// webpack-dev-middleware/lib/middleware.js\nmodule.exports = function wrapper(context) {\n  return function middleware(req, res, next) {\n    // 1. 根据请求的 URL 地址，得到绝对路径的 webpack 输出的资源路径地址\n    let filename = getFilenameFromUrl(\n      context.options.publicPath,\n      context.compiler,\n      req.url\n    );\n\n    return new Promise((resolve) => {\n      handleRequest(context, filename, processRequest, req);\n      // eslint-disable-next-line consistent-return\n      function processRequest() {\n\n        // 2.从内存读取到资源内容\n        let content = context.fs.readFileSync(filename);\n\n        // 3. 返回给客户端\n        if (res.send) {\n          res.send(content);\n        } else {\n          res.end(content);\n        }\n        resolve();\n      }\n    });\n  };\n};\n```\n\n## webscoket 通信\n\n当我们编辑了源代码，触发 webpack 重新编译，编译完成后执行 done 钩子上的回调。具体可参考上面 Server.js 中 setupHooks 方法。_sendStats 方法会先广播一个类型为 hash 的消息，然后再根据编译信息广播 warnings/errors/ok 消息。这里我们只关注正常流程 ok 消息。\n\n\n我们已经很熟悉客户端接收到更新后都会对应用进行 Reload 来获取更好的开发体验。具体是 liveReload（刷新整个页面）还是 hotReload（更新改动过的模块）就取决于我们的 hot 选项。\n\n\n这些代码我们在上面就讲到过是在 webpack 编译的时候注入到 bundle.js 进去的。当用户打开页面预览时，这些代码就会自动执行。\n\n\n```js\n// webpack-dev-server/client/index.js\nvar onSocketMessage = {\n  hot: function hot() {\n    options.hot = true;\n    log.info('[WDS] Hot Module Replacement enabled.');\n  },\n  liveReload: function liveReload() {\n    options.liveReload = true;\n    log.info('[WDS] Live Reloading enabled.');\n  },\n  hash: function hash(_hash) {\n    status.currentHash = _hash;\n  },\n  ok: function ok() {\n    if (options.initial) {\n      return options.initial = false;\n    } // eslint-disable-line no-return-assign\n\n\n    reloadApp(options, status);\n  }\n};\nsocket(socketUrl, onSocketMessage);\n```\n\n\nclient/index.js 主要就是初始化了 webscoket 客户端，然后为不同的消息类型设置了相应的回调函数。\n\n在前面 Server.js 中我们看到如果 hot 选项为 true 时，当 websocket 客户端连接到服务端，服务端会先广播一个 hot 类型的消息，客户端接收到后会把 options 对象的 hot 设置为 true。\n服务端在每次编译后都会广播 hash 消息，客户端接收到后就会将这个webpack 编译产生的 hash 值暂存起来。编译成功如果没有 warning 也没有 error 就会广播 ok 消息，客户端接收到 ok 消息就会执行 ok 回调函数中的 reloadApp 刷新应用。\n\n\n## webscoket 消息处理\n\n```js\n// webpack-dev-server/client/utils/reloadApp.js\n\nfunction reloadApp(_ref, _ref2) {\n  var hotReload = _ref.hotReload,\n      hot = _ref.hot,\n      liveReload = _ref.liveReload,\n      currentHash = _ref2.currentHash;\n\n  if (hot) {\n    log.info('[WDS] App hot update...');\n\n    var hotEmitter = require('webpack/hot/emitter');\n\n    hotEmitter.emit('webpackHotUpdate', currentHash);\n  } \n  else if (liveReload) {\n      var rootWindow = self; // use parent window for reload (in case we're in an iframe with no valid src)\n\n      var intervalId = self.setInterval(function () {\n        if (rootWindow.location.protocol !== 'about:') {\n          // reload immediately if protocol is valid\n          applyReload(rootWindow, intervalId);\n        } else {\n          rootWindow = rootWindow.parent;\n\n          if (rootWindow.parent === rootWindow) {\n            // if parent equals current window we've reached the root which would continue forever, so trigger a reload anyways\n            applyReload(rootWindow, intervalId);\n          }\n        }\n      });\n    }\n\n  function applyReload(rootWindow, intervalId) {\n    clearInterval(intervalId);\n    log.info('[WDS] App updated. Reloading...');\n    rootWindow.location.reload();\n  }\n}\n\n```\n\n\n## Hot Module Replacement\n\n\n### 触发 hot check\n\n如果设置了 hot: true 客户端就会引入 webpack/hot/emitter，触发一个 webpackHotUpdate 事件，将 hash 值传递过去。这个 ` webpack/hot/emitter` 我们查阅 webpack 源码看到其实就是 node 的 events 模块。我们暂时不关注这个事件会触发什么回调后面再具体再看。如果没有设置 hot: true。那么就是使用 liveReload 模式，liveReload 就比较无脑，直接刷新整个页面。\n\n\n再回到上一个问题，到底是在哪里接收 webpackHotUpdate 事件并处理的呢？就是 webpack/hot/dev-server.js 中处理的。在这里会去检查是否可以更新，如果更新失败就会刷新整个页面来降级实现代码更新的功能。其实我们回过头来看看这样降级也是必须的，如果更新失败，源码更新了，而客户端的代码却没更新，这样显示是不合理的。\n\n\n```js\n\n\tvar lastHash;\n\tvar upToDate = function upToDate() {\n\t\treturn lastHash.indexOf(__webpack_hash__) >= 0;\n\t};\n\tvar log = require(\"./log\");\n    // 2. 检查更新\n\tvar check = function check() {\n    // 3. 具体的检查逻辑\n\t\tmodule.hot\n\t\t\t.check(true)\n\t\t\t.then(function(updatedModules) {\n        // 3.1 更新成功\n\t\t\t})\n\t\t\t.catch(function(err) {\n\t\t\t\tvar status = module.hot.status();\n        // 3.2 更新失败，降级为重新刷新整个应用\n\t\t\t\tif ([\"abort\", \"fail\"].indexOf(status) >= 0) {\n\t\t\t\t\tlog(\n\t\t\t\t\t\t\"warning\",\n\t\t\t\t\t\t\"[HMR] Cannot apply update. Need to do a full reload!\"\n\t\t\t\t\t);\n\t\t\t\t\twindow.location.reload();\n\t\t\t\t} else {\n\t\t\t\t\tlog(\"warning\", \"[HMR] Update failed: \" + log.formatError(err));\n\t\t\t\t}\n\t\t\t});\n\t};\n\tvar hotEmitter = require(\"./emitter\");\n  // 1. 注册事件回调\n\thotEmitter.on(\"webpackHotUpdate\", function(currentHash) {\n\t\tlastHash = currentHash;\n\t\tif (!upToDate() && module.hot.status() === \"idle\") {\n\t\t\tlog(\"info\", \"[HMR] Checking for updates on the server...\");\n\t\t\tcheck();\n\t\t}\n\t});\n\n```\n\n### 模块更新依赖判断 \n\nmodule.hot.check 方法位于 webpack/lib/HotModuleReplacement.runtime.js 中，是 webpack 内置的 HotModuleReplacementPlugin 注入在 webpack bootstrap runtime 中的。\n\n所以 check 方法主要做了什么呢，这里提前总结一下。在 webpack 使用了 HotModuleReplacementPlugin 编译时，每次增量编译就会多产出两个文件，形如`c390bbe0037a0dd079a6.hot-update.json`，`main.c390bbe0037a0dd079a6.hot-update.js`，分别是描述 chunk 更新的 manifest文件和更新过后的 chunk 文件。那么浏览器端调用 hotDownloadManifest 去下载模块更新的 manifest.json 文件，然后使用 hotDownloadUpdateChunk 使用 jsonp 的方式下载需要更新的 chunk。hotDownloadUpdateChunk 下载完成后调用 webpackHotUpdate 回调。回调内拿到更新的模块，然后从模块自身开始进行冒泡，如果发现**只要有一条**祖先路径没有 accept 这次改动就直接刷新页面实行降级强制更新, 如果有被 accept, 就会替换掉原来 webpack runtime 里 module 里旧的模块，然后再执行 accept 的 callback 进行更新。为什么要执行这样的判断呢？\n\n假设给定这样的依赖路径\n\n```\ncomponentA.js -> componentB.js -> app.js -> index.js\ncomponentA.js -> componentC.js -> app.js -> index.js\n```\n\naccept 指该 module 的祖先模块调用了 module.hot.accept 处理了该 module 更新过后的业务逻辑，一般都是 rerender。\n\n```js\n// index.js\nif(module.hot) {\n    module.hot.accept('./app', function() {\n        rerender()\n    })\n}\n```\n\n\n如果我们对 componentA.js 进行了更改，但是如果仅仅 componentB accept 了更改，componentC 却没 accept，那么这样是没有到达更新的目的的。所以在祖先路径回溯的时候，要保证每一条路径都被 accept。\n\n\n\n```js\nfunction hotCheck(apply) {\n  // 1. 拿这次编译后的 hash 请求服务器，拿到结构为 {c: {main: true} h: \"ac69ee760bb48d5db5f5\"} 的数据\n  return hotDownloadManifest(hotRequestTimeout).then(function(update) {\n    hotAvailableFilesMap = update.c;\n    hotUpdateNewHash = update.h;\n\n    // 2. 生成一个 defered promise，供上面提到的 promise 链消费\n    var promise = new Promise(function(resolve, reject) {\n      hotDeferred = {\n        resolve: resolve,\n        reject: reject\n      };\n    });\n\n    hotUpdate = {};\n    // 3. 这个方法里面调用的就是 hotDownloadUpdateChunk，就是发起一个 jsonp 请求更新过后的 chunk，jsonp的回调是 HMR runtime 里的 webpackHotUpdate\n    {\n      hotEnsureUpdateChunk(chunkId);\n    }\n\n    return promise;\n  });\n}\n```\n\nhotCheck 方法就是和服务器进行通信拿到更新过后的 chunk，下载好 chunk 后就开始执行 HMR runtime 里的 webpackHotUpdate 回调。\n\n```js\nwindow[\"webpackHotUpdate\"] = function webpackHotUpdateCallback(chunkId, moreModules) {\n\thotAddUpdateChunk(chunkId, moreModules);\n\tif (parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);\n} ;\n```\n\n\n经过一系列方法调用然后来到 hotApplyInternal 方法，这个方法把更新过后的模块 apply 到业务中，整个方法比较长，就不完整贴出来了。这里拿出核心的部分，\n\n```js\nfor (var id in hotUpdate) {\n    if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {\n        var result;\n        if (hotUpdate[id]) {\n            result = getAffectedStuff(moduleId);\n        } else {\n            result = {\n                type: \"disposed\",\n                moduleId: id\n            };\n        }\n        switch (result.type) {\n            case \"self-declined\":\n            case \"declined\":\n            case \"unaccepted\":\n                if (options.onUnaccepted) options.onUnaccepted(result);\n                if (!options.ignoreUnaccepted)\n                    abortError = new Error(\n                        \"Aborted because \" + moduleId + \" is not accepted\" + chainInfo\n                    );\n                break;\n            case \"accepted\":\n                if (options.onAccepted) options.onAccepted(result);\n                doApply = true;\n                break;\n            case \"disposed\":\n                break;\n            default:\n                throw new Error(\"Unexception type \" + result.type);\n        }\n    }\n}\n```\n\n把更新过的模块进行遍历，找到被该模块影响到的祖先模块，返回一个结果，如果结果标识为 unaccepted 就会被抛出错误，然后走到 webpack/hot/dev-server.js 里的 catch 进行页面级刷新。如果被 accept 的话就会执行后面的 apply 的逻辑。\n\n\n```js\nfunction getAffectedStuff(updateModuleId) {\n  var outdatedModules = [updateModuleId];\n  var outdatedDependencies = {};\n\n  var queue = outdatedModules.map(function(id) {\n    return {\n      chain: [id],\n      id: id\n    };\n  });\n  // 1. 遍历 queue\n  while (queue.length > 0) {\n    var queueItem = queue.pop();\n    var moduleId = queueItem.id;\n    var chain = queueItem.chain;\n    // 2. 找到改模块的旧版本\n    module = installedModules[moduleId];\n\n    // 3. 如果到根模块了，返回 unaccepted\n    if (module.hot._main) {\n      return {\n        type: \"unaccepted\",\n        chain: chain,\n        moduleId: moduleId\n      };\n    }\n    // 4. 遍历父模块\n    for (var i = 0; i < module.parents.length; i++) {\n      var parentId = module.parents[i];\n      var parent = installedModules[parentId];\n      \n      // 5. 如果父模块处理了模块变更的话就跳过，继续检查\n      if (parent.hot._acceptedDependencies[moduleId]) {\n        continue;\n      }\n      outdatedModules.push(parentId);\n      // 6. 没跳过的话推入队列，继续检查\n      queue.push({\n        chain: chain.concat([parentId]),\n        id: parentId\n      });\n    }\n  }\n\n  // 7.如果所有依赖路径都有被 accept 就返回 accepted\n  return {\n    type: \"accepted\",\n    moduleId: updateModuleId,\n    outdatedModules: outdatedModules,\n    outdatedDependencies: outdatedDependencies\n  };\n}\n```\n\n### module apply\n\n看过 webpack runtime 代码的应该知道 runtime 里声明了 installedModules 这个变量，里面缓存了所有被 __webpack_require__ 调用后加载过的模块，还有 modules 这个变量存储了所有模块，为了理解下面模块替换的部分可以先去看下 webpack runtime 代码的执行机制。如果模块有被 accept 的话，那么就会从 installedModules 里删掉旧的模块，把模块从父子依赖中删除，然后把 modules 里面的模块替换成新的模块。\n\n```js\n// remove module from cache\ndelete installedModules[moduleId];\n\n\n// insert new code\nfor (moduleId in appliedUpdate) {\n    if (Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {\n        modules[moduleId] = appliedUpdate[moduleId];\n    }\n}\n```\n\n这样仅仅完成了模块的替换，还没有执行过新模块代码，也就是没被 __webpack_require__ 调用过。新模块代码的执行是在 accept 函数的的 callback 里被 webpack 自动插入代码执行的。\n\n```js\nif(module.hot) {\n    module.hot.accept('./App', function() {\n        console.log('accepted')\n    })\n}\n```\n\n会被 webpack 改造为\n\n```js\nif(true) {\n    module.hot.accept(\"./src/App.js\", function(__WEBPACK_OUTDATED_DEPENDENCIES__) { \n      _App__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./src/App.js\");\n      (function() {\n        console.log('accepted')\n      })(__WEBPACK_OUTDATED_DEPENDENCIES__); \n    }.bind(this))\n}\n```\n\n所以新模块的代码是在 accept 方法回调执行之前被执行的。引入了新代码后就可以执行我们的业务代码，这些业务代码一般都和框架相关，框架去处理模块的热更新逻辑。比如 react-hot-loader, vue-loader 。\n\n## 总结\n\n最后总结一下，webpack-dev-server 可以作为命令行工具使用，核心模块依赖是 webpack 和 webpack-dev-middleware。webapck-dev-server 负责启动一个 express 服务器监听客户端请求；实例化 webpack compiler；启动负责推送 webpack 编译信息的 webscoket 服务器；负责向 bundle.js 注入和服务端通信用的 webscoket 客户端代码和处理逻辑。webapck-dev-middleware 把 webpack compiler 的 outputFileSystem 改为 in-memory fileSystem；启动 webpack watch 编译；处理浏览器发出的静态资源的请求，把 webpack 输出到内存的文件响应给浏览器。\n\n每次 webpack 编译完成后向客户端广播 ok 消息，客户端收到信息后根据是否开启 hot 模式使用 liveReload 页面级刷新模式或者 hotReload 模块热替换。hotReload 存在失败的情况，失败的情况下会降级使用页面级刷新。\n\n开启 hot 模式，即启用 HMR 插件。hot 模式会向服务器请求更新过后的模块，然后对模块的父模块进行回溯，对依赖路径进行判断，如果每条依赖路径都配置了模块更新后所需的业务处理回到函数则是 accepted 状态，否则就降级刷新页面。判断 accepted 状态后对旧的缓存模块和父子依赖模块进行替换和删除，然后执行 accept 方法的回调函数，执行新模块代码，引入新模块，执行业务处理代码。\n\n想要更加熟悉完整的运行流程还是需要自己打开浏览器，断点调试。","slug":"how-wepback-dev-server-run","published":1,"updated":"2020-09-18T11:24:38.191Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhpu92xn000iak871p63idj7","content":"<p>现代 web 开发者们对于 webpack 想必已经很熟悉了。webpack-dev-server 几乎也是标配。但是 webpack-dev-server 背后的运行原理是怎样的呢？想了解 how 我们先看看 what。webpack 将我们的项目源代码进行编译打包成可分发上线的静态资源，在开发阶段我们想要预览页面效果的话就需要启动一个服务器伺服 webpack 编译出来的静态资源。webpack-dev-server 就是用来伺服这些静态资源，除此之外，它还默认提供了liveReload的功能，就是在一次 webpack 编译完成后浏览器端就能自动刷新页面读取最新的编译后资源。为了提升开发体验，它还提供了 hot 选项开启 hotReload，相对于 liveReload, hotReload 不刷新整个页面，只更新被更改过的模块。</p>\n<p><img src=\"/images/flow.jpg\" alt=\"alt\"></p>\n<p>上图是我对 webpack-dev-server 的一个简单的整理。具体的实现原理是怎样的我们接着往下看。</p>\n<h2 id=\"版本\"><a href=\"#版本\" class=\"headerlink\" title=\"版本\"></a>版本</h2><p>本文基于以下版本进行分析</p>\n<ul>\n<li><a href=\"https://github.com/webpack/webpack-dev-server/tree/v3.11.0\" target=\"_blank\" rel=\"noopener\">webpack-dev-server@3.11.0</a></li>\n<li><a href=\"https://github.com/webpack/webpack/tree/v4.44.1\" target=\"_blank\" rel=\"noopener\">webpack@4.44.1</a></li>\n</ul>\n<h2 id=\"入口\"><a href=\"#入口\" class=\"headerlink\" title=\"入口\"></a>入口</h2><p>如果作为命令行启动，<code>webpack-dev-server/bin/webpack-dev-server.js</code> 就是整个命令行的入口。贴出来的代码进行了一些精简，忽略了一些非核心的分支处理，只关心webpack-dev-server的是核心逻辑。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack-dev-server/bin/webpack-dev-server.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">startDevServer</span>(<span class=\"params\">config, options</span>) </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> compiler;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">try</span> {</span><br><span class=\"line\">    <span class=\"comment\">// 2. 调用webpack函数返回的是 webpack compiler 实例</span></span><br><span class=\"line\">    compiler = webpack(config);</span><br><span class=\"line\">  } <span class=\"keyword\">catch</span> (err) {</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">try</span> {</span><br><span class=\"line\">    <span class=\"comment\">// 3. 实例化 webpack-dev-server</span></span><br><span class=\"line\">    server = <span class=\"keyword\">new</span> Server(compiler, options, log);</span><br><span class=\"line\">  } <span class=\"keyword\">catch</span> (err) {</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (options.socket) {</span><br><span class=\"line\">  } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">    <span class=\"comment\">// 4. 调用 server 实例的 listen 方法</span></span><br><span class=\"line\">    server.listen(options.port, options.host, (err) => {</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (err) {</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">      }</span><br><span class=\"line\">    });</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1. 对参数进行处理后启动</span></span><br><span class=\"line\">processOptions(config, argv, (config, options) => {</span><br><span class=\"line\">  startDevServer(config, options);</span><br><span class=\"line\">});</span><br></pre></td></tr></tbody></table></figure>\n<p>webpack-dev-server 作为命令行启动，首先是调用了 webpack-cli 模块下的两个文件，分别配置了命令行提示选项、和从命令行和配置文件收集了 webpack 的 config，这样保持和 webpack-cli 的行为一致，上面贴出来的代码省略了这些代码，有兴趣的可以自己翻阅源码。之后调用processOptions 对收集的参数进行一些默认处理后得到传给 webpack 的 config 和传给 wepack-dev-server 的options。然后传入这两个配置参数调用 startDevServer，startDevServer 这个函数主要是先调用 webpack 函数实例化了 compiler, 注意这里没有给 webpack 函数传入回调函数，根据 webpack 源码，不传入回调函数就不会直接运行 webpack 而是返回 webpack compiler 的实例，供调用方自行调用。拿到 webpack compiler 实例和先前的 webapck-dev-server 的 options 就去实例化 Server，这个 Server 类就是实现 webpack-dev-server 的核心逻辑。最后调用 Server 类的 listen 方法，就正式开启监听请求，listen 方法后面会再解析具体逻辑。这就是 webapck-dev-server 大致的启动过程，后面来看下 Server 类具体做了什么。</p>\n<h2 id=\"核心框架\"><a href=\"#核心框架\" class=\"headerlink\" title=\"核心框架\"></a>核心框架</h2><figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack-dev-server/lib/Server.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Server</span> </span>{</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(compiler, options = {}, _log) {</span><br><span class=\"line\">    <span class=\"comment\">// 0. 校验参数是否符合 schema, 不符合会抛出错误</span></span><br><span class=\"line\">    validateOptions(schema, options, <span class=\"string\">'webpack Dev Server'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.compiler = compiler;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.options = options;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 为一些选项提供默认参数</span></span><br><span class=\"line\">    normalizeOptions(<span class=\"keyword\">this</span>.compiler, <span class=\"keyword\">this</span>.options);</span><br><span class=\"line\">    <span class=\"comment\">// 2. 对 webpack compiler 进行一些修改  webpack-dev-server/lib/utils/updateCompiler.js</span></span><br><span class=\"line\">    <span class=\"comment\">//    - 如果设置了 hot 选项，自动给 webpack 配置 HotModuleReplacementPlugin</span></span><br><span class=\"line\">    <span class=\"comment\">//    - 注入一些客户端代码：webpack 的 websocket 客户端依赖 sockJS/websocket + websocket 客户端业务代码 + hot 模式下的 webpack/hot/dev-server</span></span><br><span class=\"line\">    updateCompiler(<span class=\"keyword\">this</span>.compiler, <span class=\"keyword\">this</span>.options);</span><br><span class=\"line\">    <span class=\"comment\">// 3. 添加一些 hooks 插件，这里主要关注 webpack compiler 的 done 钩子，即每次编译完成后的钩子 (编译完成触发 _sendStats 方法给客户端广播消息 )</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setupHooks();</span><br><span class=\"line\">    <span class=\"comment\">// 4. 实例化 express 服务器</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setupApp();</span><br><span class=\"line\">    <span class=\"comment\">// 5. 设置 webpack-dev-middleware，用于处理对静态资源的处理，后面解析</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setupDevMiddleware();</span><br><span class=\"line\">    <span class=\"comment\">// 6. 创建 HTTP 服务器</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.createServer();</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  setupApp() {</span><br><span class=\"line\">    <span class=\"comment\">// Init express server</span></span><br><span class=\"line\">    <span class=\"comment\">// eslint-disable-next-line new-cap</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.app = <span class=\"keyword\">new</span> express();</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  setupHooks() {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> addHooks = <span class=\"function\">(<span class=\"params\">compiler</span>) =></span> {</span><br><span class=\"line\">      <span class=\"keyword\">const</span> { compile  } = compiler.hooks;</span><br><span class=\"line\">      done.tap(<span class=\"string\">'webpack-dev-server'</span>, (stats) => {</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._sendStats(<span class=\"keyword\">this</span>.sockets, <span class=\"keyword\">this</span>.getStats(stats));</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._stats = stats;</span><br><span class=\"line\">      });</span><br><span class=\"line\">    };</span><br><span class=\"line\">    addHooks(<span class=\"keyword\">this</span>.compiler);</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  setupDevMiddleware() {</span><br><span class=\"line\">    <span class=\"comment\">// middleware for serving webpack bundle</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.middleware = webpackDevMiddleware(</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.compiler,</span><br><span class=\"line\">      <span class=\"built_in\">Object</span>.assign({}, <span class=\"keyword\">this</span>.options, { <span class=\"attr\">logLevel</span>: <span class=\"keyword\">this</span>.log.options.level })</span><br><span class=\"line\">    );</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.app.use(<span class=\"keyword\">this</span>.middleware);</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  createServer() {</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.listeningApp = http.createServer(<span class=\"keyword\">this</span>.app);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.listeningApp.on(<span class=\"string\">'error'</span>, (err) => {</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.log.error(err);</span><br><span class=\"line\">    });</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  listen(port, hostname, fn) {</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.hostname = hostname;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.listeningApp.listen(port, hostname, (err) => {</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.createSocketServer();</span><br><span class=\"line\">    });</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  createSocketServer() {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> SocketServerImplementation = <span class=\"keyword\">this</span>.socketServerImplementation;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.socketServer = <span class=\"keyword\">new</span> SocketServerImplementation(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.socketServer.onConnection(<span class=\"function\">(<span class=\"params\">connection, headers</span>) =></span> {</span><br><span class=\"line\">      <span class=\"comment\">// 连接后保存客户端连接</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.sockets.push(connection);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.hot) {</span><br><span class=\"line\">        <span class=\"comment\">// hot 选项先广播一个 hot 类型的消息</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.sockWrite([connection], <span class=\"string\">'hot'</span>);</span><br><span class=\"line\">      }</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">this</span>._sendStats([connection], <span class=\"keyword\">this</span>.getStats(<span class=\"keyword\">this</span>._stats), <span class=\"literal\">true</span>);</span><br><span class=\"line\">    });</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// eslint-disable-next-line</span></span><br><span class=\"line\">  sockWrite(sockets, type, data) {</span><br><span class=\"line\">    sockets.forEach(<span class=\"function\">(<span class=\"params\">socket</span>) =></span> {</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.socketServer.send(socket, <span class=\"built_in\">JSON</span>.stringify({ type, data }));</span><br><span class=\"line\">    });</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// send stats to a socket or multiple sockets</span></span><br><span class=\"line\">  _sendStats(sockets, stats, force) {</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sockWrite(sockets, <span class=\"string\">'hash'</span>, stats.hash);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (stats.errors.length > <span class=\"number\">0</span>) {</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.sockWrite(sockets, <span class=\"string\">'errors'</span>, stats.errors);</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (stats.warnings.length > <span class=\"number\">0</span>) {</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.sockWrite(sockets, <span class=\"string\">'warnings'</span>, stats.warnings);</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.sockWrite(sockets, <span class=\"string\">'ok'</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>这部分代码稍长，主逻辑都在构造函数里。在构造函数中进行参数校验，参数缺省值处理，注入客户端代码，绑定 webpack compiler 钩子，这里主要关注是 done 钩子，(在 webpack compiler 实例每次触发编译完成后就会进行 webscoket 广播 webpack 的编译信息)。实例化 express 服务器，添加 webpack-dev-middleware 中间件用于处理静态资源的请求，然后初始化 HTTP 服务器。我们在上面的 webpack-dev-server.js 中调用的 listen 方法就是开始监听配置的端口，监听回调里再初始化 websocket 的服务端。<br>代码执行到这已经完成了服务器端所有的逻辑，但是 webpack 还没有启动编译，用户打开浏览器后请求设置的IP和端口又是怎么处理的呢。那这个部分暂时被我们略过了，这部分就是 webpack-dev-middleware 处理的内容了。</p>\n<h2 id=\"webapck-dev-middleware-初始化\"><a href=\"#webapck-dev-middleware-初始化\" class=\"headerlink\" title=\"webapck-dev-middleware 初始化\"></a>webapck-dev-middleware 初始化</h2><p>webapck-dev-middleware 作为一个独立的模块，以下是它的目录结构</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── README.md</span><br><span class=\"line\">├── index.js</span><br><span class=\"line\">├── lib</span><br><span class=\"line\">│   ├── DevMiddlewareError.js</span><br><span class=\"line\">│   ├── context.js</span><br><span class=\"line\">│   ├── fs.js</span><br><span class=\"line\">│   ├── middleware.js</span><br><span class=\"line\">│   ├── reporter.js</span><br><span class=\"line\">│   └── util.js</span><br><span class=\"line\">└── package.json</span><br></pre></td></tr></tbody></table></figure>\n<p>webapck-dev-middleware 初始化执行</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack-dev-middleware/index.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wdm</span>(<span class=\"params\">compiler, opts</span>) </span>{</span><br><span class=\"line\">  <span class=\"keyword\">const</span> options = <span class=\"built_in\">Object</span>.assign({}, defaults, opts);</span><br><span class=\"line\">  <span class=\"comment\">// 1. 初始化 context</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> context = createContext(compiler, options);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// start watching</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!options.lazy) {</span><br><span class=\"line\">    <span class=\"comment\">// 2. 启动 webpack 编译</span></span><br><span class=\"line\">    context.watching = compiler.watch(options.watchOptions, (err) => {</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (err) {</span><br><span class=\"line\">        context.log.error(err.stack || err);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err.details) {</span><br><span class=\"line\">          context.log.error(err.details);</span><br><span class=\"line\">        }</span><br><span class=\"line\">      }</span><br><span class=\"line\">    });</span><br><span class=\"line\">  } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">    <span class=\"comment\">// lazy 模式是请求过来一次才webpack编译一次, 这里不关注</span></span><br><span class=\"line\">  }</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 3. 替换 webpack 默认的 outputFileSystem 为 memory-fs, 存取都在内存上操作</span></span><br><span class=\"line\">  <span class=\"comment\">// fileSystem = new MemoryFileSystem();</span></span><br><span class=\"line\">  <span class=\"comment\">// compiler.outputFileSystem = fileSystem;</span></span><br><span class=\"line\">  setFs(context, compiler);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 3. 执行 middleware 函数返回真正的 middleware</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> middleware(context);</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n<p>wdm 函数返回结果是 express 标准的 middleware 用于处理浏览器静态资源的请求。执行过程中显示初始化了一个 context 对象，默认不是 lazy 模式的情况下，开启了 webpack 的 watch 模式开始启动编译。 然后将 compiler 的原来基于 fs 模块的 outputFileSystem 替换成 <a href=\"https://www.npmjs.com/package/memory-fs\" target=\"_blank\" rel=\"noopener\">memory-fs</a>模块的实例。memory-fs 是实现了 node fs api 的基于内存的 fileSystem，这意味着 webpack 编译后的资源不会被输出到硬盘而是内存。最后将真正处理请求的 middleware 返回装载在 express 上。</p>\n<h2 id=\"webapck-dev-middleware-处理请求\"><a href=\"#webapck-dev-middleware-处理请求\" class=\"headerlink\" title=\"webapck-dev-middleware 处理请求\"></a>webapck-dev-middleware 处理请求</h2><p>当用户在浏览器打开配置的IP和端口，如 <a href=\"https://localhost:8080，请求就会被\" target=\"_blank\" rel=\"noopener\">https://localhost:8080，请求就会被</a> middleware 处理。middleware 从内存中读到请求的资源就返回给客户端。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack-dev-middleware/lib/middleware.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wrapper</span>(<span class=\"params\">context</span>) </span>{</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">middleware</span>(<span class=\"params\">req, res, next</span>) </span>{</span><br><span class=\"line\">    <span class=\"comment\">// 1. 根据请求的 URL 地址，得到绝对路径的 webpack 输出的资源路径地址</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> filename = getFilenameFromUrl(</span><br><span class=\"line\">      context.options.publicPath,</span><br><span class=\"line\">      context.compiler,</span><br><span class=\"line\">      req.url</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =></span> {</span><br><span class=\"line\">      handleRequest(context, filename, processRequest, req);</span><br><span class=\"line\">      <span class=\"comment\">// eslint-disable-next-line consistent-return</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">processRequest</span>(<span class=\"params\"></span>) </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 2.从内存读取到资源内容</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> content = context.fs.readFileSync(filename);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 3. 返回给客户端</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (res.send) {</span><br><span class=\"line\">          res.send(content);</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">          res.end(content);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        resolve();</span><br><span class=\"line\">      }</span><br><span class=\"line\">    });</span><br><span class=\"line\">  };</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n<h2 id=\"webscoket-通信\"><a href=\"#webscoket-通信\" class=\"headerlink\" title=\"webscoket 通信\"></a>webscoket 通信</h2><p>当我们编辑了源代码，触发 webpack 重新编译，编译完成后执行 done 钩子上的回调。具体可参考上面 Server.js 中 setupHooks 方法。_sendStats 方法会先广播一个类型为 hash 的消息，然后再根据编译信息广播 warnings/errors/ok 消息。这里我们只关注正常流程 ok 消息。</p>\n<p>我们已经很熟悉客户端接收到更新后都会对应用进行 Reload 来获取更好的开发体验。具体是 liveReload（刷新整个页面）还是 hotReload（更新改动过的模块）就取决于我们的 hot 选项。</p>\n<p>这些代码我们在上面就讲到过是在 webpack 编译的时候注入到 bundle.js 进去的。当用户打开页面预览时，这些代码就会自动执行。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack-dev-server/client/index.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> onSocketMessage = {</span><br><span class=\"line\">  hot: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hot</span>(<span class=\"params\"></span>) </span>{</span><br><span class=\"line\">    options.hot = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    log.info(<span class=\"string\">'[WDS] Hot Module Replacement enabled.'</span>);</span><br><span class=\"line\">  },</span><br><span class=\"line\">  liveReload: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">liveReload</span>(<span class=\"params\"></span>) </span>{</span><br><span class=\"line\">    options.liveReload = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    log.info(<span class=\"string\">'[WDS] Live Reloading enabled.'</span>);</span><br><span class=\"line\">  },</span><br><span class=\"line\">  hash: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hash</span>(<span class=\"params\">_hash</span>) </span>{</span><br><span class=\"line\">    status.currentHash = _hash;</span><br><span class=\"line\">  },</span><br><span class=\"line\">  ok: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ok</span>(<span class=\"params\"></span>) </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (options.initial) {</span><br><span class=\"line\">      <span class=\"keyword\">return</span> options.initial = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    } <span class=\"comment\">// eslint-disable-line no-return-assign</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    reloadApp(options, status);</span><br><span class=\"line\">  }</span><br><span class=\"line\">};</span><br><span class=\"line\">socket(socketUrl, onSocketMessage);</span><br></pre></td></tr></tbody></table></figure>\n<p>client/index.js 主要就是初始化了 webscoket 客户端，然后为不同的消息类型设置了相应的回调函数。</p>\n<p>在前面 Server.js 中我们看到如果 hot 选项为 true 时，当 websocket 客户端连接到服务端，服务端会先广播一个 hot 类型的消息，客户端接收到后会把 options 对象的 hot 设置为 true。<br>服务端在每次编译后都会广播 hash 消息，客户端接收到后就会将这个webpack 编译产生的 hash 值暂存起来。编译成功如果没有 warning 也没有 error 就会广播 ok 消息，客户端接收到 ok 消息就会执行 ok 回调函数中的 reloadApp 刷新应用。</p>\n<h2 id=\"webscoket-消息处理\"><a href=\"#webscoket-消息处理\" class=\"headerlink\" title=\"webscoket 消息处理\"></a>webscoket 消息处理</h2><figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack-dev-server/client/utils/reloadApp.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reloadApp</span>(<span class=\"params\">_ref, _ref2</span>) </span>{</span><br><span class=\"line\">  <span class=\"keyword\">var</span> hotReload = _ref.hotReload,</span><br><span class=\"line\">      hot = _ref.hot,</span><br><span class=\"line\">      liveReload = _ref.liveReload,</span><br><span class=\"line\">      currentHash = _ref2.currentHash;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (hot) {</span><br><span class=\"line\">    log.info(<span class=\"string\">'[WDS] App hot update...'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> hotEmitter = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack/hot/emitter'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    hotEmitter.emit(<span class=\"string\">'webpackHotUpdate'</span>, currentHash);</span><br><span class=\"line\">  } </span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (liveReload) {</span><br><span class=\"line\">      <span class=\"keyword\">var</span> rootWindow = self; <span class=\"comment\">// use parent window for reload (in case we're in an iframe with no valid src)</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">var</span> intervalId = self.setInterval(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>{</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rootWindow.location.protocol !== <span class=\"string\">'about:'</span>) {</span><br><span class=\"line\">          <span class=\"comment\">// reload immediately if protocol is valid</span></span><br><span class=\"line\">          applyReload(rootWindow, intervalId);</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">          rootWindow = rootWindow.parent;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (rootWindow.parent === rootWindow) {</span><br><span class=\"line\">            <span class=\"comment\">// if parent equals current window we've reached the root which would continue forever, so trigger a reload anyways</span></span><br><span class=\"line\">            applyReload(rootWindow, intervalId);</span><br><span class=\"line\">          }</span><br><span class=\"line\">        }</span><br><span class=\"line\">      });</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">applyReload</span>(<span class=\"params\">rootWindow, intervalId</span>) </span>{</span><br><span class=\"line\">    clearInterval(intervalId);</span><br><span class=\"line\">    log.info(<span class=\"string\">'[WDS] App updated. Reloading...'</span>);</span><br><span class=\"line\">    rootWindow.location.reload();</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h2 id=\"Hot-Module-Replacement\"><a href=\"#Hot-Module-Replacement\" class=\"headerlink\" title=\"Hot Module Replacement\"></a>Hot Module Replacement</h2><h3 id=\"触发-hot-check\"><a href=\"#触发-hot-check\" class=\"headerlink\" title=\"触发 hot check\"></a>触发 hot check</h3><p>如果设置了 hot: true 客户端就会引入 webpack/hot/emitter，触发一个 webpackHotUpdate 事件，将 hash 值传递过去。这个 <code>webpack/hot/emitter</code> 我们查阅 webpack 源码看到其实就是 node 的 events 模块。我们暂时不关注这个事件会触发什么回调后面再具体再看。如果没有设置 hot: true。那么就是使用 liveReload 模式，liveReload 就比较无脑，直接刷新整个页面。</p>\n<p>再回到上一个问题，到底是在哪里接收 webpackHotUpdate 事件并处理的呢？就是 webpack/hot/dev-server.js 中处理的。在这里会去检查是否可以更新，如果更新失败就会刷新整个页面来降级实现代码更新的功能。其实我们回过头来看看这样降级也是必须的，如果更新失败，源码更新了，而客户端的代码却没更新，这样显示是不合理的。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> lastHash;</span><br><span class=\"line\"><span class=\"keyword\">var</span> upToDate = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upToDate</span>(<span class=\"params\"></span>) </span>{</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> lastHash.indexOf(__webpack_hash__) >= <span class=\"number\">0</span>;</span><br><span class=\"line\">};</span><br><span class=\"line\"><span class=\"keyword\">var</span> log = <span class=\"built_in\">require</span>(<span class=\"string\">\"./log\"</span>);</span><br><span class=\"line\">   <span class=\"comment\">// 2. 检查更新</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> check = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">check</span>(<span class=\"params\"></span>) </span>{</span><br><span class=\"line\">   <span class=\"comment\">// 3. 具体的检查逻辑</span></span><br><span class=\"line\">\t<span class=\"built_in\">module</span>.hot</span><br><span class=\"line\">\t\t.check(<span class=\"literal\">true</span>)</span><br><span class=\"line\">\t\t.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">updatedModules</span>) </span>{</span><br><span class=\"line\">       <span class=\"comment\">// 3.1 更新成功</span></span><br><span class=\"line\">\t\t})</span><br><span class=\"line\">\t\t.catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>{</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> status = <span class=\"built_in\">module</span>.hot.status();</span><br><span class=\"line\">       <span class=\"comment\">// 3.2 更新失败，降级为重新刷新整个应用</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ([<span class=\"string\">\"abort\"</span>, <span class=\"string\">\"fail\"</span>].indexOf(status) >= <span class=\"number\">0</span>) {</span><br><span class=\"line\">\t\t\t\tlog(</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">\"warning\"</span>,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">\"[HMR] Cannot apply update. Need to do a full reload!\"</span></span><br><span class=\"line\">\t\t\t\t);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">window</span>.location.reload();</span><br><span class=\"line\">\t\t\t} <span class=\"keyword\">else</span> {</span><br><span class=\"line\">\t\t\t\tlog(<span class=\"string\">\"warning\"</span>, <span class=\"string\">\"[HMR] Update failed: \"</span> + log.formatError(err));</span><br><span class=\"line\">\t\t\t}</span><br><span class=\"line\">\t\t});</span><br><span class=\"line\">};</span><br><span class=\"line\"><span class=\"keyword\">var</span> hotEmitter = <span class=\"built_in\">require</span>(<span class=\"string\">\"./emitter\"</span>);</span><br><span class=\"line\"> <span class=\"comment\">// 1. 注册事件回调</span></span><br><span class=\"line\">hotEmitter.on(<span class=\"string\">\"webpackHotUpdate\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">currentHash</span>) </span>{</span><br><span class=\"line\">\tlastHash = currentHash;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!upToDate() && <span class=\"built_in\">module</span>.hot.status() === <span class=\"string\">\"idle\"</span>) {</span><br><span class=\"line\">\t\tlog(<span class=\"string\">\"info\"</span>, <span class=\"string\">\"[HMR] Checking for updates on the server...\"</span>);</span><br><span class=\"line\">\t\tcheck();</span><br><span class=\"line\">\t}</span><br><span class=\"line\">});</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"模块更新依赖判断\"><a href=\"#模块更新依赖判断\" class=\"headerlink\" title=\"模块更新依赖判断\"></a>模块更新依赖判断</h3><p>module.hot.check 方法位于 webpack/lib/HotModuleReplacement.runtime.js 中，是 webpack 内置的 HotModuleReplacementPlugin 注入在 webpack bootstrap runtime 中的。</p>\n<p>所以 check 方法主要做了什么呢，这里提前总结一下。在 webpack 使用了 HotModuleReplacementPlugin 编译时，每次增量编译就会多产出两个文件，形如<code>c390bbe0037a0dd079a6.hot-update.json</code>，<code>main.c390bbe0037a0dd079a6.hot-update.js</code>，分别是描述 chunk 更新的 manifest文件和更新过后的 chunk 文件。那么浏览器端调用 hotDownloadManifest 去下载模块更新的 manifest.json 文件，然后使用 hotDownloadUpdateChunk 使用 jsonp 的方式下载需要更新的 chunk。hotDownloadUpdateChunk 下载完成后调用 webpackHotUpdate 回调。回调内拿到更新的模块，然后从模块自身开始进行冒泡，如果发现<strong>只要有一条</strong>祖先路径没有 accept 这次改动就直接刷新页面实行降级强制更新, 如果有被 accept, 就会替换掉原来 webpack runtime 里 module 里旧的模块，然后再执行 accept 的 callback 进行更新。为什么要执行这样的判断呢？</p>\n<p>假设给定这样的依赖路径</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentA.js -> componentB.js -> app.js -> index.js</span><br><span class=\"line\">componentA.js -> componentC.js -> app.js -> index.js</span><br></pre></td></tr></tbody></table></figure>\n<p>accept 指该 module 的祖先模块调用了 module.hot.accept 处理了该 module 更新过后的业务逻辑，一般都是 rerender。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"built_in\">module</span>.hot) {</span><br><span class=\"line\">    <span class=\"built_in\">module</span>.hot.accept(<span class=\"string\">'./app'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>{</span><br><span class=\"line\">        rerender()</span><br><span class=\"line\">    })</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>如果我们对 componentA.js 进行了更改，但是如果仅仅 componentB accept 了更改，componentC 却没 accept，那么这样是没有到达更新的目的的。所以在祖先路径回溯的时候，要保证每一条路径都被 accept。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hotCheck</span>(<span class=\"params\">apply</span>) </span>{</span><br><span class=\"line\">  <span class=\"comment\">// 1. 拿这次编译后的 hash 请求服务器，拿到结构为 {c: {main: true} h: \"ac69ee760bb48d5db5f5\"} 的数据</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> hotDownloadManifest(hotRequestTimeout).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">update</span>) </span>{</span><br><span class=\"line\">    hotAvailableFilesMap = update.c;</span><br><span class=\"line\">    hotUpdateNewHash = update.h;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2. 生成一个 defered promise，供上面提到的 promise 链消费</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>{</span><br><span class=\"line\">      hotDeferred = {</span><br><span class=\"line\">        resolve: resolve,</span><br><span class=\"line\">        reject: reject</span><br><span class=\"line\">      };</span><br><span class=\"line\">    });</span><br><span class=\"line\"></span><br><span class=\"line\">    hotUpdate = {};</span><br><span class=\"line\">    <span class=\"comment\">// 3. 这个方法里面调用的就是 hotDownloadUpdateChunk，就是发起一个 jsonp 请求更新过后的 chunk，jsonp的回调是 HMR runtime 里的 webpackHotUpdate</span></span><br><span class=\"line\">    {</span><br><span class=\"line\">      hotEnsureUpdateChunk(chunkId);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> promise;</span><br><span class=\"line\">  });</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>hotCheck 方法就是和服务器进行通信拿到更新过后的 chunk，下载好 chunk 后就开始执行 HMR runtime 里的 webpackHotUpdate 回调。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>[<span class=\"string\">\"webpackHotUpdate\"</span>] = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">webpackHotUpdateCallback</span>(<span class=\"params\">chunkId, moreModules</span>) </span>{</span><br><span class=\"line\">\thotAddUpdateChunk(chunkId, moreModules);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);</span><br><span class=\"line\">} ;</span><br></pre></td></tr></tbody></table></figure>\n<p>经过一系列方法调用然后来到 hotApplyInternal 方法，这个方法把更新过后的模块 apply 到业务中，整个方法比较长，就不完整贴出来了。这里拿出核心的部分，</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> id <span class=\"keyword\">in</span> hotUpdate) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(hotUpdate, id)) {</span><br><span class=\"line\">        <span class=\"keyword\">var</span> result;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hotUpdate[id]) {</span><br><span class=\"line\">            result = getAffectedStuff(moduleId);</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            result = {</span><br><span class=\"line\">                type: <span class=\"string\">\"disposed\"</span>,</span><br><span class=\"line\">                moduleId: id</span><br><span class=\"line\">            };</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (result.type) {</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">\"self-declined\"</span>:</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">\"declined\"</span>:</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">\"unaccepted\"</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (options.onUnaccepted) options.onUnaccepted(result);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!options.ignoreUnaccepted)</span><br><span class=\"line\">                    abortError = <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">                        <span class=\"string\">\"Aborted because \"</span> + moduleId + <span class=\"string\">\" is not accepted\"</span> + chainInfo</span><br><span class=\"line\">                    );</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">\"accepted\"</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (options.onAccepted) options.onAccepted(result);</span><br><span class=\"line\">                doApply = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">\"disposed\"</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"Unexception type \"</span> + result.type);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>把更新过的模块进行遍历，找到被该模块影响到的祖先模块，返回一个结果，如果结果标识为 unaccepted 就会被抛出错误，然后走到 webpack/hot/dev-server.js 里的 catch 进行页面级刷新。如果被 accept 的话就会执行后面的 apply 的逻辑。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getAffectedStuff</span>(<span class=\"params\">updateModuleId</span>) </span>{</span><br><span class=\"line\">  <span class=\"keyword\">var</span> outdatedModules = [updateModuleId];</span><br><span class=\"line\">  <span class=\"keyword\">var</span> outdatedDependencies = {};</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> queue = outdatedModules.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id</span>) </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> {</span><br><span class=\"line\">      chain: [id],</span><br><span class=\"line\">      id: id</span><br><span class=\"line\">    };</span><br><span class=\"line\">  });</span><br><span class=\"line\">  <span class=\"comment\">// 1. 遍历 queue</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (queue.length > <span class=\"number\">0</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">var</span> queueItem = queue.pop();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> moduleId = queueItem.id;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> chain = queueItem.chain;</span><br><span class=\"line\">    <span class=\"comment\">// 2. 找到改模块的旧版本</span></span><br><span class=\"line\">    <span class=\"built_in\">module</span> = installedModules[moduleId];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 3. 如果到根模块了，返回 unaccepted</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">module</span>.hot._main) {</span><br><span class=\"line\">      <span class=\"keyword\">return</span> {</span><br><span class=\"line\">        type: <span class=\"string\">\"unaccepted\"</span>,</span><br><span class=\"line\">        chain: chain,</span><br><span class=\"line\">        moduleId: moduleId</span><br><span class=\"line\">      };</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// 4. 遍历父模块</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i < <span class=\"built_in\">module</span>.parents.length; i++) {</span><br><span class=\"line\">      <span class=\"keyword\">var</span> parentId = <span class=\"built_in\">module</span>.parents[i];</span><br><span class=\"line\">      <span class=\"keyword\">var</span> parent = installedModules[parentId];</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">// 5. 如果父模块处理了模块变更的话就跳过，继续检查</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (parent.hot._acceptedDependencies[moduleId]) {</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      }</span><br><span class=\"line\">      outdatedModules.push(parentId);</span><br><span class=\"line\">      <span class=\"comment\">// 6. 没跳过的话推入队列，继续检查</span></span><br><span class=\"line\">      queue.push({</span><br><span class=\"line\">        chain: chain.concat([parentId]),</span><br><span class=\"line\">        id: parentId</span><br><span class=\"line\">      });</span><br><span class=\"line\">    }</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 7.如果所有依赖路径都有被 accept 就返回 accepted</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> {</span><br><span class=\"line\">    type: <span class=\"string\">\"accepted\"</span>,</span><br><span class=\"line\">    moduleId: updateModuleId,</span><br><span class=\"line\">    outdatedModules: outdatedModules,</span><br><span class=\"line\">    outdatedDependencies: outdatedDependencies</span><br><span class=\"line\">  };</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"module-apply\"><a href=\"#module-apply\" class=\"headerlink\" title=\"module apply\"></a>module apply</h3><p>看过 webpack runtime 代码的应该知道 runtime 里声明了 installedModules 这个变量，里面缓存了所有被 <strong>webpack_require</strong> 调用后加载过的模块，还有 modules 这个变量存储了所有模块，为了理解下面模块替换的部分可以先去看下 webpack runtime 代码的执行机制。如果模块有被 accept 的话，那么就会从 installedModules 里删掉旧的模块，把模块从父子依赖中删除，然后把 modules 里面的模块替换成新的模块。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// remove module from cache</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> installedModules[moduleId];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// insert new code</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (moduleId <span class=\"keyword\">in</span> appliedUpdate) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {</span><br><span class=\"line\">        modules[moduleId] = appliedUpdate[moduleId];</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>这样仅仅完成了模块的替换，还没有执行过新模块代码，也就是没被 <strong>webpack_require</strong> 调用过。新模块代码的执行是在 accept 函数的的 callback 里被 webpack 自动插入代码执行的。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"built_in\">module</span>.hot) {</span><br><span class=\"line\">    <span class=\"built_in\">module</span>.hot.accept(<span class=\"string\">'./App'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>{</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'accepted'</span>)</span><br><span class=\"line\">    })</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>会被 webpack 改造为</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">true</span>) {</span><br><span class=\"line\">    <span class=\"built_in\">module</span>.hot.accept(<span class=\"string\">\"./src/App.js\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">__WEBPACK_OUTDATED_DEPENDENCIES__</span>) </span>{ </span><br><span class=\"line\">      _App__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(<span class=\"string\">\"./src/App.js\"</span>);</span><br><span class=\"line\">      (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>{</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'accepted'</span>)</span><br><span class=\"line\">      })(__WEBPACK_OUTDATED_DEPENDENCIES__); </span><br><span class=\"line\">    }.bind(<span class=\"keyword\">this</span>))</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>所以新模块的代码是在 accept 方法回调执行之前被执行的。引入了新代码后就可以执行我们的业务代码，这些业务代码一般都和框架相关，框架去处理模块的热更新逻辑。比如 react-hot-loader, vue-loader 。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>最后总结一下，webpack-dev-server 可以作为命令行工具使用，核心模块依赖是 webpack 和 webpack-dev-middleware。webapck-dev-server 负责启动一个 express 服务器监听客户端请求；实例化 webpack compiler；启动负责推送 webpack 编译信息的 webscoket 服务器；负责向 bundle.js 注入和服务端通信用的 webscoket 客户端代码和处理逻辑。webapck-dev-middleware 把 webpack compiler 的 outputFileSystem 改为 in-memory fileSystem；启动 webpack watch 编译；处理浏览器发出的静态资源的请求，把 webpack 输出到内存的文件响应给浏览器。</p>\n<p>每次 webpack 编译完成后向客户端广播 ok 消息，客户端收到信息后根据是否开启 hot 模式使用 liveReload 页面级刷新模式或者 hotReload 模块热替换。hotReload 存在失败的情况，失败的情况下会降级使用页面级刷新。</p>\n<p>开启 hot 模式，即启用 HMR 插件。hot 模式会向服务器请求更新过后的模块，然后对模块的父模块进行回溯，对依赖路径进行判断，如果每条依赖路径都配置了模块更新后所需的业务处理回到函数则是 accepted 状态，否则就降级刷新页面。判断 accepted 状态后对旧的缓存模块和父子依赖模块进行替换和删除，然后执行 accept 方法的回调函数，执行新模块代码，引入新模块，执行业务处理代码。</p>\n<p>想要更加熟悉完整的运行流程还是需要自己打开浏览器，断点调试。</p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"excerpt":"","more":"<p>现代 web 开发者们对于 webpack 想必已经很熟悉了。webpack-dev-server 几乎也是标配。但是 webpack-dev-server 背后的运行原理是怎样的呢？想了解 how 我们先看看 what。webpack 将我们的项目源代码进行编译打包成可分发上线的静态资源，在开发阶段我们想要预览页面效果的话就需要启动一个服务器伺服 webpack 编译出来的静态资源。webpack-dev-server 就是用来伺服这些静态资源，除此之外，它还默认提供了liveReload的功能，就是在一次 webpack 编译完成后浏览器端就能自动刷新页面读取最新的编译后资源。为了提升开发体验，它还提供了 hot 选项开启 hotReload，相对于 liveReload, hotReload 不刷新整个页面，只更新被更改过的模块。</p>\n<p><img src=\"/images/flow.jpg\" alt=\"alt\"></p>\n<p>上图是我对 webpack-dev-server 的一个简单的整理。具体的实现原理是怎样的我们接着往下看。</p>\n<h2 id=\"版本\"><a href=\"#版本\" class=\"headerlink\" title=\"版本\"></a>版本</h2><p>本文基于以下版本进行分析</p>\n<ul>\n<li><a href=\"https://github.com/webpack/webpack-dev-server/tree/v3.11.0\" target=\"_blank\" rel=\"noopener\">webpack-dev-server@3.11.0</a></li>\n<li><a href=\"https://github.com/webpack/webpack/tree/v4.44.1\" target=\"_blank\" rel=\"noopener\">webpack@4.44.1</a></li>\n</ul>\n<h2 id=\"入口\"><a href=\"#入口\" class=\"headerlink\" title=\"入口\"></a>入口</h2><p>如果作为命令行启动，<code>webpack-dev-server/bin/webpack-dev-server.js</code> 就是整个命令行的入口。贴出来的代码进行了一些精简，忽略了一些非核心的分支处理，只关心webpack-dev-server的是核心逻辑。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack-dev-server/bin/webpack-dev-server.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">startDevServer</span>(<span class=\"params\">config, options</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> compiler;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2. 调用webpack函数返回的是 webpack compiler 实例</span></span><br><span class=\"line\">    compiler = webpack(config);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 3. 实例化 webpack-dev-server</span></span><br><span class=\"line\">    server = <span class=\"keyword\">new</span> Server(compiler, options, log);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (options.socket) &#123;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 4. 调用 server 实例的 listen 方法</span></span><br><span class=\"line\">    server.listen(options.port, options.host, (err) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1. 对参数进行处理后启动</span></span><br><span class=\"line\">processOptions(config, argv, (config, options) =&gt; &#123;</span><br><span class=\"line\">  startDevServer(config, options);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>webpack-dev-server 作为命令行启动，首先是调用了 webpack-cli 模块下的两个文件，分别配置了命令行提示选项、和从命令行和配置文件收集了 webpack 的 config，这样保持和 webpack-cli 的行为一致，上面贴出来的代码省略了这些代码，有兴趣的可以自己翻阅源码。之后调用processOptions 对收集的参数进行一些默认处理后得到传给 webpack 的 config 和传给 wepack-dev-server 的options。然后传入这两个配置参数调用 startDevServer，startDevServer 这个函数主要是先调用 webpack 函数实例化了 compiler, 注意这里没有给 webpack 函数传入回调函数，根据 webpack 源码，不传入回调函数就不会直接运行 webpack 而是返回 webpack compiler 的实例，供调用方自行调用。拿到 webpack compiler 实例和先前的 webapck-dev-server 的 options 就去实例化 Server，这个 Server 类就是实现 webpack-dev-server 的核心逻辑。最后调用 Server 类的 listen 方法，就正式开启监听请求，listen 方法后面会再解析具体逻辑。这就是 webapck-dev-server 大致的启动过程，后面来看下 Server 类具体做了什么。</p>\n<h2 id=\"核心框架\"><a href=\"#核心框架\" class=\"headerlink\" title=\"核心框架\"></a>核心框架</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack-dev-server/lib/Server.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Server</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(compiler, options = &#123;&#125;, _log) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 0. 校验参数是否符合 schema, 不符合会抛出错误</span></span><br><span class=\"line\">    validateOptions(schema, options, <span class=\"string\">'webpack Dev Server'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.compiler = compiler;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.options = options;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 为一些选项提供默认参数</span></span><br><span class=\"line\">    normalizeOptions(<span class=\"keyword\">this</span>.compiler, <span class=\"keyword\">this</span>.options);</span><br><span class=\"line\">    <span class=\"comment\">// 2. 对 webpack compiler 进行一些修改  webpack-dev-server/lib/utils/updateCompiler.js</span></span><br><span class=\"line\">    <span class=\"comment\">//    - 如果设置了 hot 选项，自动给 webpack 配置 HotModuleReplacementPlugin</span></span><br><span class=\"line\">    <span class=\"comment\">//    - 注入一些客户端代码：webpack 的 websocket 客户端依赖 sockJS/websocket + websocket 客户端业务代码 + hot 模式下的 webpack/hot/dev-server</span></span><br><span class=\"line\">    updateCompiler(<span class=\"keyword\">this</span>.compiler, <span class=\"keyword\">this</span>.options);</span><br><span class=\"line\">    <span class=\"comment\">// 3. 添加一些 hooks 插件，这里主要关注 webpack compiler 的 done 钩子，即每次编译完成后的钩子 (编译完成触发 _sendStats 方法给客户端广播消息 )</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setupHooks();</span><br><span class=\"line\">    <span class=\"comment\">// 4. 实例化 express 服务器</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setupApp();</span><br><span class=\"line\">    <span class=\"comment\">// 5. 设置 webpack-dev-middleware，用于处理对静态资源的处理，后面解析</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setupDevMiddleware();</span><br><span class=\"line\">    <span class=\"comment\">// 6. 创建 HTTP 服务器</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.createServer();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  setupApp() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Init express server</span></span><br><span class=\"line\">    <span class=\"comment\">// eslint-disable-next-line new-cap</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.app = <span class=\"keyword\">new</span> express();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  setupHooks() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> addHooks = <span class=\"function\">(<span class=\"params\">compiler</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; compile  &#125; = compiler.hooks;</span><br><span class=\"line\">      done.tap(<span class=\"string\">'webpack-dev-server'</span>, (stats) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._sendStats(<span class=\"keyword\">this</span>.sockets, <span class=\"keyword\">this</span>.getStats(stats));</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._stats = stats;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    addHooks(<span class=\"keyword\">this</span>.compiler);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  setupDevMiddleware() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// middleware for serving webpack bundle</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.middleware = webpackDevMiddleware(</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.compiler,</span><br><span class=\"line\">      <span class=\"built_in\">Object</span>.assign(&#123;&#125;, <span class=\"keyword\">this</span>.options, &#123; <span class=\"attr\">logLevel</span>: <span class=\"keyword\">this</span>.log.options.level &#125;)</span><br><span class=\"line\">    );</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.app.use(<span class=\"keyword\">this</span>.middleware);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  createServer() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.listeningApp = http.createServer(<span class=\"keyword\">this</span>.app);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.listeningApp.on(<span class=\"string\">'error'</span>, (err) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.log.error(err);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  listen(port, hostname, fn) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.hostname = hostname;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.listeningApp.listen(port, hostname, (err) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.createSocketServer();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  createSocketServer() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> SocketServerImplementation = <span class=\"keyword\">this</span>.socketServerImplementation;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.socketServer = <span class=\"keyword\">new</span> SocketServerImplementation(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.socketServer.onConnection(<span class=\"function\">(<span class=\"params\">connection, headers</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 连接后保存客户端连接</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.sockets.push(connection);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.hot) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// hot 选项先广播一个 hot 类型的消息</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.sockWrite([connection], <span class=\"string\">'hot'</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">this</span>._sendStats([connection], <span class=\"keyword\">this</span>.getStats(<span class=\"keyword\">this</span>._stats), <span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// eslint-disable-next-line</span></span><br><span class=\"line\">  sockWrite(sockets, type, data) &#123;</span><br><span class=\"line\">    sockets.forEach(<span class=\"function\">(<span class=\"params\">socket</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.socketServer.send(socket, <span class=\"built_in\">JSON</span>.stringify(&#123; type, data &#125;));</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// send stats to a socket or multiple sockets</span></span><br><span class=\"line\">  _sendStats(sockets, stats, force) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sockWrite(sockets, <span class=\"string\">'hash'</span>, stats.hash);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (stats.errors.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.sockWrite(sockets, <span class=\"string\">'errors'</span>, stats.errors);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (stats.warnings.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.sockWrite(sockets, <span class=\"string\">'warnings'</span>, stats.warnings);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.sockWrite(sockets, <span class=\"string\">'ok'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这部分代码稍长，主逻辑都在构造函数里。在构造函数中进行参数校验，参数缺省值处理，注入客户端代码，绑定 webpack compiler 钩子，这里主要关注是 done 钩子，(在 webpack compiler 实例每次触发编译完成后就会进行 webscoket 广播 webpack 的编译信息)。实例化 express 服务器，添加 webpack-dev-middleware 中间件用于处理静态资源的请求，然后初始化 HTTP 服务器。我们在上面的 webpack-dev-server.js 中调用的 listen 方法就是开始监听配置的端口，监听回调里再初始化 websocket 的服务端。<br>代码执行到这已经完成了服务器端所有的逻辑，但是 webpack 还没有启动编译，用户打开浏览器后请求设置的IP和端口又是怎么处理的呢。那这个部分暂时被我们略过了，这部分就是 webpack-dev-middleware 处理的内容了。</p>\n<h2 id=\"webapck-dev-middleware-初始化\"><a href=\"#webapck-dev-middleware-初始化\" class=\"headerlink\" title=\"webapck-dev-middleware 初始化\"></a>webapck-dev-middleware 初始化</h2><p>webapck-dev-middleware 作为一个独立的模块，以下是它的目录结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── README.md</span><br><span class=\"line\">├── index.js</span><br><span class=\"line\">├── lib</span><br><span class=\"line\">│   ├── DevMiddlewareError.js</span><br><span class=\"line\">│   ├── context.js</span><br><span class=\"line\">│   ├── fs.js</span><br><span class=\"line\">│   ├── middleware.js</span><br><span class=\"line\">│   ├── reporter.js</span><br><span class=\"line\">│   └── util.js</span><br><span class=\"line\">└── package.json</span><br></pre></td></tr></table></figure>\n<p>webapck-dev-middleware 初始化执行</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack-dev-middleware/index.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wdm</span>(<span class=\"params\">compiler, opts</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> options = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, defaults, opts);</span><br><span class=\"line\">  <span class=\"comment\">// 1. 初始化 context</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> context = createContext(compiler, options);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// start watching</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!options.lazy) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2. 启动 webpack 编译</span></span><br><span class=\"line\">    context.watching = compiler.watch(options.watchOptions, (err) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">        context.log.error(err.stack || err);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err.details) &#123;</span><br><span class=\"line\">          context.log.error(err.details);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// lazy 模式是请求过来一次才webpack编译一次, 这里不关注</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 3. 替换 webpack 默认的 outputFileSystem 为 memory-fs, 存取都在内存上操作</span></span><br><span class=\"line\">  <span class=\"comment\">// fileSystem = new MemoryFileSystem();</span></span><br><span class=\"line\">  <span class=\"comment\">// compiler.outputFileSystem = fileSystem;</span></span><br><span class=\"line\">  setFs(context, compiler);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 3. 执行 middleware 函数返回真正的 middleware</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> middleware(context);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>wdm 函数返回结果是 express 标准的 middleware 用于处理浏览器静态资源的请求。执行过程中显示初始化了一个 context 对象，默认不是 lazy 模式的情况下，开启了 webpack 的 watch 模式开始启动编译。 然后将 compiler 的原来基于 fs 模块的 outputFileSystem 替换成 <a href=\"https://www.npmjs.com/package/memory-fs\" target=\"_blank\" rel=\"noopener\">memory-fs</a>模块的实例。memory-fs 是实现了 node fs api 的基于内存的 fileSystem，这意味着 webpack 编译后的资源不会被输出到硬盘而是内存。最后将真正处理请求的 middleware 返回装载在 express 上。</p>\n<h2 id=\"webapck-dev-middleware-处理请求\"><a href=\"#webapck-dev-middleware-处理请求\" class=\"headerlink\" title=\"webapck-dev-middleware 处理请求\"></a>webapck-dev-middleware 处理请求</h2><p>当用户在浏览器打开配置的IP和端口，如 <a href=\"https://localhost:8080，请求就会被\" target=\"_blank\" rel=\"noopener\">https://localhost:8080，请求就会被</a> middleware 处理。middleware 从内存中读到请求的资源就返回给客户端。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack-dev-middleware/lib/middleware.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wrapper</span>(<span class=\"params\">context</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">middleware</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 根据请求的 URL 地址，得到绝对路径的 webpack 输出的资源路径地址</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> filename = getFilenameFromUrl(</span><br><span class=\"line\">      context.options.publicPath,</span><br><span class=\"line\">      context.compiler,</span><br><span class=\"line\">      req.url</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      handleRequest(context, filename, processRequest, req);</span><br><span class=\"line\">      <span class=\"comment\">// eslint-disable-next-line consistent-return</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">processRequest</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 2.从内存读取到资源内容</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> content = context.fs.readFileSync(filename);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 3. 返回给客户端</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (res.send) &#123;</span><br><span class=\"line\">          res.send(content);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          res.end(content);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        resolve();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"webscoket-通信\"><a href=\"#webscoket-通信\" class=\"headerlink\" title=\"webscoket 通信\"></a>webscoket 通信</h2><p>当我们编辑了源代码，触发 webpack 重新编译，编译完成后执行 done 钩子上的回调。具体可参考上面 Server.js 中 setupHooks 方法。_sendStats 方法会先广播一个类型为 hash 的消息，然后再根据编译信息广播 warnings/errors/ok 消息。这里我们只关注正常流程 ok 消息。</p>\n<p>我们已经很熟悉客户端接收到更新后都会对应用进行 Reload 来获取更好的开发体验。具体是 liveReload（刷新整个页面）还是 hotReload（更新改动过的模块）就取决于我们的 hot 选项。</p>\n<p>这些代码我们在上面就讲到过是在 webpack 编译的时候注入到 bundle.js 进去的。当用户打开页面预览时，这些代码就会自动执行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack-dev-server/client/index.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> onSocketMessage = &#123;</span><br><span class=\"line\">  hot: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hot</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    options.hot = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    log.info(<span class=\"string\">'[WDS] Hot Module Replacement enabled.'</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  liveReload: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">liveReload</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    options.liveReload = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    log.info(<span class=\"string\">'[WDS] Live Reloading enabled.'</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  hash: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hash</span>(<span class=\"params\">_hash</span>) </span>&#123;</span><br><span class=\"line\">    status.currentHash = _hash;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  ok: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ok</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (options.initial) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> options.initial = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125; <span class=\"comment\">// eslint-disable-line no-return-assign</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    reloadApp(options, status);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">socket(socketUrl, onSocketMessage);</span><br></pre></td></tr></table></figure>\n<p>client/index.js 主要就是初始化了 webscoket 客户端，然后为不同的消息类型设置了相应的回调函数。</p>\n<p>在前面 Server.js 中我们看到如果 hot 选项为 true 时，当 websocket 客户端连接到服务端，服务端会先广播一个 hot 类型的消息，客户端接收到后会把 options 对象的 hot 设置为 true。<br>服务端在每次编译后都会广播 hash 消息，客户端接收到后就会将这个webpack 编译产生的 hash 值暂存起来。编译成功如果没有 warning 也没有 error 就会广播 ok 消息，客户端接收到 ok 消息就会执行 ok 回调函数中的 reloadApp 刷新应用。</p>\n<h2 id=\"webscoket-消息处理\"><a href=\"#webscoket-消息处理\" class=\"headerlink\" title=\"webscoket 消息处理\"></a>webscoket 消息处理</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack-dev-server/client/utils/reloadApp.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reloadApp</span>(<span class=\"params\">_ref, _ref2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> hotReload = _ref.hotReload,</span><br><span class=\"line\">      hot = _ref.hot,</span><br><span class=\"line\">      liveReload = _ref.liveReload,</span><br><span class=\"line\">      currentHash = _ref2.currentHash;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (hot) &#123;</span><br><span class=\"line\">    log.info(<span class=\"string\">'[WDS] App hot update...'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> hotEmitter = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack/hot/emitter'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    hotEmitter.emit(<span class=\"string\">'webpackHotUpdate'</span>, currentHash);</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (liveReload) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> rootWindow = self; <span class=\"comment\">// use parent window for reload (in case we're in an iframe with no valid src)</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">var</span> intervalId = self.setInterval(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rootWindow.location.protocol !== <span class=\"string\">'about:'</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// reload immediately if protocol is valid</span></span><br><span class=\"line\">          applyReload(rootWindow, intervalId);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          rootWindow = rootWindow.parent;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (rootWindow.parent === rootWindow) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// if parent equals current window we've reached the root which would continue forever, so trigger a reload anyways</span></span><br><span class=\"line\">            applyReload(rootWindow, intervalId);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">applyReload</span>(<span class=\"params\">rootWindow, intervalId</span>) </span>&#123;</span><br><span class=\"line\">    clearInterval(intervalId);</span><br><span class=\"line\">    log.info(<span class=\"string\">'[WDS] App updated. Reloading...'</span>);</span><br><span class=\"line\">    rootWindow.location.reload();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Hot-Module-Replacement\"><a href=\"#Hot-Module-Replacement\" class=\"headerlink\" title=\"Hot Module Replacement\"></a>Hot Module Replacement</h2><h3 id=\"触发-hot-check\"><a href=\"#触发-hot-check\" class=\"headerlink\" title=\"触发 hot check\"></a>触发 hot check</h3><p>如果设置了 hot: true 客户端就会引入 webpack/hot/emitter，触发一个 webpackHotUpdate 事件，将 hash 值传递过去。这个 <code>webpack/hot/emitter</code> 我们查阅 webpack 源码看到其实就是 node 的 events 模块。我们暂时不关注这个事件会触发什么回调后面再具体再看。如果没有设置 hot: true。那么就是使用 liveReload 模式，liveReload 就比较无脑，直接刷新整个页面。</p>\n<p>再回到上一个问题，到底是在哪里接收 webpackHotUpdate 事件并处理的呢？就是 webpack/hot/dev-server.js 中处理的。在这里会去检查是否可以更新，如果更新失败就会刷新整个页面来降级实现代码更新的功能。其实我们回过头来看看这样降级也是必须的，如果更新失败，源码更新了，而客户端的代码却没更新，这样显示是不合理的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> lastHash;</span><br><span class=\"line\"><span class=\"keyword\">var</span> upToDate = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upToDate</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> lastHash.indexOf(__webpack_hash__) &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> log = <span class=\"built_in\">require</span>(<span class=\"string\">\"./log\"</span>);</span><br><span class=\"line\">   <span class=\"comment\">// 2. 检查更新</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> check = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">check</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 3. 具体的检查逻辑</span></span><br><span class=\"line\">\t<span class=\"built_in\">module</span>.hot</span><br><span class=\"line\">\t\t.check(<span class=\"literal\">true</span>)</span><br><span class=\"line\">\t\t.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">updatedModules</span>) </span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">// 3.1 更新成功</span></span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t\t.catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> status = <span class=\"built_in\">module</span>.hot.status();</span><br><span class=\"line\">       <span class=\"comment\">// 3.2 更新失败，降级为重新刷新整个应用</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ([<span class=\"string\">\"abort\"</span>, <span class=\"string\">\"fail\"</span>].indexOf(status) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\tlog(</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">\"warning\"</span>,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">\"[HMR] Cannot apply update. Need to do a full reload!\"</span></span><br><span class=\"line\">\t\t\t\t);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">window</span>.location.reload();</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tlog(<span class=\"string\">\"warning\"</span>, <span class=\"string\">\"[HMR] Update failed: \"</span> + log.formatError(err));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> hotEmitter = <span class=\"built_in\">require</span>(<span class=\"string\">\"./emitter\"</span>);</span><br><span class=\"line\"> <span class=\"comment\">// 1. 注册事件回调</span></span><br><span class=\"line\">hotEmitter.on(<span class=\"string\">\"webpackHotUpdate\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">currentHash</span>) </span>&#123;</span><br><span class=\"line\">\tlastHash = currentHash;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!upToDate() &amp;&amp; <span class=\"built_in\">module</span>.hot.status() === <span class=\"string\">\"idle\"</span>) &#123;</span><br><span class=\"line\">\t\tlog(<span class=\"string\">\"info\"</span>, <span class=\"string\">\"[HMR] Checking for updates on the server...\"</span>);</span><br><span class=\"line\">\t\tcheck();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"模块更新依赖判断\"><a href=\"#模块更新依赖判断\" class=\"headerlink\" title=\"模块更新依赖判断\"></a>模块更新依赖判断</h3><p>module.hot.check 方法位于 webpack/lib/HotModuleReplacement.runtime.js 中，是 webpack 内置的 HotModuleReplacementPlugin 注入在 webpack bootstrap runtime 中的。</p>\n<p>所以 check 方法主要做了什么呢，这里提前总结一下。在 webpack 使用了 HotModuleReplacementPlugin 编译时，每次增量编译就会多产出两个文件，形如<code>c390bbe0037a0dd079a6.hot-update.json</code>，<code>main.c390bbe0037a0dd079a6.hot-update.js</code>，分别是描述 chunk 更新的 manifest文件和更新过后的 chunk 文件。那么浏览器端调用 hotDownloadManifest 去下载模块更新的 manifest.json 文件，然后使用 hotDownloadUpdateChunk 使用 jsonp 的方式下载需要更新的 chunk。hotDownloadUpdateChunk 下载完成后调用 webpackHotUpdate 回调。回调内拿到更新的模块，然后从模块自身开始进行冒泡，如果发现<strong>只要有一条</strong>祖先路径没有 accept 这次改动就直接刷新页面实行降级强制更新, 如果有被 accept, 就会替换掉原来 webpack runtime 里 module 里旧的模块，然后再执行 accept 的 callback 进行更新。为什么要执行这样的判断呢？</p>\n<p>假设给定这样的依赖路径</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentA.js -&gt; componentB.js -&gt; app.js -&gt; index.js</span><br><span class=\"line\">componentA.js -&gt; componentC.js -&gt; app.js -&gt; index.js</span><br></pre></td></tr></table></figure>\n<p>accept 指该 module 的祖先模块调用了 module.hot.accept 处理了该 module 更新过后的业务逻辑，一般都是 rerender。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"built_in\">module</span>.hot) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">module</span>.hot.accept(<span class=\"string\">'./app'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        rerender()</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果我们对 componentA.js 进行了更改，但是如果仅仅 componentB accept 了更改，componentC 却没 accept，那么这样是没有到达更新的目的的。所以在祖先路径回溯的时候，要保证每一条路径都被 accept。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hotCheck</span>(<span class=\"params\">apply</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 1. 拿这次编译后的 hash 请求服务器，拿到结构为 &#123;c: &#123;main: true&#125; h: \"ac69ee760bb48d5db5f5\"&#125; 的数据</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> hotDownloadManifest(hotRequestTimeout).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">update</span>) </span>&#123;</span><br><span class=\"line\">    hotAvailableFilesMap = update.c;</span><br><span class=\"line\">    hotUpdateNewHash = update.h;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2. 生成一个 defered promise，供上面提到的 promise 链消费</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">      hotDeferred = &#123;</span><br><span class=\"line\">        resolve: resolve,</span><br><span class=\"line\">        reject: reject</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    hotUpdate = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 3. 这个方法里面调用的就是 hotDownloadUpdateChunk，就是发起一个 jsonp 请求更新过后的 chunk，jsonp的回调是 HMR runtime 里的 webpackHotUpdate</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      hotEnsureUpdateChunk(chunkId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> promise;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>hotCheck 方法就是和服务器进行通信拿到更新过后的 chunk，下载好 chunk 后就开始执行 HMR runtime 里的 webpackHotUpdate 回调。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>[<span class=\"string\">\"webpackHotUpdate\"</span>] = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">webpackHotUpdateCallback</span>(<span class=\"params\">chunkId, moreModules</span>) </span>&#123;</span><br><span class=\"line\">\thotAddUpdateChunk(chunkId, moreModules);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);</span><br><span class=\"line\">&#125; ;</span><br></pre></td></tr></table></figure>\n<p>经过一系列方法调用然后来到 hotApplyInternal 方法，这个方法把更新过后的模块 apply 到业务中，整个方法比较长，就不完整贴出来了。这里拿出核心的部分，</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> id <span class=\"keyword\">in</span> hotUpdate) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(hotUpdate, id)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> result;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hotUpdate[id]) &#123;</span><br><span class=\"line\">            result = getAffectedStuff(moduleId);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            result = &#123;</span><br><span class=\"line\">                type: <span class=\"string\">\"disposed\"</span>,</span><br><span class=\"line\">                moduleId: id</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (result.type) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">\"self-declined\"</span>:</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">\"declined\"</span>:</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">\"unaccepted\"</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (options.onUnaccepted) options.onUnaccepted(result);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!options.ignoreUnaccepted)</span><br><span class=\"line\">                    abortError = <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">                        <span class=\"string\">\"Aborted because \"</span> + moduleId + <span class=\"string\">\" is not accepted\"</span> + chainInfo</span><br><span class=\"line\">                    );</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">\"accepted\"</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (options.onAccepted) options.onAccepted(result);</span><br><span class=\"line\">                doApply = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">\"disposed\"</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"Unexception type \"</span> + result.type);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>把更新过的模块进行遍历，找到被该模块影响到的祖先模块，返回一个结果，如果结果标识为 unaccepted 就会被抛出错误，然后走到 webpack/hot/dev-server.js 里的 catch 进行页面级刷新。如果被 accept 的话就会执行后面的 apply 的逻辑。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getAffectedStuff</span>(<span class=\"params\">updateModuleId</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> outdatedModules = [updateModuleId];</span><br><span class=\"line\">  <span class=\"keyword\">var</span> outdatedDependencies = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> queue = outdatedModules.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      chain: [id],</span><br><span class=\"line\">      id: id</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"comment\">// 1. 遍历 queue</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (queue.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> queueItem = queue.pop();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> moduleId = queueItem.id;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> chain = queueItem.chain;</span><br><span class=\"line\">    <span class=\"comment\">// 2. 找到改模块的旧版本</span></span><br><span class=\"line\">    <span class=\"built_in\">module</span> = installedModules[moduleId];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 3. 如果到根模块了，返回 unaccepted</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">module</span>.hot._main) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        type: <span class=\"string\">\"unaccepted\"</span>,</span><br><span class=\"line\">        chain: chain,</span><br><span class=\"line\">        moduleId: moduleId</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 4. 遍历父模块</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">module</span>.parents.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> parentId = <span class=\"built_in\">module</span>.parents[i];</span><br><span class=\"line\">      <span class=\"keyword\">var</span> parent = installedModules[parentId];</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">// 5. 如果父模块处理了模块变更的话就跳过，继续检查</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (parent.hot._acceptedDependencies[moduleId]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      outdatedModules.push(parentId);</span><br><span class=\"line\">      <span class=\"comment\">// 6. 没跳过的话推入队列，继续检查</span></span><br><span class=\"line\">      queue.push(&#123;</span><br><span class=\"line\">        chain: chain.concat([parentId]),</span><br><span class=\"line\">        id: parentId</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 7.如果所有依赖路径都有被 accept 就返回 accepted</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type: <span class=\"string\">\"accepted\"</span>,</span><br><span class=\"line\">    moduleId: updateModuleId,</span><br><span class=\"line\">    outdatedModules: outdatedModules,</span><br><span class=\"line\">    outdatedDependencies: outdatedDependencies</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"module-apply\"><a href=\"#module-apply\" class=\"headerlink\" title=\"module apply\"></a>module apply</h3><p>看过 webpack runtime 代码的应该知道 runtime 里声明了 installedModules 这个变量，里面缓存了所有被 <strong>webpack_require</strong> 调用后加载过的模块，还有 modules 这个变量存储了所有模块，为了理解下面模块替换的部分可以先去看下 webpack runtime 代码的执行机制。如果模块有被 accept 的话，那么就会从 installedModules 里删掉旧的模块，把模块从父子依赖中删除，然后把 modules 里面的模块替换成新的模块。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// remove module from cache</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> installedModules[moduleId];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// insert new code</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (moduleId <span class=\"keyword\">in</span> appliedUpdate) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) &#123;</span><br><span class=\"line\">        modules[moduleId] = appliedUpdate[moduleId];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样仅仅完成了模块的替换，还没有执行过新模块代码，也就是没被 <strong>webpack_require</strong> 调用过。新模块代码的执行是在 accept 函数的的 callback 里被 webpack 自动插入代码执行的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"built_in\">module</span>.hot) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">module</span>.hot.accept(<span class=\"string\">'./App'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'accepted'</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>会被 webpack 改造为</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">module</span>.hot.accept(<span class=\"string\">\"./src/App.js\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">__WEBPACK_OUTDATED_DEPENDENCIES__</span>) </span>&#123; </span><br><span class=\"line\">      _App__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(<span class=\"string\">\"./src/App.js\"</span>);</span><br><span class=\"line\">      (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'accepted'</span>)</span><br><span class=\"line\">      &#125;)(__WEBPACK_OUTDATED_DEPENDENCIES__); </span><br><span class=\"line\">    &#125;.bind(<span class=\"keyword\">this</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以新模块的代码是在 accept 方法回调执行之前被执行的。引入了新代码后就可以执行我们的业务代码，这些业务代码一般都和框架相关，框架去处理模块的热更新逻辑。比如 react-hot-loader, vue-loader 。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>最后总结一下，webpack-dev-server 可以作为命令行工具使用，核心模块依赖是 webpack 和 webpack-dev-middleware。webapck-dev-server 负责启动一个 express 服务器监听客户端请求；实例化 webpack compiler；启动负责推送 webpack 编译信息的 webscoket 服务器；负责向 bundle.js 注入和服务端通信用的 webscoket 客户端代码和处理逻辑。webapck-dev-middleware 把 webpack compiler 的 outputFileSystem 改为 in-memory fileSystem；启动 webpack watch 编译；处理浏览器发出的静态资源的请求，把 webpack 输出到内存的文件响应给浏览器。</p>\n<p>每次 webpack 编译完成后向客户端广播 ok 消息，客户端收到信息后根据是否开启 hot 模式使用 liveReload 页面级刷新模式或者 hotReload 模块热替换。hotReload 存在失败的情况，失败的情况下会降级使用页面级刷新。</p>\n<p>开启 hot 模式，即启用 HMR 插件。hot 模式会向服务器请求更新过后的模块，然后对模块的父模块进行回溯，对依赖路径进行判断，如果每条依赖路径都配置了模块更新后所需的业务处理回到函数则是 accepted 状态，否则就降级刷新页面。判断 accepted 状态后对旧的缓存模块和父子依赖模块进行替换和删除，然后执行 accept 方法的回调函数，执行新模块代码，引入新模块，执行业务处理代码。</p>\n<p>想要更加熟悉完整的运行流程还是需要自己打开浏览器，断点调试。</p>\n"},{"title":"Koa 原理","date":"2020-10-16T09:11:15.000Z","_content":"\n\nKoa 作为 node.js 的下一代 web framework 和它的前辈 express.js 相比有什么不一样？\n\n从 [官方文档](https://github.com/koajs/koa/blob/master/docs/koa-vs-express.md) 可以看出它的主要特点或者说和 express.js 的区别主要是\n\n1. 精简\n2. 使用 async\n\nkoa 只实现了中间件内核，没有 express.js 的重要功能 -- 路由，也更没有模板渲染，jsonp等等特性，这些功能都通过三方中间件来实现。所以它可以被看成 node.js 的 http 模块的抽象，而 express.js 则是一个应用框架。\n\nkoa 不使用传统的 node.js callback 编码风格，而是拥抱了 async/await。当然 express.js 也是可以使用 async/await，只不过 koa 使用 async/await 能够实现 [洋葱圈模型](https://eggjs.org/zh-cn/intro/egg-and-koa.html#middleware) 和更好的 [异常处理](https://itnext.io/from-express-to-koa-f3be4afdfd39)。\n\n\n## API\n\n首先看看 koa 是如何使用的？\n\n```js\nconst Koa = require('koa');\nconst app = new Koa();\n\n// logger\n\napp.use(async (ctx, next) => {\n  await next();\n  const rt = ctx.response.get('X-Response-Time');\n  console.log(`${ctx.method} ${ctx.url} - ${rt}`);\n});\n\n// x-response-time\n\napp.use(async (ctx, next) => {\n  const start = Date.now();\n  await next();\n  const ms = Date.now() - start;\n  ctx.set('X-Response-Time', `${ms}ms`);\n});\n\n// response\n\napp.use(async ctx => {\n  ctx.body = 'Hello World';\n});\n\napp.listen(3000);\n```\n\nkoa app 的实例化和 express 的工厂模式不同，它通过 new 关键字来实例化。\n\n`use` 方法继承了 express.js 的命名风格，在这个示例里声明了三个中间件。但是这里 `use` 的入参和 express 的 `use` 方法有不同，koa 这里只接收一个入参，就是中间件函数。\n\n中间件函数的签名是 `(context: Koa.Context, next: Koa.Next) => any;`，那么这里又有两个非常重要的概念，`context` 和 `next()`，`context` 是单次请求的上下文对象，在每次请求时会被创建；`next` 方法是 Koa 实现洋葱圈模型的关键。\n\n`listen` 方法同 express.js 的 `listen` 方法一样，开启了监听端口。\n\n## 目录结构\n\n> 版本：Koa v2.13.0\n\n![cloc koa/lib](https://img10.360buyimg.com/jdphoto/jfs/t1/127096/30/18199/6516/5faa98eaEd5e002ab/f40c762d5fdd23f8.png)\n\n\nKoa 的源代码（不包括依赖）只有大概700行，相比于 express.js 少了大概 1000 行。\n\n\n```sh\nlib\n├── application.js\n├── context.js\n├── request.js\n└── response.js\n```\n\nkoa 的代码被划分为以上四个文件:\n\napplication.js 导出的是 Koa Application 类\ncontext.js 是 context 对象的原型\nrequest.js 和 response.js 分别是 context.request 和 context.response 对象的原型\n\n## use \n![koa structue](https://img10.360buyimg.com/jdphoto/jfs/t1/143072/10/15096/11183/5fb618ccE295c7533/604bf4ee66b82557.png)\n\nKoa 框架的核心在于它实现了一套好用的中间件机制。Koa 的中间件是一个签名为 `(context: Koa.Context, next: Koa.Next) => any;` 的函数，Koa 实例的 `use` 方法用于注册中间件。Koa 实例上维护了一个名为 `middleware` 的队列，用于存储所有的中间件函数。`use` 方法的实现非常简单，以下是精简过的代码：\n\n```js\n  use(fn) {\n    this.middleware.push(fn);\n    return this;\n  }\n```\n\n`use` 方法将中间件函数推入队列中，返回 `this`，这让 `use` 可以链式调用。\n\n完成了中间件的注册之后，我们就要创建 http 服务器，开启端口监听。koa 实例的 `listen` 方法就是这个作用，它是怎么实现的呢？\n\n\n## listen\nKoa 是基于 node.js 网络模块封装出来的框架。在上面的示例中在初始化 koa 实例后，就调用了 `listen` 方法在 3000 端口开始监听请求。它的实现是：\n\n```js\nlisten(...args) {\n    const server = http.createServer(this.callback());\n    return server.listen(...args);\n}\n```\n\n通过查阅 [node.js 文档](https://nodejs.org/api/http.html#http_http_createserver_options_requestlistener) 我们会知道调用`http.createServer` 方法之后会返回一个 `Server` 实例，且这个方法的入参就是一个签名为 `(req: IncomingMessage, res: ServerResponse) => void` 的 `request handler`，这个函数会在 Server 实例每次接收到 [`request` 事件](https://nodejs.org/api/http.html#http_event_request)（即请求进入）时被调用。\n\n从源码看到 Koa 框架使用的 `request handler` 就是 `this.callback()` 的返回值。所以当请求进入的时候，Koa 是如何应战的？\n\n## callback\n\n```js\nconst compose = require('koa-compose');\n\nclass Application {\n  callback() {\n    const fn = compose(this.middleware);\n\n    if (!this.listenerCount('error')) this.on('error', this.onerror);\n\n    const handleRequest = (req, res) => {\n      const ctx = this.createContext(req, res);\n      return this.handleRequest(ctx, fn);\n    };\n\n    return handleRequest;\n  }\n\n  /**\n   * Handle request in callback.\n   *\n   * @api private\n   */\n\n  handleRequest(ctx, fnMiddleware) {\n    const res = ctx.res;\n    res.statusCode = 404;\n    const onerror = err => ctx.onerror(err);\n    const handleResponse = () => respond(ctx);\n    onFinished(res, onerror);\n    return fnMiddleware(ctx).then(handleResponse).catch(onerror);\n  }\n\n  ...\n}\n```\n\n`callback` 首先把 middleware 传给了 koa-compose 模块，返回了一个函数 `fn`。\n\n接着 `callback` 内声明了一个 `handleRequest` 函数并将其返回。所以最终 node.js `request` 事件触发的时候调用的就是这个 `handleRequest`。\n\n当请求进入，`handleRequest` 被调用。被调用时它创建了一个 `context` 对象，关于 `context` 对象我们暂时略过，先走完中间件的执行流程。接着就把上面得到的 `fn` 和 `ctx` 传递给**实例方法** `handleRequest` 执行。\n\n实例方法 `handleRequest` 中实际的代码就是执行了 koa-compose 得到的函数 `fnMiddleware`。\n\n可以看出这是一个 promsise 链，当 `fnMiddleware` 返回的 `promise` 变更为 resolved 状态时，就调用 `handleResponse`这个闭包函数，其内的 `respond` 方法持有对 `ctx` 的引用。其作用就是经过中间件处理后响应客户端；当 `promise` 变更为 rejected 状态时，就会使用 `ctx.onerror` 方法响应给客户端，这个主要是 Koa 框架提供的兜底异常处理。一般业务中我们都会定义自己的异常处理函数。\n\n所以中间件具体是怎么执行的，这就需要查看 koa-compose 模块的执行逻辑。\n\n\n### koa-compose\n\n```js\n/**\n * Compose `middleware` returning\n * a fully valid middleware comprised\n * of all those which are passed.\n *\n * @param {Array} middleware\n * @return {Function}\n * @api public\n */\nfunction compose (middleware) {\n  if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!')\n  for (const fn of middleware) {\n    if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!')\n  }\n\n  /**\n   * @param {Object} context\n   * @return {Promise}\n   * @api public\n   */\n\n  return function (context, next) {\n    // last called middleware #\n    let index = -1\n    return dispatch(0)\n    function dispatch (i) {\n      if (i <= index) return Promise.reject(new Error('next() called multiple times'))\n      index = i\n      let fn = middleware[i]\n      if (i === middleware.length) fn = next\n      if (!fn) return Promise.resolve()\n      try {\n        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));\n      } catch (err) {\n        return Promise.reject(err)\n      }\n    }\n  }\n}\n```\n\n当我们在上面的 `handleRequest` 中调用 `fnMiddleware` 时最终执行的是 `dispatch(0)`，上面 promise 链的起点也就是这个方法的返回值。\n\n我们先跳过 dispatch 函数声明的第二行和第三行。从第四行开始阅读，以 i 为下标取 middleware 队列中的中间件函数，还记得中间件的签名是 `(context: Koa.Context, next: Koa.Next) => any;`，在这里将作用域里的 context 和 bind 过后且参数为 i+1 的 dispatch 函数作为 next 传给中间件执行。\n\n假设有如下两个中间件\n\n```js\napp.use(async function middleware1(context, next) {\n  console.log('before 1')\n  await next()\n  console.log('after 1')\n})\n\napp.use(async function middleware2(context, next) {\n  console.log('before 2')\n  await next()\n  console.log('after ')\n})\n```\n\n经过 Koa 的编排，那么他们的执行逻辑等同于\n\n```js\n\nasync function middleware1(context, next) {\n  console.log('before 1')\n  await Promise.resolve(async function(context, next) {\n    console.log('before 2')\n    await next()\n    console.log('after 2')\n  }(context, () => Promise.resolve()))\n  console.log('after 1')\n}\n\nmiddleware1({}, undefined)\n```\n\n中间件的嵌套执行实现了 Koa 的洋葱圈模型。\n\n最后一个值得注意的点是，闭包里维护了一个 index，这是防止 `next` 方法在一个中间件中被多次执行，多次执行就会导致中间件的执行顺序不是串行的而是并行的导致混乱。\n\n\n## context\n在上面我们看到每次请求进入都会调用 createContext 来创建一个上下文对象 context，并将其传给了中间件链条。\n\n```js\n  createContext(req, res) {\n    const context = Object.create(this.context);\n    const request = context.request = Object.create(this.request);\n    const response = context.response = Object.create(this.response);\n    context.app = request.app = response.app = this;\n    context.req = request.req = response.req = req;\n    context.res = request.res = response.res = res;\n    request.ctx = response.ctx = context;\n    request.response = response;\n    response.request = request;\n    context.originalUrl = request.originalUrl = req.url;\n    context.state = {};\n    return context;\n  }\n```\n\ncontext 是一个原型为 `this.context` 的新对象。而 `this.context` 又是以 `context.js` 下声明的原型对象为原型的对象。\n\ncontext.app 为 Koa 实例；context.req 是 Node.js IncomingMessage 的实例；context.res 是 Node.js ServerResponse 的实例；context.request 是 Koa 扩展过 IncomingMessage 后的实例；context.request 是 Koa 扩展过 ServerResponse 后的实例；\n\ncontext 如下大量代理了它的 Koa response (非 Node.js req)和 Koa request (非 Node.js res)上的方法和属性。这就是为什么我们可以使用诸如 `ctx.body = { data: {}}` 的原因。\n\n```js\ndelegate(proto, 'response')\n  .method('attachment')\n  .method('redirect')\n  .method('remove')\n  .method('vary')\n  .method('has')\n  .method('set')\n  .method('append')\n  .method('flushHeaders')\n  .access('status')\n  .access('message')\n  .access('body')\n  .access('length')\n  .access('type')\n  .access('lastModified')\n  .access('etag')\n  .getter('headerSent')\n  .getter('writable');\n\n/**\n * Request delegation.\n */\n\ndelegate(proto, 'request')\n  .method('acceptsLanguages')\n  .method('acceptsEncodings')\n  .method('acceptsCharsets')\n  .method('accepts')\n  .method('get')\n  .method('is')\n  .access('querystring')\n  .access('idempotent')\n  .access('socket')\n  .access('search')\n  .access('method')\n  .access('query')\n  .access('path')\n  .access('url')\n  .access('accept')\n  .getter('origin')\n  .getter('href')\n  .getter('subdomains')\n  .getter('protocol')\n  .getter('host')\n  .getter('hostname')\n  .getter('URL')\n  .getter('header')\n  .getter('headers')\n  .getter('secure')\n  .getter('stale')\n  .getter('fresh')\n  .getter('ips')\n  .getter('ip');\n```\n\n## Request & Response\nrequest.js 和 response.js 分别声明了上面 context.request 和 context.response 对象的原型。\n\n在这些原型上声明了很多语法糖方法。比如 `ctx.status = 200` 和  `const status = ctx.status` 都是我们上面所说的 ctx 对 response 对象的代理。而 `response[set status]` 和 `response[get status]` 实现如下\n\n```js\n  /**\n   * Get response status code.\n   *\n   * @return {Number}\n   * @api public\n   */\n\n  get status() {\n    return this.res.statusCode;\n  },\n\n  /**\n   * Set response status code.\n   *\n   * @param {Number} code\n   * @api public\n   */\n\n  set status(code) {\n    if (this.headerSent) return;\n\n    assert(Number.isInteger(code), 'status code must be a number');\n    assert(code >= 100 && code <= 999, `invalid status code: ${code}`);\n    this._explicitStatus = true;\n    this.res.statusCode = code;\n    if (this.req.httpVersionMajor < 2) this.res.statusMessage = statuses[code];\n    if (this.body && statuses.empty[code]) this.body = null;\n  },\n```\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/how-koa.md","raw":"---\ntitle: Koa 原理\ndate: 2020-10-16 17:11:15\ntags:\n---\n\n\nKoa 作为 node.js 的下一代 web framework 和它的前辈 express.js 相比有什么不一样？\n\n从 [官方文档](https://github.com/koajs/koa/blob/master/docs/koa-vs-express.md) 可以看出它的主要特点或者说和 express.js 的区别主要是\n\n1. 精简\n2. 使用 async\n\nkoa 只实现了中间件内核，没有 express.js 的重要功能 -- 路由，也更没有模板渲染，jsonp等等特性，这些功能都通过三方中间件来实现。所以它可以被看成 node.js 的 http 模块的抽象，而 express.js 则是一个应用框架。\n\nkoa 不使用传统的 node.js callback 编码风格，而是拥抱了 async/await。当然 express.js 也是可以使用 async/await，只不过 koa 使用 async/await 能够实现 [洋葱圈模型](https://eggjs.org/zh-cn/intro/egg-and-koa.html#middleware) 和更好的 [异常处理](https://itnext.io/from-express-to-koa-f3be4afdfd39)。\n\n\n## API\n\n首先看看 koa 是如何使用的？\n\n```js\nconst Koa = require('koa');\nconst app = new Koa();\n\n// logger\n\napp.use(async (ctx, next) => {\n  await next();\n  const rt = ctx.response.get('X-Response-Time');\n  console.log(`${ctx.method} ${ctx.url} - ${rt}`);\n});\n\n// x-response-time\n\napp.use(async (ctx, next) => {\n  const start = Date.now();\n  await next();\n  const ms = Date.now() - start;\n  ctx.set('X-Response-Time', `${ms}ms`);\n});\n\n// response\n\napp.use(async ctx => {\n  ctx.body = 'Hello World';\n});\n\napp.listen(3000);\n```\n\nkoa app 的实例化和 express 的工厂模式不同，它通过 new 关键字来实例化。\n\n`use` 方法继承了 express.js 的命名风格，在这个示例里声明了三个中间件。但是这里 `use` 的入参和 express 的 `use` 方法有不同，koa 这里只接收一个入参，就是中间件函数。\n\n中间件函数的签名是 `(context: Koa.Context, next: Koa.Next) => any;`，那么这里又有两个非常重要的概念，`context` 和 `next()`，`context` 是单次请求的上下文对象，在每次请求时会被创建；`next` 方法是 Koa 实现洋葱圈模型的关键。\n\n`listen` 方法同 express.js 的 `listen` 方法一样，开启了监听端口。\n\n## 目录结构\n\n> 版本：Koa v2.13.0\n\n![cloc koa/lib](https://img10.360buyimg.com/jdphoto/jfs/t1/127096/30/18199/6516/5faa98eaEd5e002ab/f40c762d5fdd23f8.png)\n\n\nKoa 的源代码（不包括依赖）只有大概700行，相比于 express.js 少了大概 1000 行。\n\n\n```sh\nlib\n├── application.js\n├── context.js\n├── request.js\n└── response.js\n```\n\nkoa 的代码被划分为以上四个文件:\n\napplication.js 导出的是 Koa Application 类\ncontext.js 是 context 对象的原型\nrequest.js 和 response.js 分别是 context.request 和 context.response 对象的原型\n\n## use \n![koa structue](https://img10.360buyimg.com/jdphoto/jfs/t1/143072/10/15096/11183/5fb618ccE295c7533/604bf4ee66b82557.png)\n\nKoa 框架的核心在于它实现了一套好用的中间件机制。Koa 的中间件是一个签名为 `(context: Koa.Context, next: Koa.Next) => any;` 的函数，Koa 实例的 `use` 方法用于注册中间件。Koa 实例上维护了一个名为 `middleware` 的队列，用于存储所有的中间件函数。`use` 方法的实现非常简单，以下是精简过的代码：\n\n```js\n  use(fn) {\n    this.middleware.push(fn);\n    return this;\n  }\n```\n\n`use` 方法将中间件函数推入队列中，返回 `this`，这让 `use` 可以链式调用。\n\n完成了中间件的注册之后，我们就要创建 http 服务器，开启端口监听。koa 实例的 `listen` 方法就是这个作用，它是怎么实现的呢？\n\n\n## listen\nKoa 是基于 node.js 网络模块封装出来的框架。在上面的示例中在初始化 koa 实例后，就调用了 `listen` 方法在 3000 端口开始监听请求。它的实现是：\n\n```js\nlisten(...args) {\n    const server = http.createServer(this.callback());\n    return server.listen(...args);\n}\n```\n\n通过查阅 [node.js 文档](https://nodejs.org/api/http.html#http_http_createserver_options_requestlistener) 我们会知道调用`http.createServer` 方法之后会返回一个 `Server` 实例，且这个方法的入参就是一个签名为 `(req: IncomingMessage, res: ServerResponse) => void` 的 `request handler`，这个函数会在 Server 实例每次接收到 [`request` 事件](https://nodejs.org/api/http.html#http_event_request)（即请求进入）时被调用。\n\n从源码看到 Koa 框架使用的 `request handler` 就是 `this.callback()` 的返回值。所以当请求进入的时候，Koa 是如何应战的？\n\n## callback\n\n```js\nconst compose = require('koa-compose');\n\nclass Application {\n  callback() {\n    const fn = compose(this.middleware);\n\n    if (!this.listenerCount('error')) this.on('error', this.onerror);\n\n    const handleRequest = (req, res) => {\n      const ctx = this.createContext(req, res);\n      return this.handleRequest(ctx, fn);\n    };\n\n    return handleRequest;\n  }\n\n  /**\n   * Handle request in callback.\n   *\n   * @api private\n   */\n\n  handleRequest(ctx, fnMiddleware) {\n    const res = ctx.res;\n    res.statusCode = 404;\n    const onerror = err => ctx.onerror(err);\n    const handleResponse = () => respond(ctx);\n    onFinished(res, onerror);\n    return fnMiddleware(ctx).then(handleResponse).catch(onerror);\n  }\n\n  ...\n}\n```\n\n`callback` 首先把 middleware 传给了 koa-compose 模块，返回了一个函数 `fn`。\n\n接着 `callback` 内声明了一个 `handleRequest` 函数并将其返回。所以最终 node.js `request` 事件触发的时候调用的就是这个 `handleRequest`。\n\n当请求进入，`handleRequest` 被调用。被调用时它创建了一个 `context` 对象，关于 `context` 对象我们暂时略过，先走完中间件的执行流程。接着就把上面得到的 `fn` 和 `ctx` 传递给**实例方法** `handleRequest` 执行。\n\n实例方法 `handleRequest` 中实际的代码就是执行了 koa-compose 得到的函数 `fnMiddleware`。\n\n可以看出这是一个 promsise 链，当 `fnMiddleware` 返回的 `promise` 变更为 resolved 状态时，就调用 `handleResponse`这个闭包函数，其内的 `respond` 方法持有对 `ctx` 的引用。其作用就是经过中间件处理后响应客户端；当 `promise` 变更为 rejected 状态时，就会使用 `ctx.onerror` 方法响应给客户端，这个主要是 Koa 框架提供的兜底异常处理。一般业务中我们都会定义自己的异常处理函数。\n\n所以中间件具体是怎么执行的，这就需要查看 koa-compose 模块的执行逻辑。\n\n\n### koa-compose\n\n```js\n/**\n * Compose `middleware` returning\n * a fully valid middleware comprised\n * of all those which are passed.\n *\n * @param {Array} middleware\n * @return {Function}\n * @api public\n */\nfunction compose (middleware) {\n  if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!')\n  for (const fn of middleware) {\n    if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!')\n  }\n\n  /**\n   * @param {Object} context\n   * @return {Promise}\n   * @api public\n   */\n\n  return function (context, next) {\n    // last called middleware #\n    let index = -1\n    return dispatch(0)\n    function dispatch (i) {\n      if (i <= index) return Promise.reject(new Error('next() called multiple times'))\n      index = i\n      let fn = middleware[i]\n      if (i === middleware.length) fn = next\n      if (!fn) return Promise.resolve()\n      try {\n        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));\n      } catch (err) {\n        return Promise.reject(err)\n      }\n    }\n  }\n}\n```\n\n当我们在上面的 `handleRequest` 中调用 `fnMiddleware` 时最终执行的是 `dispatch(0)`，上面 promise 链的起点也就是这个方法的返回值。\n\n我们先跳过 dispatch 函数声明的第二行和第三行。从第四行开始阅读，以 i 为下标取 middleware 队列中的中间件函数，还记得中间件的签名是 `(context: Koa.Context, next: Koa.Next) => any;`，在这里将作用域里的 context 和 bind 过后且参数为 i+1 的 dispatch 函数作为 next 传给中间件执行。\n\n假设有如下两个中间件\n\n```js\napp.use(async function middleware1(context, next) {\n  console.log('before 1')\n  await next()\n  console.log('after 1')\n})\n\napp.use(async function middleware2(context, next) {\n  console.log('before 2')\n  await next()\n  console.log('after ')\n})\n```\n\n经过 Koa 的编排，那么他们的执行逻辑等同于\n\n```js\n\nasync function middleware1(context, next) {\n  console.log('before 1')\n  await Promise.resolve(async function(context, next) {\n    console.log('before 2')\n    await next()\n    console.log('after 2')\n  }(context, () => Promise.resolve()))\n  console.log('after 1')\n}\n\nmiddleware1({}, undefined)\n```\n\n中间件的嵌套执行实现了 Koa 的洋葱圈模型。\n\n最后一个值得注意的点是，闭包里维护了一个 index，这是防止 `next` 方法在一个中间件中被多次执行，多次执行就会导致中间件的执行顺序不是串行的而是并行的导致混乱。\n\n\n## context\n在上面我们看到每次请求进入都会调用 createContext 来创建一个上下文对象 context，并将其传给了中间件链条。\n\n```js\n  createContext(req, res) {\n    const context = Object.create(this.context);\n    const request = context.request = Object.create(this.request);\n    const response = context.response = Object.create(this.response);\n    context.app = request.app = response.app = this;\n    context.req = request.req = response.req = req;\n    context.res = request.res = response.res = res;\n    request.ctx = response.ctx = context;\n    request.response = response;\n    response.request = request;\n    context.originalUrl = request.originalUrl = req.url;\n    context.state = {};\n    return context;\n  }\n```\n\ncontext 是一个原型为 `this.context` 的新对象。而 `this.context` 又是以 `context.js` 下声明的原型对象为原型的对象。\n\ncontext.app 为 Koa 实例；context.req 是 Node.js IncomingMessage 的实例；context.res 是 Node.js ServerResponse 的实例；context.request 是 Koa 扩展过 IncomingMessage 后的实例；context.request 是 Koa 扩展过 ServerResponse 后的实例；\n\ncontext 如下大量代理了它的 Koa response (非 Node.js req)和 Koa request (非 Node.js res)上的方法和属性。这就是为什么我们可以使用诸如 `ctx.body = { data: {}}` 的原因。\n\n```js\ndelegate(proto, 'response')\n  .method('attachment')\n  .method('redirect')\n  .method('remove')\n  .method('vary')\n  .method('has')\n  .method('set')\n  .method('append')\n  .method('flushHeaders')\n  .access('status')\n  .access('message')\n  .access('body')\n  .access('length')\n  .access('type')\n  .access('lastModified')\n  .access('etag')\n  .getter('headerSent')\n  .getter('writable');\n\n/**\n * Request delegation.\n */\n\ndelegate(proto, 'request')\n  .method('acceptsLanguages')\n  .method('acceptsEncodings')\n  .method('acceptsCharsets')\n  .method('accepts')\n  .method('get')\n  .method('is')\n  .access('querystring')\n  .access('idempotent')\n  .access('socket')\n  .access('search')\n  .access('method')\n  .access('query')\n  .access('path')\n  .access('url')\n  .access('accept')\n  .getter('origin')\n  .getter('href')\n  .getter('subdomains')\n  .getter('protocol')\n  .getter('host')\n  .getter('hostname')\n  .getter('URL')\n  .getter('header')\n  .getter('headers')\n  .getter('secure')\n  .getter('stale')\n  .getter('fresh')\n  .getter('ips')\n  .getter('ip');\n```\n\n## Request & Response\nrequest.js 和 response.js 分别声明了上面 context.request 和 context.response 对象的原型。\n\n在这些原型上声明了很多语法糖方法。比如 `ctx.status = 200` 和  `const status = ctx.status` 都是我们上面所说的 ctx 对 response 对象的代理。而 `response[set status]` 和 `response[get status]` 实现如下\n\n```js\n  /**\n   * Get response status code.\n   *\n   * @return {Number}\n   * @api public\n   */\n\n  get status() {\n    return this.res.statusCode;\n  },\n\n  /**\n   * Set response status code.\n   *\n   * @param {Number} code\n   * @api public\n   */\n\n  set status(code) {\n    if (this.headerSent) return;\n\n    assert(Number.isInteger(code), 'status code must be a number');\n    assert(code >= 100 && code <= 999, `invalid status code: ${code}`);\n    this._explicitStatus = true;\n    this.res.statusCode = code;\n    if (this.req.httpVersionMajor < 2) this.res.statusMessage = statuses[code];\n    if (this.body && statuses.empty[code]) this.body = null;\n  },\n```\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"how-koa","published":1,"updated":"2020-11-20T11:16:36.369Z","_id":"ckhpu9d1x000jak87zbh1ovkt","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Koa 作为 node.js 的下一代 web framework 和它的前辈 express.js 相比有什么不一样？</p>\n<p>从 <a href=\"https://github.com/koajs/koa/blob/master/docs/koa-vs-express.md\" target=\"_blank\" rel=\"noopener\">官方文档</a> 可以看出它的主要特点或者说和 express.js 的区别主要是</p>\n<ol>\n<li>精简</li>\n<li>使用 async</li>\n</ol>\n<p>koa 只实现了中间件内核，没有 express.js 的重要功能 – 路由，也更没有模板渲染，jsonp等等特性，这些功能都通过三方中间件来实现。所以它可以被看成 node.js 的 http 模块的抽象，而 express.js 则是一个应用框架。</p>\n<p>koa 不使用传统的 node.js callback 编码风格，而是拥抱了 async/await。当然 express.js 也是可以使用 async/await，只不过 koa 使用 async/await 能够实现 <a href=\"https://eggjs.org/zh-cn/intro/egg-and-koa.html#middleware\" target=\"_blank\" rel=\"noopener\">洋葱圈模型</a> 和更好的 <a href=\"https://itnext.io/from-express-to-koa-f3be4afdfd39\" target=\"_blank\" rel=\"noopener\">异常处理</a>。</p>\n<h2 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h2><p>首先看看 koa 是如何使用的？</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// logger</span></span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) => {</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> rt = ctx.response.get(<span class=\"string\">'X-Response-Time'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">${ctx.method}</span> <span class=\"subst\">${ctx.url}</span> - <span class=\"subst\">${rt}</span>`</span>);</span><br><span class=\"line\">});</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// x-response-time</span></span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) => {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> start = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> ms = <span class=\"built_in\">Date</span>.now() - start;</span><br><span class=\"line\">  ctx.set(<span class=\"string\">'X-Response-Time'</span>, <span class=\"string\">`<span class=\"subst\">${ms}</span>ms`</span>);</span><br><span class=\"line\">});</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// response</span></span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> ctx => {</span><br><span class=\"line\">  ctx.body = <span class=\"string\">'Hello World'</span>;</span><br><span class=\"line\">});</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>);</span><br></pre></td></tr></tbody></table></figure>\n<p>koa app 的实例化和 express 的工厂模式不同，它通过 new 关键字来实例化。</p>\n<p><code>use</code> 方法继承了 express.js 的命名风格，在这个示例里声明了三个中间件。但是这里 <code>use</code> 的入参和 express 的 <code>use</code> 方法有不同，koa 这里只接收一个入参，就是中间件函数。</p>\n<p>中间件函数的签名是 <code>(context: Koa.Context, next: Koa.Next) => any;</code>，那么这里又有两个非常重要的概念，<code>context</code> 和 <code>next()</code>，<code>context</code> 是单次请求的上下文对象，在每次请求时会被创建；<code>next</code> 方法是 Koa 实现洋葱圈模型的关键。</p>\n<p><code>listen</code> 方法同 express.js 的 <code>listen</code> 方法一样，开启了监听端口。</p>\n<h2 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h2><blockquote>\n<p>版本：Koa v2.13.0</p>\n</blockquote>\n<p><img src=\"https://img10.360buyimg.com/jdphoto/jfs/t1/127096/30/18199/6516/5faa98eaEd5e002ab/f40c762d5fdd23f8.png\" alt=\"cloc koa/lib\"></p>\n<p>Koa 的源代码（不包括依赖）只有大概700行，相比于 express.js 少了大概 1000 行。</p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lib</span><br><span class=\"line\">├── application.js</span><br><span class=\"line\">├── context.js</span><br><span class=\"line\">├── request.js</span><br><span class=\"line\">└── response.js</span><br></pre></td></tr></tbody></table></figure>\n<p>koa 的代码被划分为以上四个文件:</p>\n<p>application.js 导出的是 Koa Application 类<br>context.js 是 context 对象的原型<br>request.js 和 response.js 分别是 context.request 和 context.response 对象的原型</p>\n<h2 id=\"use\"><a href=\"#use\" class=\"headerlink\" title=\"use\"></a>use</h2><p><img src=\"https://img10.360buyimg.com/jdphoto/jfs/t1/143072/10/15096/11183/5fb618ccE295c7533/604bf4ee66b82557.png\" alt=\"koa structue\"></p>\n<p>Koa 框架的核心在于它实现了一套好用的中间件机制。Koa 的中间件是一个签名为 <code>(context: Koa.Context, next: Koa.Next) => any;</code> 的函数，Koa 实例的 <code>use</code> 方法用于注册中间件。Koa 实例上维护了一个名为 <code>middleware</code> 的队列，用于存储所有的中间件函数。<code>use</code> 方法的实现非常简单，以下是精简过的代码：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use(fn) {</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.middleware.push(fn);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p><code>use</code> 方法将中间件函数推入队列中，返回 <code>this</code>，这让 <code>use</code> 可以链式调用。</p>\n<p>完成了中间件的注册之后，我们就要创建 http 服务器，开启端口监听。koa 实例的 <code>listen</code> 方法就是这个作用，它是怎么实现的呢？</p>\n<h2 id=\"listen\"><a href=\"#listen\" class=\"headerlink\" title=\"listen\"></a>listen</h2><p>Koa 是基于 node.js 网络模块封装出来的框架。在上面的示例中在初始化 koa 实例后，就调用了 <code>listen</code> 方法在 3000 端口开始监听请求。它的实现是：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">listen(...args) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> server = http.createServer(<span class=\"keyword\">this</span>.callback());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> server.listen(...args);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>通过查阅 <a href=\"https://nodejs.org/api/http.html#http_http_createserver_options_requestlistener\" target=\"_blank\" rel=\"noopener\">node.js 文档</a> 我们会知道调用<code>http.createServer</code> 方法之后会返回一个 <code>Server</code> 实例，且这个方法的入参就是一个签名为 <code>(req: IncomingMessage, res: ServerResponse) => void</code> 的 <code>request handler</code>，这个函数会在 Server 实例每次接收到 <a href=\"https://nodejs.org/api/http.html#http_event_request\" target=\"_blank\" rel=\"noopener\"><code>request</code> 事件</a>（即请求进入）时被调用。</p>\n<p>从源码看到 Koa 框架使用的 <code>request handler</code> 就是 <code>this.callback()</code> 的返回值。所以当请求进入的时候，Koa 是如何应战的？</p>\n<h2 id=\"callback\"><a href=\"#callback\" class=\"headerlink\" title=\"callback\"></a>callback</h2><figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-compose'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Application</span> </span>{</span><br><span class=\"line\">  callback() {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> fn = compose(<span class=\"keyword\">this</span>.middleware);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.listenerCount(<span class=\"string\">'error'</span>)) <span class=\"keyword\">this</span>.on(<span class=\"string\">'error'</span>, <span class=\"keyword\">this</span>.onerror);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> handleRequest = <span class=\"function\">(<span class=\"params\">req, res</span>) =></span> {</span><br><span class=\"line\">      <span class=\"keyword\">const</span> ctx = <span class=\"keyword\">this</span>.createContext(req, res);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.handleRequest(ctx, fn);</span><br><span class=\"line\">    };</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> handleRequest;</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Handle request in callback.</span></span><br><span class=\"line\"><span class=\"comment\">   *</span></span><br><span class=\"line\"><span class=\"comment\">   * @api private</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  handleRequest(ctx, fnMiddleware) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> res = ctx.res;</span><br><span class=\"line\">    res.statusCode = <span class=\"number\">404</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> onerror = <span class=\"function\"><span class=\"params\">err</span> =></span> ctx.onerror(err);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> handleResponse = <span class=\"function\"><span class=\"params\">()</span> =></span> respond(ctx);</span><br><span class=\"line\">    onFinished(res, onerror);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fnMiddleware(ctx).then(handleResponse).catch(onerror);</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p><code>callback</code> 首先把 middleware 传给了 koa-compose 模块，返回了一个函数 <code>fn</code>。</p>\n<p>接着 <code>callback</code> 内声明了一个 <code>handleRequest</code> 函数并将其返回。所以最终 node.js <code>request</code> 事件触发的时候调用的就是这个 <code>handleRequest</code>。</p>\n<p>当请求进入，<code>handleRequest</code> 被调用。被调用时它创建了一个 <code>context</code> 对象，关于 <code>context</code> 对象我们暂时略过，先走完中间件的执行流程。接着就把上面得到的 <code>fn</code> 和 <code>ctx</code> 传递给<strong>实例方法</strong> <code>handleRequest</code> 执行。</p>\n<p>实例方法 <code>handleRequest</code> 中实际的代码就是执行了 koa-compose 得到的函数 <code>fnMiddleware</code>。</p>\n<p>可以看出这是一个 promsise 链，当 <code>fnMiddleware</code> 返回的 <code>promise</code> 变更为 resolved 状态时，就调用 <code>handleResponse</code>这个闭包函数，其内的 <code>respond</code> 方法持有对 <code>ctx</code> 的引用。其作用就是经过中间件处理后响应客户端；当 <code>promise</code> 变更为 rejected 状态时，就会使用 <code>ctx.onerror</code> 方法响应给客户端，这个主要是 Koa 框架提供的兜底异常处理。一般业务中我们都会定义自己的异常处理函数。</p>\n<p>所以中间件具体是怎么执行的，这就需要查看 koa-compose 模块的执行逻辑。</p>\n<h3 id=\"koa-compose\"><a href=\"#koa-compose\" class=\"headerlink\" title=\"koa-compose\"></a>koa-compose</h3><figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Compose `middleware` returning</span></span><br><span class=\"line\"><span class=\"comment\"> * a fully valid middleware comprised</span></span><br><span class=\"line\"><span class=\"comment\"> * of all those which are passed.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @param {Array} middleware</span></span><br><span class=\"line\"><span class=\"comment\"> * @return {Function}</span></span><br><span class=\"line\"><span class=\"comment\"> * @api public</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compose</span> (<span class=\"params\">middleware</span>) </span>{</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"built_in\">Array</span>.isArray(middleware)) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">'Middleware stack must be an array!'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> fn <span class=\"keyword\">of</span> middleware) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> fn !== <span class=\"string\">'function'</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">'Middleware must be composed of functions!'</span>)</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * @param {Object} context</span></span><br><span class=\"line\"><span class=\"comment\">   * @return {Promise}</span></span><br><span class=\"line\"><span class=\"comment\">   * @api public</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">context, next</span>) </span>{</span><br><span class=\"line\">    <span class=\"comment\">// last called middleware #</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> index = <span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dispatch(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dispatch</span> (<span class=\"params\">i</span>) </span>{</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i <= index) <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'next() called multiple times'</span>))</span><br><span class=\"line\">      index = i</span><br><span class=\"line\">      <span class=\"keyword\">let</span> fn = middleware[i]</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i === middleware.length) fn = next</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!fn) <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve()</span><br><span class=\"line\">      <span class=\"keyword\">try</span> {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve(fn(context, dispatch.bind(<span class=\"literal\">null</span>, i + <span class=\"number\">1</span>)));</span><br><span class=\"line\">      } <span class=\"keyword\">catch</span> (err) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.reject(err)</span><br><span class=\"line\">      }</span><br><span class=\"line\">    }</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>当我们在上面的 <code>handleRequest</code> 中调用 <code>fnMiddleware</code> 时最终执行的是 <code>dispatch(0)</code>，上面 promise 链的起点也就是这个方法的返回值。</p>\n<p>我们先跳过 dispatch 函数声明的第二行和第三行。从第四行开始阅读，以 i 为下标取 middleware 队列中的中间件函数，还记得中间件的签名是 <code>(context: Koa.Context, next: Koa.Next) => any;</code>，在这里将作用域里的 context 和 bind 过后且参数为 i+1 的 dispatch 函数作为 next 传给中间件执行。</p>\n<p>假设有如下两个中间件</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">middleware1</span>(<span class=\"params\">context, next</span>) </span>{</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'before 1'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'after 1'</span>)</span><br><span class=\"line\">})</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">middleware2</span>(<span class=\"params\">context, next</span>) </span>{</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'before 2'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'after '</span>)</span><br><span class=\"line\">})</span><br></pre></td></tr></tbody></table></figure>\n<p>经过 Koa 的编排，那么他们的执行逻辑等同于</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">middleware1</span>(<span class=\"params\">context, next</span>) </span>{</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'before 1'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">context, next</span>) </span>{</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'before 2'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'after 2'</span>)</span><br><span class=\"line\">  }(context, () => <span class=\"built_in\">Promise</span>.resolve()))</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'after 1'</span>)</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">middleware1({}, <span class=\"literal\">undefined</span>)</span><br></pre></td></tr></tbody></table></figure>\n<p>中间件的嵌套执行实现了 Koa 的洋葱圈模型。</p>\n<p>最后一个值得注意的点是，闭包里维护了一个 index，这是防止 <code>next</code> 方法在一个中间件中被多次执行，多次执行就会导致中间件的执行顺序不是串行的而是并行的导致混乱。</p>\n<h2 id=\"context\"><a href=\"#context\" class=\"headerlink\" title=\"context\"></a>context</h2><p>在上面我们看到每次请求进入都会调用 createContext 来创建一个上下文对象 context，并将其传给了中间件链条。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">createContext(req, res) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> context = <span class=\"built_in\">Object</span>.create(<span class=\"keyword\">this</span>.context);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> request = context.request = <span class=\"built_in\">Object</span>.create(<span class=\"keyword\">this</span>.request);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> response = context.response = <span class=\"built_in\">Object</span>.create(<span class=\"keyword\">this</span>.response);</span><br><span class=\"line\">  context.app = request.app = response.app = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  context.req = request.req = response.req = req;</span><br><span class=\"line\">  context.res = request.res = response.res = res;</span><br><span class=\"line\">  request.ctx = response.ctx = context;</span><br><span class=\"line\">  request.response = response;</span><br><span class=\"line\">  response.request = request;</span><br><span class=\"line\">  context.originalUrl = request.originalUrl = req.url;</span><br><span class=\"line\">  context.state = {};</span><br><span class=\"line\">  <span class=\"keyword\">return</span> context;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>context 是一个原型为 <code>this.context</code> 的新对象。而 <code>this.context</code> 又是以 <code>context.js</code> 下声明的原型对象为原型的对象。</p>\n<p>context.app 为 Koa 实例；context.req 是 Node.js IncomingMessage 的实例；context.res 是 Node.js ServerResponse 的实例；context.request 是 Koa 扩展过 IncomingMessage 后的实例；context.request 是 Koa 扩展过 ServerResponse 后的实例；</p>\n<p>context 如下大量代理了它的 Koa response (非 Node.js req)和 Koa request (非 Node.js res)上的方法和属性。这就是为什么我们可以使用诸如 <code>ctx.body = { data: {}}</code> 的原因。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delegate(proto, <span class=\"string\">'response'</span>)</span><br><span class=\"line\">  .method(<span class=\"string\">'attachment'</span>)</span><br><span class=\"line\">  .method(<span class=\"string\">'redirect'</span>)</span><br><span class=\"line\">  .method(<span class=\"string\">'remove'</span>)</span><br><span class=\"line\">  .method(<span class=\"string\">'vary'</span>)</span><br><span class=\"line\">  .method(<span class=\"string\">'has'</span>)</span><br><span class=\"line\">  .method(<span class=\"string\">'set'</span>)</span><br><span class=\"line\">  .method(<span class=\"string\">'append'</span>)</span><br><span class=\"line\">  .method(<span class=\"string\">'flushHeaders'</span>)</span><br><span class=\"line\">  .access(<span class=\"string\">'status'</span>)</span><br><span class=\"line\">  .access(<span class=\"string\">'message'</span>)</span><br><span class=\"line\">  .access(<span class=\"string\">'body'</span>)</span><br><span class=\"line\">  .access(<span class=\"string\">'length'</span>)</span><br><span class=\"line\">  .access(<span class=\"string\">'type'</span>)</span><br><span class=\"line\">  .access(<span class=\"string\">'lastModified'</span>)</span><br><span class=\"line\">  .access(<span class=\"string\">'etag'</span>)</span><br><span class=\"line\">  .getter(<span class=\"string\">'headerSent'</span>)</span><br><span class=\"line\">  .getter(<span class=\"string\">'writable'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Request delegation.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\">delegate(proto, <span class=\"string\">'request'</span>)</span><br><span class=\"line\">  .method(<span class=\"string\">'acceptsLanguages'</span>)</span><br><span class=\"line\">  .method(<span class=\"string\">'acceptsEncodings'</span>)</span><br><span class=\"line\">  .method(<span class=\"string\">'acceptsCharsets'</span>)</span><br><span class=\"line\">  .method(<span class=\"string\">'accepts'</span>)</span><br><span class=\"line\">  .method(<span class=\"string\">'get'</span>)</span><br><span class=\"line\">  .method(<span class=\"string\">'is'</span>)</span><br><span class=\"line\">  .access(<span class=\"string\">'querystring'</span>)</span><br><span class=\"line\">  .access(<span class=\"string\">'idempotent'</span>)</span><br><span class=\"line\">  .access(<span class=\"string\">'socket'</span>)</span><br><span class=\"line\">  .access(<span class=\"string\">'search'</span>)</span><br><span class=\"line\">  .access(<span class=\"string\">'method'</span>)</span><br><span class=\"line\">  .access(<span class=\"string\">'query'</span>)</span><br><span class=\"line\">  .access(<span class=\"string\">'path'</span>)</span><br><span class=\"line\">  .access(<span class=\"string\">'url'</span>)</span><br><span class=\"line\">  .access(<span class=\"string\">'accept'</span>)</span><br><span class=\"line\">  .getter(<span class=\"string\">'origin'</span>)</span><br><span class=\"line\">  .getter(<span class=\"string\">'href'</span>)</span><br><span class=\"line\">  .getter(<span class=\"string\">'subdomains'</span>)</span><br><span class=\"line\">  .getter(<span class=\"string\">'protocol'</span>)</span><br><span class=\"line\">  .getter(<span class=\"string\">'host'</span>)</span><br><span class=\"line\">  .getter(<span class=\"string\">'hostname'</span>)</span><br><span class=\"line\">  .getter(<span class=\"string\">'URL'</span>)</span><br><span class=\"line\">  .getter(<span class=\"string\">'header'</span>)</span><br><span class=\"line\">  .getter(<span class=\"string\">'headers'</span>)</span><br><span class=\"line\">  .getter(<span class=\"string\">'secure'</span>)</span><br><span class=\"line\">  .getter(<span class=\"string\">'stale'</span>)</span><br><span class=\"line\">  .getter(<span class=\"string\">'fresh'</span>)</span><br><span class=\"line\">  .getter(<span class=\"string\">'ips'</span>)</span><br><span class=\"line\">  .getter(<span class=\"string\">'ip'</span>);</span><br></pre></td></tr></tbody></table></figure>\n<h2 id=\"Request-amp-Response\"><a href=\"#Request-amp-Response\" class=\"headerlink\" title=\"Request & Response\"></a>Request & Response</h2><p>request.js 和 response.js 分别声明了上面 context.request 和 context.response 对象的原型。</p>\n<p>在这些原型上声明了很多语法糖方法。比如 <code>ctx.status = 200</code> 和  <code>const status = ctx.status</code> 都是我们上面所说的 ctx 对 response 对象的代理。而 <code>response[set status]</code> 和 <code>response[get status]</code> 实现如下</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Get response status code.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @return {Number}</span></span><br><span class=\"line\"><span class=\"comment\"> * @api public</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">get</span> status() {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.res.statusCode;</span><br><span class=\"line\">},</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Set response status code.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @param {Number} code</span></span><br><span class=\"line\"><span class=\"comment\"> * @api public</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">set</span> status(code) {</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.headerSent) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  assert(<span class=\"built_in\">Number</span>.isInteger(code), <span class=\"string\">'status code must be a number'</span>);</span><br><span class=\"line\">  assert(code >= <span class=\"number\">100</span> && code <= <span class=\"number\">999</span>, <span class=\"string\">`invalid status code: <span class=\"subst\">${code}</span>`</span>);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>._explicitStatus = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.res.statusCode = code;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.req.httpVersionMajor < <span class=\"number\">2</span>) <span class=\"keyword\">this</span>.res.statusMessage = statuses[code];</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.body && statuses.empty[code]) <span class=\"keyword\">this</span>.body = <span class=\"literal\">null</span>;</span><br><span class=\"line\">},</span><br></pre></td></tr></tbody></table></figure>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"excerpt":"","more":"<p>Koa 作为 node.js 的下一代 web framework 和它的前辈 express.js 相比有什么不一样？</p>\n<p>从 <a href=\"https://github.com/koajs/koa/blob/master/docs/koa-vs-express.md\" target=\"_blank\" rel=\"noopener\">官方文档</a> 可以看出它的主要特点或者说和 express.js 的区别主要是</p>\n<ol>\n<li>精简</li>\n<li>使用 async</li>\n</ol>\n<p>koa 只实现了中间件内核，没有 express.js 的重要功能 – 路由，也更没有模板渲染，jsonp等等特性，这些功能都通过三方中间件来实现。所以它可以被看成 node.js 的 http 模块的抽象，而 express.js 则是一个应用框架。</p>\n<p>koa 不使用传统的 node.js callback 编码风格，而是拥抱了 async/await。当然 express.js 也是可以使用 async/await，只不过 koa 使用 async/await 能够实现 <a href=\"https://eggjs.org/zh-cn/intro/egg-and-koa.html#middleware\" target=\"_blank\" rel=\"noopener\">洋葱圈模型</a> 和更好的 <a href=\"https://itnext.io/from-express-to-koa-f3be4afdfd39\" target=\"_blank\" rel=\"noopener\">异常处理</a>。</p>\n<h2 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h2><p>首先看看 koa 是如何使用的？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// logger</span></span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> rt = ctx.response.get(<span class=\"string\">'X-Response-Time'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;ctx.method&#125;</span> <span class=\"subst\">$&#123;ctx.url&#125;</span> - <span class=\"subst\">$&#123;rt&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// x-response-time</span></span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> start = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> ms = <span class=\"built_in\">Date</span>.now() - start;</span><br><span class=\"line\">  ctx.set(<span class=\"string\">'X-Response-Time'</span>, <span class=\"string\">`<span class=\"subst\">$&#123;ms&#125;</span>ms`</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// response</span></span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> ctx =&gt; &#123;</span><br><span class=\"line\">  ctx.body = <span class=\"string\">'Hello World'</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n<p>koa app 的实例化和 express 的工厂模式不同，它通过 new 关键字来实例化。</p>\n<p><code>use</code> 方法继承了 express.js 的命名风格，在这个示例里声明了三个中间件。但是这里 <code>use</code> 的入参和 express 的 <code>use</code> 方法有不同，koa 这里只接收一个入参，就是中间件函数。</p>\n<p>中间件函数的签名是 <code>(context: Koa.Context, next: Koa.Next) =&gt; any;</code>，那么这里又有两个非常重要的概念，<code>context</code> 和 <code>next()</code>，<code>context</code> 是单次请求的上下文对象，在每次请求时会被创建；<code>next</code> 方法是 Koa 实现洋葱圈模型的关键。</p>\n<p><code>listen</code> 方法同 express.js 的 <code>listen</code> 方法一样，开启了监听端口。</p>\n<h2 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h2><blockquote>\n<p>版本：Koa v2.13.0</p>\n</blockquote>\n<p><img src=\"https://img10.360buyimg.com/jdphoto/jfs/t1/127096/30/18199/6516/5faa98eaEd5e002ab/f40c762d5fdd23f8.png\" alt=\"cloc koa/lib\"></p>\n<p>Koa 的源代码（不包括依赖）只有大概700行，相比于 express.js 少了大概 1000 行。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lib</span><br><span class=\"line\">├── application.js</span><br><span class=\"line\">├── context.js</span><br><span class=\"line\">├── request.js</span><br><span class=\"line\">└── response.js</span><br></pre></td></tr></table></figure>\n<p>koa 的代码被划分为以上四个文件:</p>\n<p>application.js 导出的是 Koa Application 类<br>context.js 是 context 对象的原型<br>request.js 和 response.js 分别是 context.request 和 context.response 对象的原型</p>\n<h2 id=\"use\"><a href=\"#use\" class=\"headerlink\" title=\"use\"></a>use</h2><p><img src=\"https://img10.360buyimg.com/jdphoto/jfs/t1/143072/10/15096/11183/5fb618ccE295c7533/604bf4ee66b82557.png\" alt=\"koa structue\"></p>\n<p>Koa 框架的核心在于它实现了一套好用的中间件机制。Koa 的中间件是一个签名为 <code>(context: Koa.Context, next: Koa.Next) =&gt; any;</code> 的函数，Koa 实例的 <code>use</code> 方法用于注册中间件。Koa 实例上维护了一个名为 <code>middleware</code> 的队列，用于存储所有的中间件函数。<code>use</code> 方法的实现非常简单，以下是精简过的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use(fn) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.middleware.push(fn);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>use</code> 方法将中间件函数推入队列中，返回 <code>this</code>，这让 <code>use</code> 可以链式调用。</p>\n<p>完成了中间件的注册之后，我们就要创建 http 服务器，开启端口监听。koa 实例的 <code>listen</code> 方法就是这个作用，它是怎么实现的呢？</p>\n<h2 id=\"listen\"><a href=\"#listen\" class=\"headerlink\" title=\"listen\"></a>listen</h2><p>Koa 是基于 node.js 网络模块封装出来的框架。在上面的示例中在初始化 koa 实例后，就调用了 <code>listen</code> 方法在 3000 端口开始监听请求。它的实现是：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">listen(...args) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> server = http.createServer(<span class=\"keyword\">this</span>.callback());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> server.listen(...args);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过查阅 <a href=\"https://nodejs.org/api/http.html#http_http_createserver_options_requestlistener\" target=\"_blank\" rel=\"noopener\">node.js 文档</a> 我们会知道调用<code>http.createServer</code> 方法之后会返回一个 <code>Server</code> 实例，且这个方法的入参就是一个签名为 <code>(req: IncomingMessage, res: ServerResponse) =&gt; void</code> 的 <code>request handler</code>，这个函数会在 Server 实例每次接收到 <a href=\"https://nodejs.org/api/http.html#http_event_request\" target=\"_blank\" rel=\"noopener\"><code>request</code> 事件</a>（即请求进入）时被调用。</p>\n<p>从源码看到 Koa 框架使用的 <code>request handler</code> 就是 <code>this.callback()</code> 的返回值。所以当请求进入的时候，Koa 是如何应战的？</p>\n<h2 id=\"callback\"><a href=\"#callback\" class=\"headerlink\" title=\"callback\"></a>callback</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-compose'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Application</span> </span>&#123;</span><br><span class=\"line\">  callback() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> fn = compose(<span class=\"keyword\">this</span>.middleware);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.listenerCount(<span class=\"string\">'error'</span>)) <span class=\"keyword\">this</span>.on(<span class=\"string\">'error'</span>, <span class=\"keyword\">this</span>.onerror);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> handleRequest = <span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> ctx = <span class=\"keyword\">this</span>.createContext(req, res);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.handleRequest(ctx, fn);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> handleRequest;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Handle request in callback.</span></span><br><span class=\"line\"><span class=\"comment\">   *</span></span><br><span class=\"line\"><span class=\"comment\">   * @api private</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  handleRequest(ctx, fnMiddleware) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> res = ctx.res;</span><br><span class=\"line\">    res.statusCode = <span class=\"number\">404</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> onerror = <span class=\"function\"><span class=\"params\">err</span> =&gt;</span> ctx.onerror(err);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> handleResponse = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> respond(ctx);</span><br><span class=\"line\">    onFinished(res, onerror);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fnMiddleware(ctx).then(handleResponse).catch(onerror);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>callback</code> 首先把 middleware 传给了 koa-compose 模块，返回了一个函数 <code>fn</code>。</p>\n<p>接着 <code>callback</code> 内声明了一个 <code>handleRequest</code> 函数并将其返回。所以最终 node.js <code>request</code> 事件触发的时候调用的就是这个 <code>handleRequest</code>。</p>\n<p>当请求进入，<code>handleRequest</code> 被调用。被调用时它创建了一个 <code>context</code> 对象，关于 <code>context</code> 对象我们暂时略过，先走完中间件的执行流程。接着就把上面得到的 <code>fn</code> 和 <code>ctx</code> 传递给<strong>实例方法</strong> <code>handleRequest</code> 执行。</p>\n<p>实例方法 <code>handleRequest</code> 中实际的代码就是执行了 koa-compose 得到的函数 <code>fnMiddleware</code>。</p>\n<p>可以看出这是一个 promsise 链，当 <code>fnMiddleware</code> 返回的 <code>promise</code> 变更为 resolved 状态时，就调用 <code>handleResponse</code>这个闭包函数，其内的 <code>respond</code> 方法持有对 <code>ctx</code> 的引用。其作用就是经过中间件处理后响应客户端；当 <code>promise</code> 变更为 rejected 状态时，就会使用 <code>ctx.onerror</code> 方法响应给客户端，这个主要是 Koa 框架提供的兜底异常处理。一般业务中我们都会定义自己的异常处理函数。</p>\n<p>所以中间件具体是怎么执行的，这就需要查看 koa-compose 模块的执行逻辑。</p>\n<h3 id=\"koa-compose\"><a href=\"#koa-compose\" class=\"headerlink\" title=\"koa-compose\"></a>koa-compose</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Compose `middleware` returning</span></span><br><span class=\"line\"><span class=\"comment\"> * a fully valid middleware comprised</span></span><br><span class=\"line\"><span class=\"comment\"> * of all those which are passed.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Array&#125; middleware</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;Function&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * @api public</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compose</span> (<span class=\"params\">middleware</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"built_in\">Array</span>.isArray(middleware)) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">'Middleware stack must be an array!'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> fn <span class=\"keyword\">of</span> middleware) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> fn !== <span class=\"string\">'function'</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">'Middleware must be composed of functions!'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * @param &#123;Object&#125; context</span></span><br><span class=\"line\"><span class=\"comment\">   * @return &#123;Promise&#125;</span></span><br><span class=\"line\"><span class=\"comment\">   * @api public</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">context, next</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// last called middleware #</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> index = <span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dispatch(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dispatch</span> (<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i &lt;= index) <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'next() called multiple times'</span>))</span><br><span class=\"line\">      index = i</span><br><span class=\"line\">      <span class=\"keyword\">let</span> fn = middleware[i]</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i === middleware.length) fn = next</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!fn) <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve()</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve(fn(context, dispatch.bind(<span class=\"literal\">null</span>, i + <span class=\"number\">1</span>)));</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.reject(err)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当我们在上面的 <code>handleRequest</code> 中调用 <code>fnMiddleware</code> 时最终执行的是 <code>dispatch(0)</code>，上面 promise 链的起点也就是这个方法的返回值。</p>\n<p>我们先跳过 dispatch 函数声明的第二行和第三行。从第四行开始阅读，以 i 为下标取 middleware 队列中的中间件函数，还记得中间件的签名是 <code>(context: Koa.Context, next: Koa.Next) =&gt; any;</code>，在这里将作用域里的 context 和 bind 过后且参数为 i+1 的 dispatch 函数作为 next 传给中间件执行。</p>\n<p>假设有如下两个中间件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">middleware1</span>(<span class=\"params\">context, next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'before 1'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'after 1'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">middleware2</span>(<span class=\"params\">context, next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'before 2'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'after '</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>经过 Koa 的编排，那么他们的执行逻辑等同于</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">middleware1</span>(<span class=\"params\">context, next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'before 1'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">context, next</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'before 2'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'after 2'</span>)</span><br><span class=\"line\">  &#125;(context, () =&gt; <span class=\"built_in\">Promise</span>.resolve()))</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'after 1'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">middleware1(&#123;&#125;, <span class=\"literal\">undefined</span>)</span><br></pre></td></tr></table></figure>\n<p>中间件的嵌套执行实现了 Koa 的洋葱圈模型。</p>\n<p>最后一个值得注意的点是，闭包里维护了一个 index，这是防止 <code>next</code> 方法在一个中间件中被多次执行，多次执行就会导致中间件的执行顺序不是串行的而是并行的导致混乱。</p>\n<h2 id=\"context\"><a href=\"#context\" class=\"headerlink\" title=\"context\"></a>context</h2><p>在上面我们看到每次请求进入都会调用 createContext 来创建一个上下文对象 context，并将其传给了中间件链条。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">createContext(req, res) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> context = <span class=\"built_in\">Object</span>.create(<span class=\"keyword\">this</span>.context);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> request = context.request = <span class=\"built_in\">Object</span>.create(<span class=\"keyword\">this</span>.request);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> response = context.response = <span class=\"built_in\">Object</span>.create(<span class=\"keyword\">this</span>.response);</span><br><span class=\"line\">  context.app = request.app = response.app = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  context.req = request.req = response.req = req;</span><br><span class=\"line\">  context.res = request.res = response.res = res;</span><br><span class=\"line\">  request.ctx = response.ctx = context;</span><br><span class=\"line\">  request.response = response;</span><br><span class=\"line\">  response.request = request;</span><br><span class=\"line\">  context.originalUrl = request.originalUrl = req.url;</span><br><span class=\"line\">  context.state = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> context;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>context 是一个原型为 <code>this.context</code> 的新对象。而 <code>this.context</code> 又是以 <code>context.js</code> 下声明的原型对象为原型的对象。</p>\n<p>context.app 为 Koa 实例；context.req 是 Node.js IncomingMessage 的实例；context.res 是 Node.js ServerResponse 的实例；context.request 是 Koa 扩展过 IncomingMessage 后的实例；context.request 是 Koa 扩展过 ServerResponse 后的实例；</p>\n<p>context 如下大量代理了它的 Koa response (非 Node.js req)和 Koa request (非 Node.js res)上的方法和属性。这就是为什么我们可以使用诸如 <code>ctx.body = { data: {}}</code> 的原因。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delegate(proto, <span class=\"string\">'response'</span>)</span><br><span class=\"line\">  .method(<span class=\"string\">'attachment'</span>)</span><br><span class=\"line\">  .method(<span class=\"string\">'redirect'</span>)</span><br><span class=\"line\">  .method(<span class=\"string\">'remove'</span>)</span><br><span class=\"line\">  .method(<span class=\"string\">'vary'</span>)</span><br><span class=\"line\">  .method(<span class=\"string\">'has'</span>)</span><br><span class=\"line\">  .method(<span class=\"string\">'set'</span>)</span><br><span class=\"line\">  .method(<span class=\"string\">'append'</span>)</span><br><span class=\"line\">  .method(<span class=\"string\">'flushHeaders'</span>)</span><br><span class=\"line\">  .access(<span class=\"string\">'status'</span>)</span><br><span class=\"line\">  .access(<span class=\"string\">'message'</span>)</span><br><span class=\"line\">  .access(<span class=\"string\">'body'</span>)</span><br><span class=\"line\">  .access(<span class=\"string\">'length'</span>)</span><br><span class=\"line\">  .access(<span class=\"string\">'type'</span>)</span><br><span class=\"line\">  .access(<span class=\"string\">'lastModified'</span>)</span><br><span class=\"line\">  .access(<span class=\"string\">'etag'</span>)</span><br><span class=\"line\">  .getter(<span class=\"string\">'headerSent'</span>)</span><br><span class=\"line\">  .getter(<span class=\"string\">'writable'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Request delegation.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\">delegate(proto, <span class=\"string\">'request'</span>)</span><br><span class=\"line\">  .method(<span class=\"string\">'acceptsLanguages'</span>)</span><br><span class=\"line\">  .method(<span class=\"string\">'acceptsEncodings'</span>)</span><br><span class=\"line\">  .method(<span class=\"string\">'acceptsCharsets'</span>)</span><br><span class=\"line\">  .method(<span class=\"string\">'accepts'</span>)</span><br><span class=\"line\">  .method(<span class=\"string\">'get'</span>)</span><br><span class=\"line\">  .method(<span class=\"string\">'is'</span>)</span><br><span class=\"line\">  .access(<span class=\"string\">'querystring'</span>)</span><br><span class=\"line\">  .access(<span class=\"string\">'idempotent'</span>)</span><br><span class=\"line\">  .access(<span class=\"string\">'socket'</span>)</span><br><span class=\"line\">  .access(<span class=\"string\">'search'</span>)</span><br><span class=\"line\">  .access(<span class=\"string\">'method'</span>)</span><br><span class=\"line\">  .access(<span class=\"string\">'query'</span>)</span><br><span class=\"line\">  .access(<span class=\"string\">'path'</span>)</span><br><span class=\"line\">  .access(<span class=\"string\">'url'</span>)</span><br><span class=\"line\">  .access(<span class=\"string\">'accept'</span>)</span><br><span class=\"line\">  .getter(<span class=\"string\">'origin'</span>)</span><br><span class=\"line\">  .getter(<span class=\"string\">'href'</span>)</span><br><span class=\"line\">  .getter(<span class=\"string\">'subdomains'</span>)</span><br><span class=\"line\">  .getter(<span class=\"string\">'protocol'</span>)</span><br><span class=\"line\">  .getter(<span class=\"string\">'host'</span>)</span><br><span class=\"line\">  .getter(<span class=\"string\">'hostname'</span>)</span><br><span class=\"line\">  .getter(<span class=\"string\">'URL'</span>)</span><br><span class=\"line\">  .getter(<span class=\"string\">'header'</span>)</span><br><span class=\"line\">  .getter(<span class=\"string\">'headers'</span>)</span><br><span class=\"line\">  .getter(<span class=\"string\">'secure'</span>)</span><br><span class=\"line\">  .getter(<span class=\"string\">'stale'</span>)</span><br><span class=\"line\">  .getter(<span class=\"string\">'fresh'</span>)</span><br><span class=\"line\">  .getter(<span class=\"string\">'ips'</span>)</span><br><span class=\"line\">  .getter(<span class=\"string\">'ip'</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Request-amp-Response\"><a href=\"#Request-amp-Response\" class=\"headerlink\" title=\"Request &amp; Response\"></a>Request &amp; Response</h2><p>request.js 和 response.js 分别声明了上面 context.request 和 context.response 对象的原型。</p>\n<p>在这些原型上声明了很多语法糖方法。比如 <code>ctx.status = 200</code> 和  <code>const status = ctx.status</code> 都是我们上面所说的 ctx 对 response 对象的代理。而 <code>response[set status]</code> 和 <code>response[get status]</code> 实现如下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Get response status code.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;Number&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * @api public</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">get</span> status() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.res.statusCode;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Set response status code.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Number&#125; code</span></span><br><span class=\"line\"><span class=\"comment\"> * @api public</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">set</span> status(code) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.headerSent) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  assert(<span class=\"built_in\">Number</span>.isInteger(code), <span class=\"string\">'status code must be a number'</span>);</span><br><span class=\"line\">  assert(code &gt;= <span class=\"number\">100</span> &amp;&amp; code &lt;= <span class=\"number\">999</span>, <span class=\"string\">`invalid status code: <span class=\"subst\">$&#123;code&#125;</span>`</span>);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>._explicitStatus = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.res.statusCode = code;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.req.httpVersionMajor &lt; <span class=\"number\">2</span>) <span class=\"keyword\">this</span>.res.statusMessage = statuses[code];</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.body &amp;&amp; statuses.empty[code]) <span class=\"keyword\">this</span>.body = <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}